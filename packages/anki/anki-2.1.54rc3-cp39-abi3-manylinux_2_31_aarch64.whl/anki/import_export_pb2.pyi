"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import anki.cards_pb2
import anki.collection_pb2
import anki.generic_pb2
import anki.notes_pb2
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class ImportCollectionPackageRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    COL_PATH_FIELD_NUMBER: builtins.int
    BACKUP_PATH_FIELD_NUMBER: builtins.int
    MEDIA_FOLDER_FIELD_NUMBER: builtins.int
    MEDIA_DB_FIELD_NUMBER: builtins.int
    col_path: typing.Text
    backup_path: typing.Text
    media_folder: typing.Text
    media_db: typing.Text
    def __init__(self,
        *,
        col_path: typing.Text = ...,
        backup_path: typing.Text = ...,
        media_folder: typing.Text = ...,
        media_db: typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["backup_path",b"backup_path","col_path",b"col_path","media_db",b"media_db","media_folder",b"media_folder"]) -> None: ...
global___ImportCollectionPackageRequest = ImportCollectionPackageRequest

class ExportCollectionPackageRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    OUT_PATH_FIELD_NUMBER: builtins.int
    INCLUDE_MEDIA_FIELD_NUMBER: builtins.int
    LEGACY_FIELD_NUMBER: builtins.int
    out_path: typing.Text
    include_media: builtins.bool
    legacy: builtins.bool
    def __init__(self,
        *,
        out_path: typing.Text = ...,
        include_media: builtins.bool = ...,
        legacy: builtins.bool = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["include_media",b"include_media","legacy",b"legacy","out_path",b"out_path"]) -> None: ...
global___ExportCollectionPackageRequest = ExportCollectionPackageRequest

class ImportAnkiPackageRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    PACKAGE_PATH_FIELD_NUMBER: builtins.int
    package_path: typing.Text
    def __init__(self,
        *,
        package_path: typing.Text = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["package_path",b"package_path"]) -> None: ...
global___ImportAnkiPackageRequest = ImportAnkiPackageRequest

class ImportResponse(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class Note(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        ID_FIELD_NUMBER: builtins.int
        FIELDS_FIELD_NUMBER: builtins.int
        @property
        def id(self) -> anki.notes_pb2.NoteId: ...
        @property
        def fields(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]: ...
        def __init__(self,
            *,
            id: typing.Optional[anki.notes_pb2.NoteId] = ...,
            fields: typing.Optional[typing.Iterable[typing.Text]] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["id",b"id"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["fields",b"fields","id",b"id"]) -> None: ...

    class Log(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        NEW_FIELD_NUMBER: builtins.int
        UPDATED_FIELD_NUMBER: builtins.int
        DUPLICATE_FIELD_NUMBER: builtins.int
        CONFLICTING_FIELD_NUMBER: builtins.int
        FIRST_FIELD_MATCH_FIELD_NUMBER: builtins.int
        MISSING_NOTETYPE_FIELD_NUMBER: builtins.int
        MISSING_DECK_FIELD_NUMBER: builtins.int
        EMPTY_FIRST_FIELD_FIELD_NUMBER: builtins.int
        DUPE_RESOLUTION_FIELD_NUMBER: builtins.int
        FOUND_NOTES_FIELD_NUMBER: builtins.int
        @property
        def new(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ImportResponse.Note]: ...
        @property
        def updated(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ImportResponse.Note]: ...
        @property
        def duplicate(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ImportResponse.Note]: ...
        @property
        def conflicting(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ImportResponse.Note]: ...
        @property
        def first_field_match(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ImportResponse.Note]: ...
        @property
        def missing_notetype(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ImportResponse.Note]: ...
        @property
        def missing_deck(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ImportResponse.Note]: ...
        @property
        def empty_first_field(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ImportResponse.Note]: ...
        dupe_resolution: global___ImportCsvRequest.DupeResolution.ValueType
        found_notes: builtins.int
        """Usually the sum of all queues, but may be lower if multiple duplicates
        have been updated with the same note.
        """

        def __init__(self,
            *,
            new: typing.Optional[typing.Iterable[global___ImportResponse.Note]] = ...,
            updated: typing.Optional[typing.Iterable[global___ImportResponse.Note]] = ...,
            duplicate: typing.Optional[typing.Iterable[global___ImportResponse.Note]] = ...,
            conflicting: typing.Optional[typing.Iterable[global___ImportResponse.Note]] = ...,
            first_field_match: typing.Optional[typing.Iterable[global___ImportResponse.Note]] = ...,
            missing_notetype: typing.Optional[typing.Iterable[global___ImportResponse.Note]] = ...,
            missing_deck: typing.Optional[typing.Iterable[global___ImportResponse.Note]] = ...,
            empty_first_field: typing.Optional[typing.Iterable[global___ImportResponse.Note]] = ...,
            dupe_resolution: global___ImportCsvRequest.DupeResolution.ValueType = ...,
            found_notes: builtins.int = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["conflicting",b"conflicting","dupe_resolution",b"dupe_resolution","duplicate",b"duplicate","empty_first_field",b"empty_first_field","first_field_match",b"first_field_match","found_notes",b"found_notes","missing_deck",b"missing_deck","missing_notetype",b"missing_notetype","new",b"new","updated",b"updated"]) -> None: ...

    CHANGES_FIELD_NUMBER: builtins.int
    LOG_FIELD_NUMBER: builtins.int
    @property
    def changes(self) -> anki.collection_pb2.OpChanges: ...
    @property
    def log(self) -> global___ImportResponse.Log: ...
    def __init__(self,
        *,
        changes: typing.Optional[anki.collection_pb2.OpChanges] = ...,
        log: typing.Optional[global___ImportResponse.Log] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["changes",b"changes","log",b"log"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["changes",b"changes","log",b"log"]) -> None: ...
global___ImportResponse = ImportResponse

class ExportAnkiPackageRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    OUT_PATH_FIELD_NUMBER: builtins.int
    WITH_SCHEDULING_FIELD_NUMBER: builtins.int
    WITH_MEDIA_FIELD_NUMBER: builtins.int
    LEGACY_FIELD_NUMBER: builtins.int
    LIMIT_FIELD_NUMBER: builtins.int
    out_path: typing.Text
    with_scheduling: builtins.bool
    with_media: builtins.bool
    legacy: builtins.bool
    @property
    def limit(self) -> global___ExportLimit: ...
    def __init__(self,
        *,
        out_path: typing.Text = ...,
        with_scheduling: builtins.bool = ...,
        with_media: builtins.bool = ...,
        legacy: builtins.bool = ...,
        limit: typing.Optional[global___ExportLimit] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["limit",b"limit"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["legacy",b"legacy","limit",b"limit","out_path",b"out_path","with_media",b"with_media","with_scheduling",b"with_scheduling"]) -> None: ...
global___ExportAnkiPackageRequest = ExportAnkiPackageRequest

class PackageMetadata(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Version:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _VersionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[PackageMetadata._Version.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        VERSION_UNKNOWN: PackageMetadata._Version.ValueType  # 0
        VERSION_LEGACY_1: PackageMetadata._Version.ValueType  # 1
        """When `meta` missing, and collection.anki2 file present."""

        VERSION_LEGACY_2: PackageMetadata._Version.ValueType  # 2
        """When `meta` missing, and collection.anki21 file present."""

        VERSION_LATEST: PackageMetadata._Version.ValueType  # 3
        """Implies MediaEntry media map, and zstd compression.
        collection.21b file
        """

    class Version(_Version, metaclass=_VersionEnumTypeWrapper):
        pass

    VERSION_UNKNOWN: PackageMetadata.Version.ValueType  # 0
    VERSION_LEGACY_1: PackageMetadata.Version.ValueType  # 1
    """When `meta` missing, and collection.anki2 file present."""

    VERSION_LEGACY_2: PackageMetadata.Version.ValueType  # 2
    """When `meta` missing, and collection.anki21 file present."""

    VERSION_LATEST: PackageMetadata.Version.ValueType  # 3
    """Implies MediaEntry media map, and zstd compression.
    collection.21b file
    """


    VERSION_FIELD_NUMBER: builtins.int
    version: global___PackageMetadata.Version.ValueType
    def __init__(self,
        *,
        version: global___PackageMetadata.Version.ValueType = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["version",b"version"]) -> None: ...
global___PackageMetadata = PackageMetadata

class MediaEntries(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class MediaEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        NAME_FIELD_NUMBER: builtins.int
        SIZE_FIELD_NUMBER: builtins.int
        SHA1_FIELD_NUMBER: builtins.int
        LEGACY_ZIP_FILENAME_FIELD_NUMBER: builtins.int
        name: typing.Text
        size: builtins.int
        sha1: builtins.bytes
        legacy_zip_filename: builtins.int
        """/ Legacy media maps may include gaps in the media list, so the original
        / file index is recorded when importing from a HashMap. This field is not
        / set when exporting.
        """

        def __init__(self,
            *,
            name: typing.Text = ...,
            size: builtins.int = ...,
            sha1: builtins.bytes = ...,
            legacy_zip_filename: typing.Optional[builtins.int] = ...,
            ) -> None: ...
        def HasField(self, field_name: typing_extensions.Literal["_legacy_zip_filename",b"_legacy_zip_filename","legacy_zip_filename",b"legacy_zip_filename"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing_extensions.Literal["_legacy_zip_filename",b"_legacy_zip_filename","legacy_zip_filename",b"legacy_zip_filename","name",b"name","sha1",b"sha1","size",b"size"]) -> None: ...
        def WhichOneof(self, oneof_group: typing_extensions.Literal["_legacy_zip_filename",b"_legacy_zip_filename"]) -> typing.Optional[typing_extensions.Literal["legacy_zip_filename"]]: ...

    ENTRIES_FIELD_NUMBER: builtins.int
    @property
    def entries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___MediaEntries.MediaEntry]: ...
    def __init__(self,
        *,
        entries: typing.Optional[typing.Iterable[global___MediaEntries.MediaEntry]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal["entries",b"entries"]) -> None: ...
global___MediaEntries = MediaEntries

class ImportCsvRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _DupeResolution:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _DupeResolutionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ImportCsvRequest._DupeResolution.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        UPDATE: ImportCsvRequest._DupeResolution.ValueType  # 0
        ADD: ImportCsvRequest._DupeResolution.ValueType  # 1
        IGNORE: ImportCsvRequest._DupeResolution.ValueType  # 2
        """UPDATE_IF_NEWER = 3;"""

    class DupeResolution(_DupeResolution, metaclass=_DupeResolutionEnumTypeWrapper):
        pass

    UPDATE: ImportCsvRequest.DupeResolution.ValueType  # 0
    ADD: ImportCsvRequest.DupeResolution.ValueType  # 1
    IGNORE: ImportCsvRequest.DupeResolution.ValueType  # 2
    """UPDATE_IF_NEWER = 3;"""


    PATH_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    DUPE_RESOLUTION_FIELD_NUMBER: builtins.int
    path: typing.Text
    @property
    def metadata(self) -> global___CsvMetadata: ...
    dupe_resolution: global___ImportCsvRequest.DupeResolution.ValueType
    def __init__(self,
        *,
        path: typing.Text = ...,
        metadata: typing.Optional[global___CsvMetadata] = ...,
        dupe_resolution: global___ImportCsvRequest.DupeResolution.ValueType = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["metadata",b"metadata"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["dupe_resolution",b"dupe_resolution","metadata",b"metadata","path",b"path"]) -> None: ...
global___ImportCsvRequest = ImportCsvRequest

class CsvMetadataRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    PATH_FIELD_NUMBER: builtins.int
    DELIMITER_FIELD_NUMBER: builtins.int
    NOTETYPE_ID_FIELD_NUMBER: builtins.int
    IS_HTML_FIELD_NUMBER: builtins.int
    path: typing.Text
    delimiter: global___CsvMetadata.Delimiter.ValueType
    notetype_id: builtins.int
    is_html: builtins.bool
    def __init__(self,
        *,
        path: typing.Text = ...,
        delimiter: typing.Optional[global___CsvMetadata.Delimiter.ValueType] = ...,
        notetype_id: typing.Optional[builtins.int] = ...,
        is_html: typing.Optional[builtins.bool] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["_delimiter",b"_delimiter","_is_html",b"_is_html","_notetype_id",b"_notetype_id","delimiter",b"delimiter","is_html",b"is_html","notetype_id",b"notetype_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["_delimiter",b"_delimiter","_is_html",b"_is_html","_notetype_id",b"_notetype_id","delimiter",b"delimiter","is_html",b"is_html","notetype_id",b"notetype_id","path",b"path"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_delimiter",b"_delimiter"]) -> typing.Optional[typing_extensions.Literal["delimiter"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_is_html",b"_is_html"]) -> typing.Optional[typing_extensions.Literal["is_html"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["_notetype_id",b"_notetype_id"]) -> typing.Optional[typing_extensions.Literal["notetype_id"]]: ...
global___CsvMetadataRequest = CsvMetadataRequest

class CsvMetadata(google.protobuf.message.Message):
    """Column indices are 1-based to make working with them in TS easier, where
    unset numerical fields default to 0.
    """
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    class _Delimiter:
        ValueType = typing.NewType('ValueType', builtins.int)
        V: typing_extensions.TypeAlias = ValueType
    class _DelimiterEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[CsvMetadata._Delimiter.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        TAB: CsvMetadata._Delimiter.ValueType  # 0
        PIPE: CsvMetadata._Delimiter.ValueType  # 1
        SEMICOLON: CsvMetadata._Delimiter.ValueType  # 2
        COLON: CsvMetadata._Delimiter.ValueType  # 3
        COMMA: CsvMetadata._Delimiter.ValueType  # 4
        SPACE: CsvMetadata._Delimiter.ValueType  # 5
    class Delimiter(_Delimiter, metaclass=_DelimiterEnumTypeWrapper):
        """Order roughly in ascending expected frequency in note text, because the
        delimiter detection algorithm is stupidly picking the first one it
        encounters.
        """
        pass

    TAB: CsvMetadata.Delimiter.ValueType  # 0
    PIPE: CsvMetadata.Delimiter.ValueType  # 1
    SEMICOLON: CsvMetadata.Delimiter.ValueType  # 2
    COLON: CsvMetadata.Delimiter.ValueType  # 3
    COMMA: CsvMetadata.Delimiter.ValueType  # 4
    SPACE: CsvMetadata.Delimiter.ValueType  # 5

    class MappedNotetype(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor
        ID_FIELD_NUMBER: builtins.int
        FIELD_COLUMNS_FIELD_NUMBER: builtins.int
        id: builtins.int
        @property
        def field_columns(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
            """Source column indices for note fields. One-based. 0 means n/a."""
            pass
        def __init__(self,
            *,
            id: builtins.int = ...,
            field_columns: typing.Optional[typing.Iterable[builtins.int]] = ...,
            ) -> None: ...
        def ClearField(self, field_name: typing_extensions.Literal["field_columns",b"field_columns","id",b"id"]) -> None: ...

    DELIMITER_FIELD_NUMBER: builtins.int
    IS_HTML_FIELD_NUMBER: builtins.int
    GLOBAL_TAGS_FIELD_NUMBER: builtins.int
    UPDATED_TAGS_FIELD_NUMBER: builtins.int
    COLUMN_LABELS_FIELD_NUMBER: builtins.int
    DECK_ID_FIELD_NUMBER: builtins.int
    DECK_COLUMN_FIELD_NUMBER: builtins.int
    GLOBAL_NOTETYPE_FIELD_NUMBER: builtins.int
    NOTETYPE_COLUMN_FIELD_NUMBER: builtins.int
    TAGS_COLUMN_FIELD_NUMBER: builtins.int
    FORCE_DELIMITER_FIELD_NUMBER: builtins.int
    FORCE_IS_HTML_FIELD_NUMBER: builtins.int
    PREVIEW_FIELD_NUMBER: builtins.int
    GUID_COLUMN_FIELD_NUMBER: builtins.int
    delimiter: global___CsvMetadata.Delimiter.ValueType
    is_html: builtins.bool
    @property
    def global_tags(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]: ...
    @property
    def updated_tags(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]: ...
    @property
    def column_labels(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[typing.Text]:
        """Column names as defined by the file or empty strings otherwise. Also used
        to determine the number of columns.
        """
        pass
    deck_id: builtins.int
    deck_column: builtins.int
    """One-based. 0 means n/a."""

    @property
    def global_notetype(self) -> global___CsvMetadata.MappedNotetype:
        """One notetype for all rows with given column mapping."""
        pass
    notetype_column: builtins.int
    """Row-specific notetypes with automatic mapping by index.
    One-based. 0 means n/a.
    """

    tags_column: builtins.int
    """One-based. 0 means n/a."""

    force_delimiter: builtins.bool
    force_is_html: builtins.bool
    @property
    def preview(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[anki.generic_pb2.StringList]: ...
    guid_column: builtins.int
    def __init__(self,
        *,
        delimiter: global___CsvMetadata.Delimiter.ValueType = ...,
        is_html: builtins.bool = ...,
        global_tags: typing.Optional[typing.Iterable[typing.Text]] = ...,
        updated_tags: typing.Optional[typing.Iterable[typing.Text]] = ...,
        column_labels: typing.Optional[typing.Iterable[typing.Text]] = ...,
        deck_id: builtins.int = ...,
        deck_column: builtins.int = ...,
        global_notetype: typing.Optional[global___CsvMetadata.MappedNotetype] = ...,
        notetype_column: builtins.int = ...,
        tags_column: builtins.int = ...,
        force_delimiter: builtins.bool = ...,
        force_is_html: builtins.bool = ...,
        preview: typing.Optional[typing.Iterable[anki.generic_pb2.StringList]] = ...,
        guid_column: builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["deck",b"deck","deck_column",b"deck_column","deck_id",b"deck_id","global_notetype",b"global_notetype","notetype",b"notetype","notetype_column",b"notetype_column"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["column_labels",b"column_labels","deck",b"deck","deck_column",b"deck_column","deck_id",b"deck_id","delimiter",b"delimiter","force_delimiter",b"force_delimiter","force_is_html",b"force_is_html","global_notetype",b"global_notetype","global_tags",b"global_tags","guid_column",b"guid_column","is_html",b"is_html","notetype",b"notetype","notetype_column",b"notetype_column","preview",b"preview","tags_column",b"tags_column","updated_tags",b"updated_tags"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["deck",b"deck"]) -> typing.Optional[typing_extensions.Literal["deck_id","deck_column"]]: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing_extensions.Literal["notetype",b"notetype"]) -> typing.Optional[typing_extensions.Literal["global_notetype","notetype_column"]]: ...
global___CsvMetadata = CsvMetadata

class ExportCardCsvRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    OUT_PATH_FIELD_NUMBER: builtins.int
    WITH_HTML_FIELD_NUMBER: builtins.int
    LIMIT_FIELD_NUMBER: builtins.int
    out_path: typing.Text
    with_html: builtins.bool
    @property
    def limit(self) -> global___ExportLimit: ...
    def __init__(self,
        *,
        out_path: typing.Text = ...,
        with_html: builtins.bool = ...,
        limit: typing.Optional[global___ExportLimit] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["limit",b"limit"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["limit",b"limit","out_path",b"out_path","with_html",b"with_html"]) -> None: ...
global___ExportCardCsvRequest = ExportCardCsvRequest

class ExportNoteCsvRequest(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    OUT_PATH_FIELD_NUMBER: builtins.int
    WITH_HTML_FIELD_NUMBER: builtins.int
    WITH_TAGS_FIELD_NUMBER: builtins.int
    WITH_DECK_FIELD_NUMBER: builtins.int
    WITH_NOTETYPE_FIELD_NUMBER: builtins.int
    WITH_GUID_FIELD_NUMBER: builtins.int
    LIMIT_FIELD_NUMBER: builtins.int
    out_path: typing.Text
    with_html: builtins.bool
    with_tags: builtins.bool
    with_deck: builtins.bool
    with_notetype: builtins.bool
    with_guid: builtins.bool
    @property
    def limit(self) -> global___ExportLimit: ...
    def __init__(self,
        *,
        out_path: typing.Text = ...,
        with_html: builtins.bool = ...,
        with_tags: builtins.bool = ...,
        with_deck: builtins.bool = ...,
        with_notetype: builtins.bool = ...,
        with_guid: builtins.bool = ...,
        limit: typing.Optional[global___ExportLimit] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["limit",b"limit"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["limit",b"limit","out_path",b"out_path","with_deck",b"with_deck","with_guid",b"with_guid","with_html",b"with_html","with_notetype",b"with_notetype","with_tags",b"with_tags"]) -> None: ...
global___ExportNoteCsvRequest = ExportNoteCsvRequest

class ExportLimit(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor
    WHOLE_COLLECTION_FIELD_NUMBER: builtins.int
    DECK_ID_FIELD_NUMBER: builtins.int
    NOTE_IDS_FIELD_NUMBER: builtins.int
    CARD_IDS_FIELD_NUMBER: builtins.int
    @property
    def whole_collection(self) -> anki.generic_pb2.Empty: ...
    deck_id: builtins.int
    @property
    def note_ids(self) -> anki.notes_pb2.NoteIds: ...
    @property
    def card_ids(self) -> anki.cards_pb2.CardIds: ...
    def __init__(self,
        *,
        whole_collection: typing.Optional[anki.generic_pb2.Empty] = ...,
        deck_id: builtins.int = ...,
        note_ids: typing.Optional[anki.notes_pb2.NoteIds] = ...,
        card_ids: typing.Optional[anki.cards_pb2.CardIds] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal["card_ids",b"card_ids","deck_id",b"deck_id","limit",b"limit","note_ids",b"note_ids","whole_collection",b"whole_collection"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal["card_ids",b"card_ids","deck_id",b"deck_id","limit",b"limit","note_ids",b"note_ids","whole_collection",b"whole_collection"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal["limit",b"limit"]) -> typing.Optional[typing_extensions.Literal["whole_collection","deck_id","note_ids","card_ids"]]: ...
global___ExportLimit = ExportLimit
