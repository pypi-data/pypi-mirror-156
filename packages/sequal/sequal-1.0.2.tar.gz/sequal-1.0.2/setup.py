# -*- coding: utf-8 -*-
from setuptools import setup

packages = \
['sequal']

package_data = \
{'': ['*']}

setup_kwargs = {
    'name': 'sequal',
    'version': '1.0.2',
    'description': 'A Python package for working with protein sequence and PTM',
    'long_description': '# SEQUAL / seq=\n\nSequal is developed as a python package for in-silico generation of modified sequences from a sequence input and modifications.\n\n## Dependencies\n\n`None.`\n\n## Usage\n\n\n### Sequence comprehension\n\n\n```python\nfrom sequal.sequence import Sequence\n#Using Sequence object with unmodified protein sequence\n\nseq = Sequence("TESTEST")\nprint(seq.seq) #should print "TESTEST"\nprint(seq[0:2]) #should print "TE"\n```\n\n```python\nfrom sequal.sequence import Sequence\n#Using Sequence object with modified protein sequence. []{}() could all be used as modification annotation. \n\nseq = Sequence("TEN[HexNAc]ST")\nfor i in seq.seq:\n    print(i, i.mods) #should print N [HexNAc] on the 3rd amino acid\n\nseq = Sequence("TEN[HexNAc][HexNAc]ST")\nfor i in seq.seq:\n    print(i, i.mods) #should print N [HexNAc, HexNAc] on the 3rd amino acid   \n\n# .mods property provides an access to all amino acids at this amino acid\n\nseq = Sequence("TE[HexNAc]NST", mod_position="left") #mod_position left indicate that the modification should be on the left of the amino acid instead of default which is right\nfor i in seq.seq:\n    print(i, i.mods) #should print N [HexNAc] on the 3rd amino acid\n```\n\n```python\nfrom sequal.sequence import Sequence\n#Format sequence with custom annotation\nseq = Sequence("TENST")\na = {1:"tes", 2:["1", "200"]}\nprint(seq.to_string_customize(a, individual_annotation_enclose=False, individual_annotation_separator="."))\n# By supplying .to_string_customize with a dictionary of position on the sequence that you wish to annotate\n# The above would print out TE[tes]N[1.200]ST\n```\n\n### Modification\n\n```python\nfrom sequal.modification import Modification\n\n# Create a modification object and try to find all its possible positions using regex\nmod = Modification("HexNAc", regex_pattern="N[^P][S|T]")\nfor ps, pe in mod.find_positions("TESNEST"):\n    print(ps, pe)\n    # this should print out the position 3 on the sequence as the start of the match and position 6 as the end of the match\n```\n\n```python\nfrom sequal.sequence import ModdedSequenceGenerator\nfrom sequal.modification import Modification\n\n# Examples for generation of modification combinations for a specific peptide\n\nnsequon = Modification("HexNAc",regex_pattern="N[^P][S|T]", mod_type="variable", labile=True)\nosequon = Modification("Mannose",regex_pattern="[S|T]", mod_type="variable", labile=True)\nsulfation = Modification("Sulfation",regex_pattern="S", mod_type="variable", labile=True)\ncarbox = Modification("Carboxylation",regex_pattern="E", mod_type="variable", labile=True)\ncarbox2 = Modification("Carboxylation2", regex_pattern="E", mod_type="variable", labile=True, mass=43.98983)\npropiona = Modification("Propionamide", regex_pattern="C", mod_type="static")\n\n#Static modification \n\nseq = "TECSNTT"\nmods = [propiona]\ng = ModdedSequenceGenerator(seq, static_mods=mods)\nfor i in g.generate():\n    print(i)\n    # this would print out a dictionary with key being the position of modifications and values being an array of all modifications can be generated at that site\n    # {2: [Propionamide]}\n\n#Variable modification\n\nmods = [nsequon, osequon, carbox]\ng = ModdedSequenceGenerator(seq, mods, [])\nprint(g.variable_map.mod_position_dict)\n#The object when supplied with an array of variable modifications would also create a dictionary of the modification and where they may be found\n#{\'HexNAc0\': [3], \'Mannose0\': [0, 2, 4, 5, 6], \'Carboxylation0\': [1]}\n\nfor i in g.generate():\n    print(i)\n    #Similar to the static modification example, this will create all possible combinations of variable modifications however it would also include ones without the modification\n    # {}\n    # {1: [Carboxylation0]}\n    # {6: [Mannose0]}\n    # {6: [Mannose0], 1: [Carboxylation0]}\n    # {5: [Mannose0]}\n    # {5: [Mannose0], 1: [Carboxylation0]}\n    # {5: [Mannose0], 6: [Mannose0]}\n    # {5: [Mannose0], 6: [Mannose0], 1: [Carboxylation0]}\n    # ...\n\n```\n### Mass spectrometry utilities\n\nHere is an examples for usage of the `mass_spectrometry` module within `sequal` in combination with modified sequence generation\n\n```python\nfrom sequal.mass_spectrometry import fragment_non_labile, fragment_labile\nfrom sequal.modification import Modification\nfrom sequal.sequence import ModdedSequenceGenerator, Sequence\n\nnsequon = Modification("HexNAc",regex_pattern="N[^P][S|T]", mod_type="variable", labile=True, labile_number=1, mass=203)\npropiona = Modification("Propionamide", regex_pattern="C", mod_type="static", mass=71)\n\n\nseq = "TECSNTT"\nstatic_mods = [propiona]\nvariable_mods = [nsequon]\n\n# Generating non labile b- and y- ions\n\ng = ModdedSequenceGenerator(seq, variable_mods, static_mods)\nfor i in g.generate():\n    print(i)\n    # Print the combination of modifications\n    s = Sequence(seq, mods=i)\n    print(s)\n    # Create new modified sequence object using the generated modifications and raw sequence string\n    for b, y in fragment_non_labile(s, "by"):\n        print(b, "b{}".format(b.fragment_number))\n        print(y, "y{}".format(y.fragment_number))\n        # Generate b- and y- non_labile ions objects based on the newly created sequence object\n\n# Generating only labile ions based on the input modification\n\ng = ModdedSequenceGenerator(seq, variable_mods, static_mods)\nfor i in g.generate():\n    s = Sequence(seq, mods=i)\n    ion = fragment_labile(s)\n    if ion.has_labile:\n        print(ion, "Y{}".format(ion.fragment_number))\n        # TEC[Propionamide]SN[HexNAc]TT Y1\n        print(ion.mz_calculate(1))\n        # 1011.277047\n\n```\n\n',
    'author': 'Toan K. Phung',
    'author_email': 'toan.phungkhoiquoctoan@gmail.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': None,
    'packages': packages,
    'package_data': package_data,
    'python_requires': '>=3.9,<4.0',
}


setup(**setup_kwargs)
