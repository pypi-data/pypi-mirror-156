// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.6

#include "pybase.h"
#include "py.Windows.UI.ViewManagement.h"


namespace py::cpp::Windows::UI::ViewManagement
{
    struct module_state
    {
        PyObject* type_ApplicationViewBoundsMode;
        PyObject* type_ApplicationViewMode;
        PyObject* type_ApplicationViewOrientation;
        PyObject* type_ApplicationViewState;
        PyObject* type_ApplicationViewSwitchingOptions;
        PyObject* type_ApplicationViewWindowingMode;
        PyObject* type_FullScreenSystemOverlayMode;
        PyObject* type_HandPreference;
        PyObject* type_ScreenCaptureDisabledBehavior;
        PyObject* type_UIColorType;
        PyObject* type_UIElementType;
        PyObject* type_UserInteractionMode;
        PyObject* type_ViewSizePreference;
        PyTypeObject* type_AccessibilitySettings;
        PyTypeObject* type_ActivationViewSwitcher;
        PyTypeObject* type_ApplicationView;
        PyTypeObject* type_ApplicationViewConsolidatedEventArgs;
        PyTypeObject* type_ApplicationViewScaling;
        PyTypeObject* type_ApplicationViewSwitcher;
        PyTypeObject* type_ApplicationViewTitleBar;
        PyTypeObject* type_ApplicationViewTransferContext;
        PyTypeObject* type_InputPane;
        PyTypeObject* type_InputPaneVisibilityEventArgs;
        PyTypeObject* type_ProjectionManager;
        PyTypeObject* type_StatusBar;
        PyTypeObject* type_StatusBarProgressIndicator;
        PyTypeObject* type_UISettings;
        PyTypeObject* type_UISettingsAnimationsEnabledChangedEventArgs;
        PyTypeObject* type_UISettingsAutoHideScrollBarsChangedEventArgs;
        PyTypeObject* type_UISettingsMessageDurationChangedEventArgs;
        PyTypeObject* type_UIViewSettings;
        PyTypeObject* type_ViewModePreferences;
    };

    static PyObject* register_ApplicationViewBoundsMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ApplicationViewBoundsMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ApplicationViewBoundsMode = type;
        Py_INCREF(state->type_ApplicationViewBoundsMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_ApplicationViewMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ApplicationViewMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ApplicationViewMode = type;
        Py_INCREF(state->type_ApplicationViewMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_ApplicationViewOrientation(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ApplicationViewOrientation)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ApplicationViewOrientation = type;
        Py_INCREF(state->type_ApplicationViewOrientation);


        Py_RETURN_NONE;
    }

    static PyObject* register_ApplicationViewState(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ApplicationViewState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ApplicationViewState = type;
        Py_INCREF(state->type_ApplicationViewState);


        Py_RETURN_NONE;
    }

    static PyObject* register_ApplicationViewSwitchingOptions(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ApplicationViewSwitchingOptions)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ApplicationViewSwitchingOptions = type;
        Py_INCREF(state->type_ApplicationViewSwitchingOptions);


        Py_RETURN_NONE;
    }

    static PyObject* register_ApplicationViewWindowingMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ApplicationViewWindowingMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ApplicationViewWindowingMode = type;
        Py_INCREF(state->type_ApplicationViewWindowingMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_FullScreenSystemOverlayMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_FullScreenSystemOverlayMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_FullScreenSystemOverlayMode = type;
        Py_INCREF(state->type_FullScreenSystemOverlayMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_HandPreference(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_HandPreference)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_HandPreference = type;
        Py_INCREF(state->type_HandPreference);


        Py_RETURN_NONE;
    }

    static PyObject* register_ScreenCaptureDisabledBehavior(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ScreenCaptureDisabledBehavior)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ScreenCaptureDisabledBehavior = type;
        Py_INCREF(state->type_ScreenCaptureDisabledBehavior);


        Py_RETURN_NONE;
    }

    static PyObject* register_UIColorType(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UIColorType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UIColorType = type;
        Py_INCREF(state->type_UIColorType);


        Py_RETURN_NONE;
    }

    static PyObject* register_UIElementType(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UIElementType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UIElementType = type;
        Py_INCREF(state->type_UIElementType);


        Py_RETURN_NONE;
    }

    static PyObject* register_UserInteractionMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UserInteractionMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UserInteractionMode = type;
        Py_INCREF(state->type_UserInteractionMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_ViewSizePreference(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ViewSizePreference)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ViewSizePreference = type;
        Py_INCREF(state->type_ViewSizePreference);


        Py_RETURN_NONE;
    }

    // ----- AccessibilitySettings class --------------------
    constexpr const char* const type_name_AccessibilitySettings = "AccessibilitySettings";

    static PyObject* _new_AccessibilitySettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::ViewManagement::AccessibilitySettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AccessibilitySettings(py::wrapper::Windows::UI::ViewManagement::AccessibilitySettings* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AccessibilitySettings_get_HighContrast(py::wrapper::Windows::UI::ViewManagement::AccessibilitySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HighContrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessibilitySettings_get_HighContrastScheme(py::wrapper::Windows::UI::ViewManagement::AccessibilitySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HighContrastScheme());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessibilitySettings_add_HighContrastChanged(py::wrapper::Windows::UI::ViewManagement::AccessibilitySettings* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::AccessibilitySettings, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.HighContrastChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AccessibilitySettings_remove_HighContrastChanged(py::wrapper::Windows::UI::ViewManagement::AccessibilitySettings* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HighContrastChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AccessibilitySettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::AccessibilitySettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AccessibilitySettings[] = {
        { "add_high_contrast_changed", reinterpret_cast<PyCFunction>(AccessibilitySettings_add_HighContrastChanged), METH_O, nullptr },
        { "remove_high_contrast_changed", reinterpret_cast<PyCFunction>(AccessibilitySettings_remove_HighContrastChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AccessibilitySettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AccessibilitySettings[] = {
        { "high_contrast", reinterpret_cast<getter>(AccessibilitySettings_get_HighContrast), nullptr, nullptr, nullptr },
        { "high_contrast_scheme", reinterpret_cast<getter>(AccessibilitySettings_get_HighContrastScheme), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AccessibilitySettings[] = 
    {
        { Py_tp_new, _new_AccessibilitySettings },
        { Py_tp_dealloc, _dealloc_AccessibilitySettings },
        { Py_tp_methods, _methods_AccessibilitySettings },
        { Py_tp_getset, _getset_AccessibilitySettings },
        { },
    };

    static PyType_Spec type_spec_AccessibilitySettings =
    {
        "_winsdk_Windows_UI_ViewManagement.AccessibilitySettings",
        sizeof(py::wrapper::Windows::UI::ViewManagement::AccessibilitySettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AccessibilitySettings
    };

    // ----- ActivationViewSwitcher class --------------------
    constexpr const char* const type_name_ActivationViewSwitcher = "ActivationViewSwitcher";

    static PyObject* _new_ActivationViewSwitcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ActivationViewSwitcher);
        return nullptr;
    }

    static void _dealloc_ActivationViewSwitcher(py::wrapper::Windows::UI::ViewManagement::ActivationViewSwitcher* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivationViewSwitcher_IsViewPresentedOnActivationVirtualDesktop(py::wrapper::Windows::UI::ViewManagement::ActivationViewSwitcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.IsViewPresentedOnActivationVirtualDesktop(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationViewSwitcher_ShowAsStandaloneAsync(py::wrapper::Windows::UI::ViewManagement::ActivationViewSwitcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.ShowAsStandaloneAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewSizePreference>(args, 1);

                return py::convert(self->obj.ShowAsStandaloneAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ActivationViewSwitcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::ActivationViewSwitcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivationViewSwitcher[] = {
        { "is_view_presented_on_activation_virtual_desktop", reinterpret_cast<PyCFunction>(ActivationViewSwitcher_IsViewPresentedOnActivationVirtualDesktop), METH_VARARGS, nullptr },
        { "show_as_standalone_async", reinterpret_cast<PyCFunction>(ActivationViewSwitcher_ShowAsStandaloneAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivationViewSwitcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivationViewSwitcher[] = {
        { }
    };

    static PyType_Slot _type_slots_ActivationViewSwitcher[] = 
    {
        { Py_tp_new, _new_ActivationViewSwitcher },
        { Py_tp_dealloc, _dealloc_ActivationViewSwitcher },
        { Py_tp_methods, _methods_ActivationViewSwitcher },
        { Py_tp_getset, _getset_ActivationViewSwitcher },
        { },
    };

    static PyType_Spec type_spec_ActivationViewSwitcher =
    {
        "_winsdk_Windows_UI_ViewManagement.ActivationViewSwitcher",
        sizeof(py::wrapper::Windows::UI::ViewManagement::ActivationViewSwitcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivationViewSwitcher
    };

    // ----- ApplicationView class --------------------
    constexpr const char* const type_name_ApplicationView = "ApplicationView";

    static PyObject* _new_ApplicationView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ApplicationView);
        return nullptr;
    }

    static void _dealloc_ApplicationView(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ApplicationView_ClearAllPersistedState(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::ViewManagement::ApplicationView::ClearAllPersistedState();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_ClearPersistedState(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::UI::ViewManagement::ApplicationView::ClearPersistedState(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_ExitFullScreenMode(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ExitFullScreenMode();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_GetApplicationViewIdForWindow(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Core::ICoreWindow>(args, 0);

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationView::GetApplicationViewIdForWindow(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_GetDisplayRegions(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDisplayRegions());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationView::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_IsViewModeSupported(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ApplicationViewMode>(args, 0);

                return py::convert(self->obj.IsViewModeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_SetDesiredBoundsMode(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ApplicationViewBoundsMode>(args, 0);

                return py::convert(self->obj.SetDesiredBoundsMode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_SetPreferredMinSize(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                self->obj.SetPreferredMinSize(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_ShowStandardSystemOverlays(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ShowStandardSystemOverlays();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_TryConsolidateAsync(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryConsolidateAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_TryEnterFullScreenMode(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryEnterFullScreenMode());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_TryEnterViewModeAsync(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ApplicationViewMode>(args, 0);

                return py::convert(self->obj.TryEnterViewModeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ApplicationViewMode>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewModePreferences>(args, 1);

                return py::convert(self->obj.TryEnterViewModeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_TryResizeView(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                return py::convert(self->obj.TryResizeView(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_TryUnsnap(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationView::TryUnsnap());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_TryUnsnapToFullscreen(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationView::TryUnsnapToFullscreen());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_Title(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationView_put_Title(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationView_get_IsScreenCaptureEnabled(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsScreenCaptureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationView_put_IsScreenCaptureEnabled(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsScreenCaptureEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationView_get_AdjacentToLeftDisplayEdge(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdjacentToLeftDisplayEdge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_AdjacentToRightDisplayEdge(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdjacentToRightDisplayEdge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_Id(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_IsFullScreen(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsFullScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_IsOnLockScreen(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOnLockScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_Orientation(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_SuppressSystemOverlays(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuppressSystemOverlays());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationView_put_SuppressSystemOverlays(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SuppressSystemOverlays(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationView_get_VisibleBounds(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VisibleBounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_DesiredBoundsMode(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredBoundsMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_FullScreenSystemOverlayMode(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FullScreenSystemOverlayMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationView_put_FullScreenSystemOverlayMode(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::FullScreenSystemOverlayMode>(arg);

            self->obj.FullScreenSystemOverlayMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationView_get_TitleBar(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TitleBar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_IsFullScreenMode(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsFullScreenMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_ViewMode(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ViewMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_PersistedStateId(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PersistedStateId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationView_put_PersistedStateId(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PersistedStateId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationView_get_WindowingEnvironment(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WindowingEnvironment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_UIContext(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UIContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_Value(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::ViewManagement::ApplicationView::Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_TerminateAppOnFinalViewClose(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::ViewManagement::ApplicationView::TerminateAppOnFinalViewClose());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_put_TerminateAppOnFinalViewClose(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        try
        {
            auto param0 = py::convert_to<bool>(arg);

            winrt::Windows::UI::ViewManagement::ApplicationView::TerminateAppOnFinalViewClose(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_PreferredLaunchWindowingMode(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::ViewManagement::ApplicationView::PreferredLaunchWindowingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_put_PreferredLaunchWindowingMode(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ApplicationViewWindowingMode>(arg);

            winrt::Windows::UI::ViewManagement::ApplicationView::PreferredLaunchWindowingMode(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_get_PreferredLaunchViewSize(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::ViewManagement::ApplicationView::PreferredLaunchViewSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_put_PreferredLaunchViewSize(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            winrt::Windows::UI::ViewManagement::ApplicationView::PreferredLaunchViewSize(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_add_Consolidated(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::ApplicationView, winrt::Windows::UI::ViewManagement::ApplicationViewConsolidatedEventArgs>>(arg);

            return py::convert(self->obj.Consolidated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_remove_Consolidated(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Consolidated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_add_VisibleBoundsChanged(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::ApplicationView, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VisibleBoundsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationView_remove_VisibleBoundsChanged(py::wrapper::Windows::UI::ViewManagement::ApplicationView* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VisibleBoundsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ApplicationView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::ApplicationView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationView[] = {
        { "clear_all_persisted_state", reinterpret_cast<PyCFunction>(ApplicationView_ClearAllPersistedState), METH_VARARGS | METH_STATIC, nullptr },
        { "clear_persisted_state", reinterpret_cast<PyCFunction>(ApplicationView_ClearPersistedState), METH_VARARGS | METH_STATIC, nullptr },
        { "exit_full_screen_mode", reinterpret_cast<PyCFunction>(ApplicationView_ExitFullScreenMode), METH_VARARGS, nullptr },
        { "get_application_view_id_for_window", reinterpret_cast<PyCFunction>(ApplicationView_GetApplicationViewIdForWindow), METH_VARARGS | METH_STATIC, nullptr },
        { "get_display_regions", reinterpret_cast<PyCFunction>(ApplicationView_GetDisplayRegions), METH_VARARGS, nullptr },
        { "get_for_current_view", reinterpret_cast<PyCFunction>(ApplicationView_GetForCurrentView), METH_VARARGS | METH_STATIC, nullptr },
        { "is_view_mode_supported", reinterpret_cast<PyCFunction>(ApplicationView_IsViewModeSupported), METH_VARARGS, nullptr },
        { "set_desired_bounds_mode", reinterpret_cast<PyCFunction>(ApplicationView_SetDesiredBoundsMode), METH_VARARGS, nullptr },
        { "set_preferred_min_size", reinterpret_cast<PyCFunction>(ApplicationView_SetPreferredMinSize), METH_VARARGS, nullptr },
        { "show_standard_system_overlays", reinterpret_cast<PyCFunction>(ApplicationView_ShowStandardSystemOverlays), METH_VARARGS, nullptr },
        { "try_consolidate_async", reinterpret_cast<PyCFunction>(ApplicationView_TryConsolidateAsync), METH_VARARGS, nullptr },
        { "try_enter_full_screen_mode", reinterpret_cast<PyCFunction>(ApplicationView_TryEnterFullScreenMode), METH_VARARGS, nullptr },
        { "try_enter_view_mode_async", reinterpret_cast<PyCFunction>(ApplicationView_TryEnterViewModeAsync), METH_VARARGS, nullptr },
        { "try_resize_view", reinterpret_cast<PyCFunction>(ApplicationView_TryResizeView), METH_VARARGS, nullptr },
        { "try_unsnap", reinterpret_cast<PyCFunction>(ApplicationView_TryUnsnap), METH_VARARGS | METH_STATIC, nullptr },
        { "try_unsnap_to_fullscreen", reinterpret_cast<PyCFunction>(ApplicationView_TryUnsnapToFullscreen), METH_VARARGS | METH_STATIC, nullptr },
        { "get_value", reinterpret_cast<PyCFunction>(ApplicationView_get_Value), METH_NOARGS | METH_STATIC, nullptr },
        { "get_terminate_app_on_final_view_close", reinterpret_cast<PyCFunction>(ApplicationView_get_TerminateAppOnFinalViewClose), METH_NOARGS | METH_STATIC, nullptr },
        { "put_terminate_app_on_final_view_close", reinterpret_cast<PyCFunction>(ApplicationView_put_TerminateAppOnFinalViewClose), METH_O | METH_STATIC, nullptr },
        { "get_preferred_launch_windowing_mode", reinterpret_cast<PyCFunction>(ApplicationView_get_PreferredLaunchWindowingMode), METH_NOARGS | METH_STATIC, nullptr },
        { "put_preferred_launch_windowing_mode", reinterpret_cast<PyCFunction>(ApplicationView_put_PreferredLaunchWindowingMode), METH_O | METH_STATIC, nullptr },
        { "get_preferred_launch_view_size", reinterpret_cast<PyCFunction>(ApplicationView_get_PreferredLaunchViewSize), METH_NOARGS | METH_STATIC, nullptr },
        { "put_preferred_launch_view_size", reinterpret_cast<PyCFunction>(ApplicationView_put_PreferredLaunchViewSize), METH_O | METH_STATIC, nullptr },
        { "add_consolidated", reinterpret_cast<PyCFunction>(ApplicationView_add_Consolidated), METH_O, nullptr },
        { "remove_consolidated", reinterpret_cast<PyCFunction>(ApplicationView_remove_Consolidated), METH_O, nullptr },
        { "add_visible_bounds_changed", reinterpret_cast<PyCFunction>(ApplicationView_add_VisibleBoundsChanged), METH_O, nullptr },
        { "remove_visible_bounds_changed", reinterpret_cast<PyCFunction>(ApplicationView_remove_VisibleBoundsChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationView[] = {
        { "title", reinterpret_cast<getter>(ApplicationView_get_Title), reinterpret_cast<setter>(ApplicationView_put_Title), nullptr, nullptr },
        { "is_screen_capture_enabled", reinterpret_cast<getter>(ApplicationView_get_IsScreenCaptureEnabled), reinterpret_cast<setter>(ApplicationView_put_IsScreenCaptureEnabled), nullptr, nullptr },
        { "adjacent_to_left_display_edge", reinterpret_cast<getter>(ApplicationView_get_AdjacentToLeftDisplayEdge), nullptr, nullptr, nullptr },
        { "adjacent_to_right_display_edge", reinterpret_cast<getter>(ApplicationView_get_AdjacentToRightDisplayEdge), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ApplicationView_get_Id), nullptr, nullptr, nullptr },
        { "is_full_screen", reinterpret_cast<getter>(ApplicationView_get_IsFullScreen), nullptr, nullptr, nullptr },
        { "is_on_lock_screen", reinterpret_cast<getter>(ApplicationView_get_IsOnLockScreen), nullptr, nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(ApplicationView_get_Orientation), nullptr, nullptr, nullptr },
        { "suppress_system_overlays", reinterpret_cast<getter>(ApplicationView_get_SuppressSystemOverlays), reinterpret_cast<setter>(ApplicationView_put_SuppressSystemOverlays), nullptr, nullptr },
        { "visible_bounds", reinterpret_cast<getter>(ApplicationView_get_VisibleBounds), nullptr, nullptr, nullptr },
        { "desired_bounds_mode", reinterpret_cast<getter>(ApplicationView_get_DesiredBoundsMode), nullptr, nullptr, nullptr },
        { "full_screen_system_overlay_mode", reinterpret_cast<getter>(ApplicationView_get_FullScreenSystemOverlayMode), reinterpret_cast<setter>(ApplicationView_put_FullScreenSystemOverlayMode), nullptr, nullptr },
        { "title_bar", reinterpret_cast<getter>(ApplicationView_get_TitleBar), nullptr, nullptr, nullptr },
        { "is_full_screen_mode", reinterpret_cast<getter>(ApplicationView_get_IsFullScreenMode), nullptr, nullptr, nullptr },
        { "view_mode", reinterpret_cast<getter>(ApplicationView_get_ViewMode), nullptr, nullptr, nullptr },
        { "persisted_state_id", reinterpret_cast<getter>(ApplicationView_get_PersistedStateId), reinterpret_cast<setter>(ApplicationView_put_PersistedStateId), nullptr, nullptr },
        { "windowing_environment", reinterpret_cast<getter>(ApplicationView_get_WindowingEnvironment), nullptr, nullptr, nullptr },
        { "u_i_context", reinterpret_cast<getter>(ApplicationView_get_UIContext), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ApplicationView[] = 
    {
        { Py_tp_new, _new_ApplicationView },
        { Py_tp_dealloc, _dealloc_ApplicationView },
        { Py_tp_methods, _methods_ApplicationView },
        { Py_tp_getset, _getset_ApplicationView },
        { },
    };

    static PyType_Spec type_spec_ApplicationView =
    {
        "_winsdk_Windows_UI_ViewManagement.ApplicationView",
        sizeof(py::wrapper::Windows::UI::ViewManagement::ApplicationView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationView
    };

    // ----- ApplicationViewConsolidatedEventArgs class --------------------
    constexpr const char* const type_name_ApplicationViewConsolidatedEventArgs = "ApplicationViewConsolidatedEventArgs";

    static PyObject* _new_ApplicationViewConsolidatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ApplicationViewConsolidatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ApplicationViewConsolidatedEventArgs(py::wrapper::Windows::UI::ViewManagement::ApplicationViewConsolidatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ApplicationViewConsolidatedEventArgs_get_IsUserInitiated(py::wrapper::Windows::UI::ViewManagement::ApplicationViewConsolidatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUserInitiated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ApplicationViewConsolidatedEventArgs_get_IsAppInitiated(py::wrapper::Windows::UI::ViewManagement::ApplicationViewConsolidatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAppInitiated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ApplicationViewConsolidatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::ApplicationViewConsolidatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationViewConsolidatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationViewConsolidatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationViewConsolidatedEventArgs[] = {
        { "is_user_initiated", reinterpret_cast<getter>(ApplicationViewConsolidatedEventArgs_get_IsUserInitiated), nullptr, nullptr, nullptr },
        { "is_app_initiated", reinterpret_cast<getter>(ApplicationViewConsolidatedEventArgs_get_IsAppInitiated), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ApplicationViewConsolidatedEventArgs[] = 
    {
        { Py_tp_new, _new_ApplicationViewConsolidatedEventArgs },
        { Py_tp_dealloc, _dealloc_ApplicationViewConsolidatedEventArgs },
        { Py_tp_methods, _methods_ApplicationViewConsolidatedEventArgs },
        { Py_tp_getset, _getset_ApplicationViewConsolidatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ApplicationViewConsolidatedEventArgs =
    {
        "_winsdk_Windows_UI_ViewManagement.ApplicationViewConsolidatedEventArgs",
        sizeof(py::wrapper::Windows::UI::ViewManagement::ApplicationViewConsolidatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationViewConsolidatedEventArgs
    };

    // ----- ApplicationViewScaling class --------------------
    constexpr const char* const type_name_ApplicationViewScaling = "ApplicationViewScaling";

    static PyObject* _new_ApplicationViewScaling(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ApplicationViewScaling);
        return nullptr;
    }

    static void _dealloc_ApplicationViewScaling(py::wrapper::Windows::UI::ViewManagement::ApplicationViewScaling* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ApplicationViewScaling_TrySetDisableLayoutScaling(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewScaling::TrySetDisableLayoutScaling(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationViewScaling_get_DisableLayoutScaling(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewScaling::DisableLayoutScaling());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ApplicationViewScaling(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::ApplicationViewScaling>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationViewScaling[] = {
        { "try_set_disable_layout_scaling", reinterpret_cast<PyCFunction>(ApplicationViewScaling_TrySetDisableLayoutScaling), METH_VARARGS | METH_STATIC, nullptr },
        { "get_disable_layout_scaling", reinterpret_cast<PyCFunction>(ApplicationViewScaling_get_DisableLayoutScaling), METH_NOARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationViewScaling), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationViewScaling[] = {
        { }
    };

    static PyType_Slot _type_slots_ApplicationViewScaling[] = 
    {
        { Py_tp_new, _new_ApplicationViewScaling },
        { Py_tp_dealloc, _dealloc_ApplicationViewScaling },
        { Py_tp_methods, _methods_ApplicationViewScaling },
        { Py_tp_getset, _getset_ApplicationViewScaling },
        { },
    };

    static PyType_Spec type_spec_ApplicationViewScaling =
    {
        "_winsdk_Windows_UI_ViewManagement.ApplicationViewScaling",
        sizeof(py::wrapper::Windows::UI::ViewManagement::ApplicationViewScaling),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationViewScaling
    };

    // ----- ApplicationViewSwitcher class --------------------
    constexpr const char* const type_name_ApplicationViewSwitcher = "ApplicationViewSwitcher";

    static PyObject* _new_ApplicationViewSwitcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ApplicationViewSwitcher);
        return nullptr;
    }

    static PyObject* ApplicationViewSwitcher_DisableShowingMainViewOnActivation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher::DisableShowingMainViewOnActivation();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationViewSwitcher_DisableSystemViewActivationPolicy(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher::DisableSystemViewActivationPolicy();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationViewSwitcher_PrepareForCustomAnimatedSwitchAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::ViewManagement::ApplicationViewSwitchingOptions>(args, 2);

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher::PrepareForCustomAnimatedSwitchAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationViewSwitcher_SwitchAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher::SwitchAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher::SwitchAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::ViewManagement::ApplicationViewSwitchingOptions>(args, 2);

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher::SwitchAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationViewSwitcher_TryShowAsStandaloneAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher::TryShowAsStandaloneAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewSizePreference>(args, 1);

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher::TryShowAsStandaloneAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewSizePreference>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewSizePreference>(args, 3);

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher::TryShowAsStandaloneAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ApplicationViewSwitcher_TryShowAsViewModeAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::ViewManagement::ApplicationViewMode>(args, 1);

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher::TryShowAsViewModeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::ViewManagement::ApplicationViewMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewModePreferences>(args, 2);

                return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher::TryShowAsViewModeAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationViewSwitcher[] = {
        { "disable_showing_main_view_on_activation", reinterpret_cast<PyCFunction>(ApplicationViewSwitcher_DisableShowingMainViewOnActivation), METH_VARARGS | METH_STATIC, nullptr },
        { "disable_system_view_activation_policy", reinterpret_cast<PyCFunction>(ApplicationViewSwitcher_DisableSystemViewActivationPolicy), METH_VARARGS | METH_STATIC, nullptr },
        { "prepare_for_custom_animated_switch_async", reinterpret_cast<PyCFunction>(ApplicationViewSwitcher_PrepareForCustomAnimatedSwitchAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "switch_async", reinterpret_cast<PyCFunction>(ApplicationViewSwitcher_SwitchAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "try_show_as_standalone_async", reinterpret_cast<PyCFunction>(ApplicationViewSwitcher_TryShowAsStandaloneAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "try_show_as_view_mode_async", reinterpret_cast<PyCFunction>(ApplicationViewSwitcher_TryShowAsViewModeAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationViewSwitcher[] = {
        { }
    };

    static PyType_Slot _type_slots_ApplicationViewSwitcher[] = 
    {
        { Py_tp_new, _new_ApplicationViewSwitcher },
        { Py_tp_methods, _methods_ApplicationViewSwitcher },
        { Py_tp_getset, _getset_ApplicationViewSwitcher },
        { },
    };

    static PyType_Spec type_spec_ApplicationViewSwitcher =
    {
        "_winsdk_Windows_UI_ViewManagement.ApplicationViewSwitcher",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationViewSwitcher
    };

    // ----- ApplicationViewTitleBar class --------------------
    constexpr const char* const type_name_ApplicationViewTitleBar = "ApplicationViewTitleBar";

    static PyObject* _new_ApplicationViewTitleBar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ApplicationViewTitleBar);
        return nullptr;
    }

    static void _dealloc_ApplicationViewTitleBar(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ApplicationViewTitleBar_get_InactiveForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InactiveForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_InactiveForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.InactiveForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTitleBar_get_InactiveBackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InactiveBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_InactiveBackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.InactiveBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTitleBar_get_ForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_ForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTitleBar_get_ButtonPressedForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ButtonPressedForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_ButtonPressedForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonPressedForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTitleBar_get_ButtonPressedBackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ButtonPressedBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_ButtonPressedBackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonPressedBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTitleBar_get_ButtonInactiveForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ButtonInactiveForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_ButtonInactiveForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonInactiveForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTitleBar_get_ButtonInactiveBackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ButtonInactiveBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_ButtonInactiveBackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonInactiveBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTitleBar_get_ButtonHoverForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ButtonHoverForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_ButtonHoverForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonHoverForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTitleBar_get_ButtonHoverBackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ButtonHoverBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_ButtonHoverBackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonHoverBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTitleBar_get_ButtonForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ButtonForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_ButtonForegroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTitleBar_get_ButtonBackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ButtonBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_ButtonBackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ButtonBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTitleBar_get_BackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTitleBar_put_BackgroundColor(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.BackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ApplicationViewTitleBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::ApplicationViewTitleBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationViewTitleBar[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationViewTitleBar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationViewTitleBar[] = {
        { "inactive_foreground_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_InactiveForegroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_InactiveForegroundColor), nullptr, nullptr },
        { "inactive_background_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_InactiveBackgroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_InactiveBackgroundColor), nullptr, nullptr },
        { "foreground_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_ForegroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_ForegroundColor), nullptr, nullptr },
        { "button_pressed_foreground_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_ButtonPressedForegroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_ButtonPressedForegroundColor), nullptr, nullptr },
        { "button_pressed_background_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_ButtonPressedBackgroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_ButtonPressedBackgroundColor), nullptr, nullptr },
        { "button_inactive_foreground_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_ButtonInactiveForegroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_ButtonInactiveForegroundColor), nullptr, nullptr },
        { "button_inactive_background_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_ButtonInactiveBackgroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_ButtonInactiveBackgroundColor), nullptr, nullptr },
        { "button_hover_foreground_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_ButtonHoverForegroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_ButtonHoverForegroundColor), nullptr, nullptr },
        { "button_hover_background_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_ButtonHoverBackgroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_ButtonHoverBackgroundColor), nullptr, nullptr },
        { "button_foreground_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_ButtonForegroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_ButtonForegroundColor), nullptr, nullptr },
        { "button_background_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_ButtonBackgroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_ButtonBackgroundColor), nullptr, nullptr },
        { "background_color", reinterpret_cast<getter>(ApplicationViewTitleBar_get_BackgroundColor), reinterpret_cast<setter>(ApplicationViewTitleBar_put_BackgroundColor), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ApplicationViewTitleBar[] = 
    {
        { Py_tp_new, _new_ApplicationViewTitleBar },
        { Py_tp_dealloc, _dealloc_ApplicationViewTitleBar },
        { Py_tp_methods, _methods_ApplicationViewTitleBar },
        { Py_tp_getset, _getset_ApplicationViewTitleBar },
        { },
    };

    static PyType_Spec type_spec_ApplicationViewTitleBar =
    {
        "_winsdk_Windows_UI_ViewManagement.ApplicationViewTitleBar",
        sizeof(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTitleBar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationViewTitleBar
    };

    // ----- ApplicationViewTransferContext class --------------------
    constexpr const char* const type_name_ApplicationViewTransferContext = "ApplicationViewTransferContext";

    static PyObject* _new_ApplicationViewTransferContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::ViewManagement::ApplicationViewTransferContext instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ApplicationViewTransferContext(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTransferContext* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ApplicationViewTransferContext_get_ViewId(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTransferContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ApplicationViewTransferContext_put_ViewId(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTransferContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ViewId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ApplicationViewTransferContext_get_DataPackageFormatId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::ViewManagement::ApplicationViewTransferContext::DataPackageFormatId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ApplicationViewTransferContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::ApplicationViewTransferContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ApplicationViewTransferContext[] = {
        { "get_data_package_format_id", reinterpret_cast<PyCFunction>(ApplicationViewTransferContext_get_DataPackageFormatId), METH_NOARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ApplicationViewTransferContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ApplicationViewTransferContext[] = {
        { "view_id", reinterpret_cast<getter>(ApplicationViewTransferContext_get_ViewId), reinterpret_cast<setter>(ApplicationViewTransferContext_put_ViewId), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ApplicationViewTransferContext[] = 
    {
        { Py_tp_new, _new_ApplicationViewTransferContext },
        { Py_tp_dealloc, _dealloc_ApplicationViewTransferContext },
        { Py_tp_methods, _methods_ApplicationViewTransferContext },
        { Py_tp_getset, _getset_ApplicationViewTransferContext },
        { },
    };

    static PyType_Spec type_spec_ApplicationViewTransferContext =
    {
        "_winsdk_Windows_UI_ViewManagement.ApplicationViewTransferContext",
        sizeof(py::wrapper::Windows::UI::ViewManagement::ApplicationViewTransferContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ApplicationViewTransferContext
    };

    // ----- InputPane class --------------------
    constexpr const char* const type_name_InputPane = "InputPane";

    static PyObject* _new_InputPane(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_InputPane);
        return nullptr;
    }

    static void _dealloc_InputPane(py::wrapper::Windows::UI::ViewManagement::InputPane* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputPane_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::ViewManagement::InputPane::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputPane_GetForUIContext(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::UIContext>(args, 0);

                return py::convert(winrt::Windows::UI::ViewManagement::InputPane::GetForUIContext(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputPane_TryHide(py::wrapper::Windows::UI::ViewManagement::InputPane* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryHide());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputPane_TryShow(py::wrapper::Windows::UI::ViewManagement::InputPane* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryShow());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputPane_get_OccludedRect(py::wrapper::Windows::UI::ViewManagement::InputPane* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OccludedRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPane_get_Visible(py::wrapper::Windows::UI::ViewManagement::InputPane* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Visible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InputPane_put_Visible(py::wrapper::Windows::UI::ViewManagement::InputPane* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Visible(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InputPane_add_Hiding(py::wrapper::Windows::UI::ViewManagement::InputPane* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::InputPane, winrt::Windows::UI::ViewManagement::InputPaneVisibilityEventArgs>>(arg);

            return py::convert(self->obj.Hiding(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPane_remove_Hiding(py::wrapper::Windows::UI::ViewManagement::InputPane* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Hiding(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPane_add_Showing(py::wrapper::Windows::UI::ViewManagement::InputPane* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::InputPane, winrt::Windows::UI::ViewManagement::InputPaneVisibilityEventArgs>>(arg);

            return py::convert(self->obj.Showing(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InputPane_remove_Showing(py::wrapper::Windows::UI::ViewManagement::InputPane* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Showing(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InputPane(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::InputPane>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputPane[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(InputPane_GetForCurrentView), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_u_i_context", reinterpret_cast<PyCFunction>(InputPane_GetForUIContext), METH_VARARGS | METH_STATIC, nullptr },
        { "try_hide", reinterpret_cast<PyCFunction>(InputPane_TryHide), METH_VARARGS, nullptr },
        { "try_show", reinterpret_cast<PyCFunction>(InputPane_TryShow), METH_VARARGS, nullptr },
        { "add_hiding", reinterpret_cast<PyCFunction>(InputPane_add_Hiding), METH_O, nullptr },
        { "remove_hiding", reinterpret_cast<PyCFunction>(InputPane_remove_Hiding), METH_O, nullptr },
        { "add_showing", reinterpret_cast<PyCFunction>(InputPane_add_Showing), METH_O, nullptr },
        { "remove_showing", reinterpret_cast<PyCFunction>(InputPane_remove_Showing), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputPane), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InputPane[] = {
        { "occluded_rect", reinterpret_cast<getter>(InputPane_get_OccludedRect), nullptr, nullptr, nullptr },
        { "visible", reinterpret_cast<getter>(InputPane_get_Visible), reinterpret_cast<setter>(InputPane_put_Visible), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InputPane[] = 
    {
        { Py_tp_new, _new_InputPane },
        { Py_tp_dealloc, _dealloc_InputPane },
        { Py_tp_methods, _methods_InputPane },
        { Py_tp_getset, _getset_InputPane },
        { },
    };

    static PyType_Spec type_spec_InputPane =
    {
        "_winsdk_Windows_UI_ViewManagement.InputPane",
        sizeof(py::wrapper::Windows::UI::ViewManagement::InputPane),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputPane
    };

    // ----- InputPaneVisibilityEventArgs class --------------------
    constexpr const char* const type_name_InputPaneVisibilityEventArgs = "InputPaneVisibilityEventArgs";

    static PyObject* _new_InputPaneVisibilityEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_InputPaneVisibilityEventArgs);
        return nullptr;
    }

    static void _dealloc_InputPaneVisibilityEventArgs(py::wrapper::Windows::UI::ViewManagement::InputPaneVisibilityEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InputPaneVisibilityEventArgs_get_EnsuredFocusedElementInView(py::wrapper::Windows::UI::ViewManagement::InputPaneVisibilityEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EnsuredFocusedElementInView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InputPaneVisibilityEventArgs_put_EnsuredFocusedElementInView(py::wrapper::Windows::UI::ViewManagement::InputPaneVisibilityEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.EnsuredFocusedElementInView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InputPaneVisibilityEventArgs_get_OccludedRect(py::wrapper::Windows::UI::ViewManagement::InputPaneVisibilityEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OccludedRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InputPaneVisibilityEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::InputPaneVisibilityEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputPaneVisibilityEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_InputPaneVisibilityEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InputPaneVisibilityEventArgs[] = {
        { "ensured_focused_element_in_view", reinterpret_cast<getter>(InputPaneVisibilityEventArgs_get_EnsuredFocusedElementInView), reinterpret_cast<setter>(InputPaneVisibilityEventArgs_put_EnsuredFocusedElementInView), nullptr, nullptr },
        { "occluded_rect", reinterpret_cast<getter>(InputPaneVisibilityEventArgs_get_OccludedRect), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InputPaneVisibilityEventArgs[] = 
    {
        { Py_tp_new, _new_InputPaneVisibilityEventArgs },
        { Py_tp_dealloc, _dealloc_InputPaneVisibilityEventArgs },
        { Py_tp_methods, _methods_InputPaneVisibilityEventArgs },
        { Py_tp_getset, _getset_InputPaneVisibilityEventArgs },
        { },
    };

    static PyType_Spec type_spec_InputPaneVisibilityEventArgs =
    {
        "_winsdk_Windows_UI_ViewManagement.InputPaneVisibilityEventArgs",
        sizeof(py::wrapper::Windows::UI::ViewManagement::InputPaneVisibilityEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputPaneVisibilityEventArgs
    };

    // ----- ProjectionManager class --------------------
    constexpr const char* const type_name_ProjectionManager = "ProjectionManager";

    static PyObject* _new_ProjectionManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProjectionManager);
        return nullptr;
    }

    static PyObject* ProjectionManager_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::ViewManagement::ProjectionManager::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProjectionManager_RequestStartProjectingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 2);

                return py::convert(winrt::Windows::UI::ViewManagement::ProjectionManager::RequestStartProjectingAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 3);

                return py::convert(winrt::Windows::UI::ViewManagement::ProjectionManager::RequestStartProjectingAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProjectionManager_StartProjectingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(winrt::Windows::UI::ViewManagement::ProjectionManager::StartProjectingAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 2);

                return py::convert(winrt::Windows::UI::ViewManagement::ProjectionManager::StartProjectingAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProjectionManager_StopProjectingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(winrt::Windows::UI::ViewManagement::ProjectionManager::StopProjectingAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProjectionManager_SwapDisplaysForViewsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(winrt::Windows::UI::ViewManagement::ProjectionManager::SwapDisplaysForViewsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProjectionManager_get_ProjectionDisplayAvailable(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::ViewManagement::ProjectionManager::ProjectionDisplayAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProjectionManager_add_ProjectionDisplayAvailableChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::UI::ViewManagement::ProjectionManager::ProjectionDisplayAvailableChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProjectionManager_remove_ProjectionDisplayAvailableChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::UI::ViewManagement::ProjectionManager::ProjectionDisplayAvailableChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProjectionManager[] = {
        { "get_device_selector", reinterpret_cast<PyCFunction>(ProjectionManager_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "request_start_projecting_async", reinterpret_cast<PyCFunction>(ProjectionManager_RequestStartProjectingAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "start_projecting_async", reinterpret_cast<PyCFunction>(ProjectionManager_StartProjectingAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "stop_projecting_async", reinterpret_cast<PyCFunction>(ProjectionManager_StopProjectingAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "swap_displays_for_views_async", reinterpret_cast<PyCFunction>(ProjectionManager_SwapDisplaysForViewsAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_projection_display_available", reinterpret_cast<PyCFunction>(ProjectionManager_get_ProjectionDisplayAvailable), METH_NOARGS | METH_STATIC, nullptr },
        { "add_projection_display_available_changed", reinterpret_cast<PyCFunction>(ProjectionManager_add_ProjectionDisplayAvailableChanged), METH_O | METH_STATIC, nullptr },
        { "remove_projection_display_available_changed", reinterpret_cast<PyCFunction>(ProjectionManager_remove_ProjectionDisplayAvailableChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProjectionManager[] = {
        { }
    };

    static PyType_Slot _type_slots_ProjectionManager[] = 
    {
        { Py_tp_new, _new_ProjectionManager },
        { Py_tp_methods, _methods_ProjectionManager },
        { Py_tp_getset, _getset_ProjectionManager },
        { },
    };

    static PyType_Spec type_spec_ProjectionManager =
    {
        "_winsdk_Windows_UI_ViewManagement.ProjectionManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProjectionManager
    };

    // ----- StatusBar class --------------------
    constexpr const char* const type_name_StatusBar = "StatusBar";

    static PyObject* _new_StatusBar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StatusBar);
        return nullptr;
    }

    static void _dealloc_StatusBar(py::wrapper::Windows::UI::ViewManagement::StatusBar* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StatusBar_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::ViewManagement::StatusBar::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StatusBar_HideAsync(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.HideAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StatusBar_ShowAsync(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ShowAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StatusBar_get_ForegroundColor(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForegroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StatusBar_put_ForegroundColor(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.ForegroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StatusBar_get_BackgroundOpacity(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BackgroundOpacity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StatusBar_put_BackgroundOpacity(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.BackgroundOpacity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StatusBar_get_BackgroundColor(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StatusBar_put_BackgroundColor(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.BackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StatusBar_get_OccludedRect(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OccludedRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StatusBar_get_ProgressIndicator(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProgressIndicator());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StatusBar_add_Hiding(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::StatusBar, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Hiding(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StatusBar_remove_Hiding(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Hiding(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StatusBar_add_Showing(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::StatusBar, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Showing(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StatusBar_remove_Showing(py::wrapper::Windows::UI::ViewManagement::StatusBar* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Showing(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StatusBar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::StatusBar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StatusBar[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(StatusBar_GetForCurrentView), METH_VARARGS | METH_STATIC, nullptr },
        { "hide_async", reinterpret_cast<PyCFunction>(StatusBar_HideAsync), METH_VARARGS, nullptr },
        { "show_async", reinterpret_cast<PyCFunction>(StatusBar_ShowAsync), METH_VARARGS, nullptr },
        { "add_hiding", reinterpret_cast<PyCFunction>(StatusBar_add_Hiding), METH_O, nullptr },
        { "remove_hiding", reinterpret_cast<PyCFunction>(StatusBar_remove_Hiding), METH_O, nullptr },
        { "add_showing", reinterpret_cast<PyCFunction>(StatusBar_add_Showing), METH_O, nullptr },
        { "remove_showing", reinterpret_cast<PyCFunction>(StatusBar_remove_Showing), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StatusBar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StatusBar[] = {
        { "foreground_color", reinterpret_cast<getter>(StatusBar_get_ForegroundColor), reinterpret_cast<setter>(StatusBar_put_ForegroundColor), nullptr, nullptr },
        { "background_opacity", reinterpret_cast<getter>(StatusBar_get_BackgroundOpacity), reinterpret_cast<setter>(StatusBar_put_BackgroundOpacity), nullptr, nullptr },
        { "background_color", reinterpret_cast<getter>(StatusBar_get_BackgroundColor), reinterpret_cast<setter>(StatusBar_put_BackgroundColor), nullptr, nullptr },
        { "occluded_rect", reinterpret_cast<getter>(StatusBar_get_OccludedRect), nullptr, nullptr, nullptr },
        { "progress_indicator", reinterpret_cast<getter>(StatusBar_get_ProgressIndicator), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StatusBar[] = 
    {
        { Py_tp_new, _new_StatusBar },
        { Py_tp_dealloc, _dealloc_StatusBar },
        { Py_tp_methods, _methods_StatusBar },
        { Py_tp_getset, _getset_StatusBar },
        { },
    };

    static PyType_Spec type_spec_StatusBar =
    {
        "_winsdk_Windows_UI_ViewManagement.StatusBar",
        sizeof(py::wrapper::Windows::UI::ViewManagement::StatusBar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StatusBar
    };

    // ----- StatusBarProgressIndicator class --------------------
    constexpr const char* const type_name_StatusBarProgressIndicator = "StatusBarProgressIndicator";

    static PyObject* _new_StatusBarProgressIndicator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StatusBarProgressIndicator);
        return nullptr;
    }

    static void _dealloc_StatusBarProgressIndicator(py::wrapper::Windows::UI::ViewManagement::StatusBarProgressIndicator* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StatusBarProgressIndicator_HideAsync(py::wrapper::Windows::UI::ViewManagement::StatusBarProgressIndicator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.HideAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StatusBarProgressIndicator_ShowAsync(py::wrapper::Windows::UI::ViewManagement::StatusBarProgressIndicator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ShowAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StatusBarProgressIndicator_get_Text(py::wrapper::Windows::UI::ViewManagement::StatusBarProgressIndicator* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StatusBarProgressIndicator_put_Text(py::wrapper::Windows::UI::ViewManagement::StatusBarProgressIndicator* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StatusBarProgressIndicator_get_ProgressValue(py::wrapper::Windows::UI::ViewManagement::StatusBarProgressIndicator* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProgressValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StatusBarProgressIndicator_put_ProgressValue(py::wrapper::Windows::UI::ViewManagement::StatusBarProgressIndicator* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(arg);

            self->obj.ProgressValue(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StatusBarProgressIndicator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::StatusBarProgressIndicator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StatusBarProgressIndicator[] = {
        { "hide_async", reinterpret_cast<PyCFunction>(StatusBarProgressIndicator_HideAsync), METH_VARARGS, nullptr },
        { "show_async", reinterpret_cast<PyCFunction>(StatusBarProgressIndicator_ShowAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StatusBarProgressIndicator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StatusBarProgressIndicator[] = {
        { "text", reinterpret_cast<getter>(StatusBarProgressIndicator_get_Text), reinterpret_cast<setter>(StatusBarProgressIndicator_put_Text), nullptr, nullptr },
        { "progress_value", reinterpret_cast<getter>(StatusBarProgressIndicator_get_ProgressValue), reinterpret_cast<setter>(StatusBarProgressIndicator_put_ProgressValue), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StatusBarProgressIndicator[] = 
    {
        { Py_tp_new, _new_StatusBarProgressIndicator },
        { Py_tp_dealloc, _dealloc_StatusBarProgressIndicator },
        { Py_tp_methods, _methods_StatusBarProgressIndicator },
        { Py_tp_getset, _getset_StatusBarProgressIndicator },
        { },
    };

    static PyType_Spec type_spec_StatusBarProgressIndicator =
    {
        "_winsdk_Windows_UI_ViewManagement.StatusBarProgressIndicator",
        sizeof(py::wrapper::Windows::UI::ViewManagement::StatusBarProgressIndicator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StatusBarProgressIndicator
    };

    // ----- UISettings class --------------------
    constexpr const char* const type_name_UISettings = "UISettings";

    static PyObject* _new_UISettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::ViewManagement::UISettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UISettings(py::wrapper::Windows::UI::ViewManagement::UISettings* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UISettings_GetColorValue(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::UIColorType>(args, 0);

                return py::convert(self->obj.GetColorValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UISettings_UIElementColor(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::UIElementType>(args, 0);

                return py::convert(self->obj.UIElementColor(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UISettings_get_AnimationsEnabled(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AnimationsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_CaretBlinkRate(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CaretBlinkRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_CaretBrowsingEnabled(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CaretBrowsingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_CaretWidth(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CaretWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_CursorSize(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CursorSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_DoubleClickTime(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DoubleClickTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_HandPreference(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HandPreference());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_MessageDuration(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_MouseHoverTime(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MouseHoverTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_ScrollBarArrowSize(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScrollBarArrowSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_ScrollBarSize(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScrollBarSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_ScrollBarThumbBoxSize(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScrollBarThumbBoxSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_TextScaleFactor(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TextScaleFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_AdvancedEffectsEnabled(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdvancedEffectsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_get_AutoHideScrollBars(py::wrapper::Windows::UI::ViewManagement::UISettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoHideScrollBars());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_add_TextScaleFactorChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::UISettings, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.TextScaleFactorChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_remove_TextScaleFactorChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TextScaleFactorChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_add_ColorValuesChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::UISettings, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ColorValuesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_remove_ColorValuesChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ColorValuesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_add_AdvancedEffectsEnabledChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::UISettings, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AdvancedEffectsEnabledChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_remove_AdvancedEffectsEnabledChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AdvancedEffectsEnabledChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_add_AutoHideScrollBarsChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::UISettings, winrt::Windows::UI::ViewManagement::UISettingsAutoHideScrollBarsChangedEventArgs>>(arg);

            return py::convert(self->obj.AutoHideScrollBarsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_remove_AutoHideScrollBarsChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AutoHideScrollBarsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_add_AnimationsEnabledChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::UISettings, winrt::Windows::UI::ViewManagement::UISettingsAnimationsEnabledChangedEventArgs>>(arg);

            return py::convert(self->obj.AnimationsEnabledChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_remove_AnimationsEnabledChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AnimationsEnabledChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_add_MessageDurationChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::ViewManagement::UISettings, winrt::Windows::UI::ViewManagement::UISettingsMessageDurationChangedEventArgs>>(arg);

            return py::convert(self->obj.MessageDurationChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UISettings_remove_MessageDurationChanged(py::wrapper::Windows::UI::ViewManagement::UISettings* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageDurationChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UISettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::UISettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UISettings[] = {
        { "get_color_value", reinterpret_cast<PyCFunction>(UISettings_GetColorValue), METH_VARARGS, nullptr },
        { "u_i_element_color", reinterpret_cast<PyCFunction>(UISettings_UIElementColor), METH_VARARGS, nullptr },
        { "add_text_scale_factor_changed", reinterpret_cast<PyCFunction>(UISettings_add_TextScaleFactorChanged), METH_O, nullptr },
        { "remove_text_scale_factor_changed", reinterpret_cast<PyCFunction>(UISettings_remove_TextScaleFactorChanged), METH_O, nullptr },
        { "add_color_values_changed", reinterpret_cast<PyCFunction>(UISettings_add_ColorValuesChanged), METH_O, nullptr },
        { "remove_color_values_changed", reinterpret_cast<PyCFunction>(UISettings_remove_ColorValuesChanged), METH_O, nullptr },
        { "add_advanced_effects_enabled_changed", reinterpret_cast<PyCFunction>(UISettings_add_AdvancedEffectsEnabledChanged), METH_O, nullptr },
        { "remove_advanced_effects_enabled_changed", reinterpret_cast<PyCFunction>(UISettings_remove_AdvancedEffectsEnabledChanged), METH_O, nullptr },
        { "add_auto_hide_scroll_bars_changed", reinterpret_cast<PyCFunction>(UISettings_add_AutoHideScrollBarsChanged), METH_O, nullptr },
        { "remove_auto_hide_scroll_bars_changed", reinterpret_cast<PyCFunction>(UISettings_remove_AutoHideScrollBarsChanged), METH_O, nullptr },
        { "add_animations_enabled_changed", reinterpret_cast<PyCFunction>(UISettings_add_AnimationsEnabledChanged), METH_O, nullptr },
        { "remove_animations_enabled_changed", reinterpret_cast<PyCFunction>(UISettings_remove_AnimationsEnabledChanged), METH_O, nullptr },
        { "add_message_duration_changed", reinterpret_cast<PyCFunction>(UISettings_add_MessageDurationChanged), METH_O, nullptr },
        { "remove_message_duration_changed", reinterpret_cast<PyCFunction>(UISettings_remove_MessageDurationChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UISettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UISettings[] = {
        { "animations_enabled", reinterpret_cast<getter>(UISettings_get_AnimationsEnabled), nullptr, nullptr, nullptr },
        { "caret_blink_rate", reinterpret_cast<getter>(UISettings_get_CaretBlinkRate), nullptr, nullptr, nullptr },
        { "caret_browsing_enabled", reinterpret_cast<getter>(UISettings_get_CaretBrowsingEnabled), nullptr, nullptr, nullptr },
        { "caret_width", reinterpret_cast<getter>(UISettings_get_CaretWidth), nullptr, nullptr, nullptr },
        { "cursor_size", reinterpret_cast<getter>(UISettings_get_CursorSize), nullptr, nullptr, nullptr },
        { "double_click_time", reinterpret_cast<getter>(UISettings_get_DoubleClickTime), nullptr, nullptr, nullptr },
        { "hand_preference", reinterpret_cast<getter>(UISettings_get_HandPreference), nullptr, nullptr, nullptr },
        { "message_duration", reinterpret_cast<getter>(UISettings_get_MessageDuration), nullptr, nullptr, nullptr },
        { "mouse_hover_time", reinterpret_cast<getter>(UISettings_get_MouseHoverTime), nullptr, nullptr, nullptr },
        { "scroll_bar_arrow_size", reinterpret_cast<getter>(UISettings_get_ScrollBarArrowSize), nullptr, nullptr, nullptr },
        { "scroll_bar_size", reinterpret_cast<getter>(UISettings_get_ScrollBarSize), nullptr, nullptr, nullptr },
        { "scroll_bar_thumb_box_size", reinterpret_cast<getter>(UISettings_get_ScrollBarThumbBoxSize), nullptr, nullptr, nullptr },
        { "text_scale_factor", reinterpret_cast<getter>(UISettings_get_TextScaleFactor), nullptr, nullptr, nullptr },
        { "advanced_effects_enabled", reinterpret_cast<getter>(UISettings_get_AdvancedEffectsEnabled), nullptr, nullptr, nullptr },
        { "auto_hide_scroll_bars", reinterpret_cast<getter>(UISettings_get_AutoHideScrollBars), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UISettings[] = 
    {
        { Py_tp_new, _new_UISettings },
        { Py_tp_dealloc, _dealloc_UISettings },
        { Py_tp_methods, _methods_UISettings },
        { Py_tp_getset, _getset_UISettings },
        { },
    };

    static PyType_Spec type_spec_UISettings =
    {
        "_winsdk_Windows_UI_ViewManagement.UISettings",
        sizeof(py::wrapper::Windows::UI::ViewManagement::UISettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UISettings
    };

    // ----- UISettingsAnimationsEnabledChangedEventArgs class --------------------
    constexpr const char* const type_name_UISettingsAnimationsEnabledChangedEventArgs = "UISettingsAnimationsEnabledChangedEventArgs";

    static PyObject* _new_UISettingsAnimationsEnabledChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UISettingsAnimationsEnabledChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_UISettingsAnimationsEnabledChangedEventArgs(py::wrapper::Windows::UI::ViewManagement::UISettingsAnimationsEnabledChangedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _from_UISettingsAnimationsEnabledChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::UISettingsAnimationsEnabledChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UISettingsAnimationsEnabledChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UISettingsAnimationsEnabledChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UISettingsAnimationsEnabledChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_UISettingsAnimationsEnabledChangedEventArgs[] = 
    {
        { Py_tp_new, _new_UISettingsAnimationsEnabledChangedEventArgs },
        { Py_tp_dealloc, _dealloc_UISettingsAnimationsEnabledChangedEventArgs },
        { Py_tp_methods, _methods_UISettingsAnimationsEnabledChangedEventArgs },
        { Py_tp_getset, _getset_UISettingsAnimationsEnabledChangedEventArgs },
        { },
    };

    static PyType_Spec type_spec_UISettingsAnimationsEnabledChangedEventArgs =
    {
        "_winsdk_Windows_UI_ViewManagement.UISettingsAnimationsEnabledChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::ViewManagement::UISettingsAnimationsEnabledChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UISettingsAnimationsEnabledChangedEventArgs
    };

    // ----- UISettingsAutoHideScrollBarsChangedEventArgs class --------------------
    constexpr const char* const type_name_UISettingsAutoHideScrollBarsChangedEventArgs = "UISettingsAutoHideScrollBarsChangedEventArgs";

    static PyObject* _new_UISettingsAutoHideScrollBarsChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UISettingsAutoHideScrollBarsChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_UISettingsAutoHideScrollBarsChangedEventArgs(py::wrapper::Windows::UI::ViewManagement::UISettingsAutoHideScrollBarsChangedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _from_UISettingsAutoHideScrollBarsChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::UISettingsAutoHideScrollBarsChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UISettingsAutoHideScrollBarsChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UISettingsAutoHideScrollBarsChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UISettingsAutoHideScrollBarsChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_UISettingsAutoHideScrollBarsChangedEventArgs[] = 
    {
        { Py_tp_new, _new_UISettingsAutoHideScrollBarsChangedEventArgs },
        { Py_tp_dealloc, _dealloc_UISettingsAutoHideScrollBarsChangedEventArgs },
        { Py_tp_methods, _methods_UISettingsAutoHideScrollBarsChangedEventArgs },
        { Py_tp_getset, _getset_UISettingsAutoHideScrollBarsChangedEventArgs },
        { },
    };

    static PyType_Spec type_spec_UISettingsAutoHideScrollBarsChangedEventArgs =
    {
        "_winsdk_Windows_UI_ViewManagement.UISettingsAutoHideScrollBarsChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::ViewManagement::UISettingsAutoHideScrollBarsChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UISettingsAutoHideScrollBarsChangedEventArgs
    };

    // ----- UISettingsMessageDurationChangedEventArgs class --------------------
    constexpr const char* const type_name_UISettingsMessageDurationChangedEventArgs = "UISettingsMessageDurationChangedEventArgs";

    static PyObject* _new_UISettingsMessageDurationChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UISettingsMessageDurationChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_UISettingsMessageDurationChangedEventArgs(py::wrapper::Windows::UI::ViewManagement::UISettingsMessageDurationChangedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _from_UISettingsMessageDurationChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::UISettingsMessageDurationChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UISettingsMessageDurationChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UISettingsMessageDurationChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UISettingsMessageDurationChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_UISettingsMessageDurationChangedEventArgs[] = 
    {
        { Py_tp_new, _new_UISettingsMessageDurationChangedEventArgs },
        { Py_tp_dealloc, _dealloc_UISettingsMessageDurationChangedEventArgs },
        { Py_tp_methods, _methods_UISettingsMessageDurationChangedEventArgs },
        { Py_tp_getset, _getset_UISettingsMessageDurationChangedEventArgs },
        { },
    };

    static PyType_Spec type_spec_UISettingsMessageDurationChangedEventArgs =
    {
        "_winsdk_Windows_UI_ViewManagement.UISettingsMessageDurationChangedEventArgs",
        sizeof(py::wrapper::Windows::UI::ViewManagement::UISettingsMessageDurationChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UISettingsMessageDurationChangedEventArgs
    };

    // ----- UIViewSettings class --------------------
    constexpr const char* const type_name_UIViewSettings = "UIViewSettings";

    static PyObject* _new_UIViewSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UIViewSettings);
        return nullptr;
    }

    static void _dealloc_UIViewSettings(py::wrapper::Windows::UI::ViewManagement::UIViewSettings* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UIViewSettings_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::ViewManagement::UIViewSettings::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UIViewSettings_get_UserInteractionMode(py::wrapper::Windows::UI::ViewManagement::UIViewSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserInteractionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UIViewSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::UIViewSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UIViewSettings[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(UIViewSettings_GetForCurrentView), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UIViewSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UIViewSettings[] = {
        { "user_interaction_mode", reinterpret_cast<getter>(UIViewSettings_get_UserInteractionMode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UIViewSettings[] = 
    {
        { Py_tp_new, _new_UIViewSettings },
        { Py_tp_dealloc, _dealloc_UIViewSettings },
        { Py_tp_methods, _methods_UIViewSettings },
        { Py_tp_getset, _getset_UIViewSettings },
        { },
    };

    static PyType_Spec type_spec_UIViewSettings =
    {
        "_winsdk_Windows_UI_ViewManagement.UIViewSettings",
        sizeof(py::wrapper::Windows::UI::ViewManagement::UIViewSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UIViewSettings
    };

    // ----- ViewModePreferences class --------------------
    constexpr const char* const type_name_ViewModePreferences = "ViewModePreferences";

    static PyObject* _new_ViewModePreferences(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ViewModePreferences);
        return nullptr;
    }

    static void _dealloc_ViewModePreferences(py::wrapper::Windows::UI::ViewManagement::ViewModePreferences* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ViewModePreferences_CreateDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ApplicationViewMode>(args, 0);

                return py::convert(winrt::Windows::UI::ViewManagement::ViewModePreferences::CreateDefault(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ViewModePreferences_get_ViewSizePreference(py::wrapper::Windows::UI::ViewManagement::ViewModePreferences* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ViewSizePreference());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ViewModePreferences_put_ViewSizePreference(py::wrapper::Windows::UI::ViewManagement::ViewModePreferences* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::ViewManagement::ViewSizePreference>(arg);

            self->obj.ViewSizePreference(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ViewModePreferences_get_CustomSize(py::wrapper::Windows::UI::ViewManagement::ViewModePreferences* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CustomSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ViewModePreferences_put_CustomSize(py::wrapper::Windows::UI::ViewManagement::ViewModePreferences* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            self->obj.CustomSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ViewModePreferences(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::ViewManagement::ViewModePreferences>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ViewModePreferences[] = {
        { "create_default", reinterpret_cast<PyCFunction>(ViewModePreferences_CreateDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ViewModePreferences), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ViewModePreferences[] = {
        { "view_size_preference", reinterpret_cast<getter>(ViewModePreferences_get_ViewSizePreference), reinterpret_cast<setter>(ViewModePreferences_put_ViewSizePreference), nullptr, nullptr },
        { "custom_size", reinterpret_cast<getter>(ViewModePreferences_get_CustomSize), reinterpret_cast<setter>(ViewModePreferences_put_CustomSize), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ViewModePreferences[] = 
    {
        { Py_tp_new, _new_ViewModePreferences },
        { Py_tp_dealloc, _dealloc_ViewModePreferences },
        { Py_tp_methods, _methods_ViewModePreferences },
        { Py_tp_getset, _getset_ViewModePreferences },
        { },
    };

    static PyType_Spec type_spec_ViewModePreferences =
    {
        "_winsdk_Windows_UI_ViewManagement.ViewModePreferences",
        sizeof(py::wrapper::Windows::UI::ViewManagement::ViewModePreferences),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ViewModePreferences
    };

    // ----- Windows.UI.ViewManagement Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::ViewManagement");

    static PyMethodDef module_methods[] = {
        {"_register_ApplicationViewBoundsMode", register_ApplicationViewBoundsMode, METH_O, "registers type"},
        {"_register_ApplicationViewMode", register_ApplicationViewMode, METH_O, "registers type"},
        {"_register_ApplicationViewOrientation", register_ApplicationViewOrientation, METH_O, "registers type"},
        {"_register_ApplicationViewState", register_ApplicationViewState, METH_O, "registers type"},
        {"_register_ApplicationViewSwitchingOptions", register_ApplicationViewSwitchingOptions, METH_O, "registers type"},
        {"_register_ApplicationViewWindowingMode", register_ApplicationViewWindowingMode, METH_O, "registers type"},
        {"_register_FullScreenSystemOverlayMode", register_FullScreenSystemOverlayMode, METH_O, "registers type"},
        {"_register_HandPreference", register_HandPreference, METH_O, "registers type"},
        {"_register_ScreenCaptureDisabledBehavior", register_ScreenCaptureDisabledBehavior, METH_O, "registers type"},
        {"_register_UIColorType", register_UIColorType, METH_O, "registers type"},
        {"_register_UIElementType", register_UIElementType, METH_O, "registers type"},
        {"_register_UserInteractionMode", register_UserInteractionMode, METH_O, "registers type"},
        {"_register_ViewSizePreference", register_ViewSizePreference, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_ApplicationViewBoundsMode);
        Py_VISIT(state->type_ApplicationViewMode);
        Py_VISIT(state->type_ApplicationViewOrientation);
        Py_VISIT(state->type_ApplicationViewState);
        Py_VISIT(state->type_ApplicationViewSwitchingOptions);
        Py_VISIT(state->type_ApplicationViewWindowingMode);
        Py_VISIT(state->type_FullScreenSystemOverlayMode);
        Py_VISIT(state->type_HandPreference);
        Py_VISIT(state->type_ScreenCaptureDisabledBehavior);
        Py_VISIT(state->type_UIColorType);
        Py_VISIT(state->type_UIElementType);
        Py_VISIT(state->type_UserInteractionMode);
        Py_VISIT(state->type_ViewSizePreference);
        Py_VISIT(state->type_AccessibilitySettings);
        Py_VISIT(state->type_ActivationViewSwitcher);
        Py_VISIT(state->type_ApplicationView);
        Py_VISIT(state->type_ApplicationViewConsolidatedEventArgs);
        Py_VISIT(state->type_ApplicationViewScaling);
        Py_VISIT(state->type_ApplicationViewSwitcher);
        Py_VISIT(state->type_ApplicationViewTitleBar);
        Py_VISIT(state->type_ApplicationViewTransferContext);
        Py_VISIT(state->type_InputPane);
        Py_VISIT(state->type_InputPaneVisibilityEventArgs);
        Py_VISIT(state->type_ProjectionManager);
        Py_VISIT(state->type_StatusBar);
        Py_VISIT(state->type_StatusBarProgressIndicator);
        Py_VISIT(state->type_UISettings);
        Py_VISIT(state->type_UISettingsAnimationsEnabledChangedEventArgs);
        Py_VISIT(state->type_UISettingsAutoHideScrollBarsChangedEventArgs);
        Py_VISIT(state->type_UISettingsMessageDurationChangedEventArgs);
        Py_VISIT(state->type_UIViewSettings);
        Py_VISIT(state->type_ViewModePreferences);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_ApplicationViewBoundsMode);
        Py_CLEAR(state->type_ApplicationViewMode);
        Py_CLEAR(state->type_ApplicationViewOrientation);
        Py_CLEAR(state->type_ApplicationViewState);
        Py_CLEAR(state->type_ApplicationViewSwitchingOptions);
        Py_CLEAR(state->type_ApplicationViewWindowingMode);
        Py_CLEAR(state->type_FullScreenSystemOverlayMode);
        Py_CLEAR(state->type_HandPreference);
        Py_CLEAR(state->type_ScreenCaptureDisabledBehavior);
        Py_CLEAR(state->type_UIColorType);
        Py_CLEAR(state->type_UIElementType);
        Py_CLEAR(state->type_UserInteractionMode);
        Py_CLEAR(state->type_ViewSizePreference);
        Py_CLEAR(state->type_AccessibilitySettings);
        Py_CLEAR(state->type_ActivationViewSwitcher);
        Py_CLEAR(state->type_ApplicationView);
        Py_CLEAR(state->type_ApplicationViewConsolidatedEventArgs);
        Py_CLEAR(state->type_ApplicationViewScaling);
        Py_CLEAR(state->type_ApplicationViewSwitcher);
        Py_CLEAR(state->type_ApplicationViewTitleBar);
        Py_CLEAR(state->type_ApplicationViewTransferContext);
        Py_CLEAR(state->type_InputPane);
        Py_CLEAR(state->type_InputPaneVisibilityEventArgs);
        Py_CLEAR(state->type_ProjectionManager);
        Py_CLEAR(state->type_StatusBar);
        Py_CLEAR(state->type_StatusBarProgressIndicator);
        Py_CLEAR(state->type_UISettings);
        Py_CLEAR(state->type_UISettingsAnimationsEnabledChangedEventArgs);
        Py_CLEAR(state->type_UISettingsAutoHideScrollBarsChangedEventArgs);
        Py_CLEAR(state->type_UISettingsMessageDurationChangedEventArgs);
        Py_CLEAR(state->type_UIViewSettings);
        Py_CLEAR(state->type_ViewModePreferences);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_UI_ViewManagement",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::UI::ViewManagement

PyMODINIT_FUNC PyInit__winsdk_Windows_UI_ViewManagement(void) noexcept
{
    using namespace py::cpp::Windows::UI::ViewManagement;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_AccessibilitySettings = py::register_python_type(module.get(), type_name_AccessibilitySettings, &type_spec_AccessibilitySettings, bases.get());
    if (!state->type_AccessibilitySettings)
    {
        return nullptr;
    }

    Py_INCREF(state->type_AccessibilitySettings);

    state->type_ActivationViewSwitcher = py::register_python_type(module.get(), type_name_ActivationViewSwitcher, &type_spec_ActivationViewSwitcher, bases.get());
    if (!state->type_ActivationViewSwitcher)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ActivationViewSwitcher);

    state->type_ApplicationView = py::register_python_type(module.get(), type_name_ApplicationView, &type_spec_ApplicationView, bases.get());
    if (!state->type_ApplicationView)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ApplicationView);

    state->type_ApplicationViewConsolidatedEventArgs = py::register_python_type(module.get(), type_name_ApplicationViewConsolidatedEventArgs, &type_spec_ApplicationViewConsolidatedEventArgs, bases.get());
    if (!state->type_ApplicationViewConsolidatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ApplicationViewConsolidatedEventArgs);

    state->type_ApplicationViewScaling = py::register_python_type(module.get(), type_name_ApplicationViewScaling, &type_spec_ApplicationViewScaling, bases.get());
    if (!state->type_ApplicationViewScaling)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ApplicationViewScaling);

    state->type_ApplicationViewSwitcher = py::register_python_type(module.get(), type_name_ApplicationViewSwitcher, &type_spec_ApplicationViewSwitcher, nullptr);
    if (!state->type_ApplicationViewSwitcher)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ApplicationViewSwitcher);

    state->type_ApplicationViewTitleBar = py::register_python_type(module.get(), type_name_ApplicationViewTitleBar, &type_spec_ApplicationViewTitleBar, bases.get());
    if (!state->type_ApplicationViewTitleBar)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ApplicationViewTitleBar);

    state->type_ApplicationViewTransferContext = py::register_python_type(module.get(), type_name_ApplicationViewTransferContext, &type_spec_ApplicationViewTransferContext, bases.get());
    if (!state->type_ApplicationViewTransferContext)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ApplicationViewTransferContext);

    state->type_InputPane = py::register_python_type(module.get(), type_name_InputPane, &type_spec_InputPane, bases.get());
    if (!state->type_InputPane)
    {
        return nullptr;
    }

    Py_INCREF(state->type_InputPane);

    state->type_InputPaneVisibilityEventArgs = py::register_python_type(module.get(), type_name_InputPaneVisibilityEventArgs, &type_spec_InputPaneVisibilityEventArgs, bases.get());
    if (!state->type_InputPaneVisibilityEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_InputPaneVisibilityEventArgs);

    state->type_ProjectionManager = py::register_python_type(module.get(), type_name_ProjectionManager, &type_spec_ProjectionManager, nullptr);
    if (!state->type_ProjectionManager)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ProjectionManager);

    state->type_StatusBar = py::register_python_type(module.get(), type_name_StatusBar, &type_spec_StatusBar, bases.get());
    if (!state->type_StatusBar)
    {
        return nullptr;
    }

    Py_INCREF(state->type_StatusBar);

    state->type_StatusBarProgressIndicator = py::register_python_type(module.get(), type_name_StatusBarProgressIndicator, &type_spec_StatusBarProgressIndicator, bases.get());
    if (!state->type_StatusBarProgressIndicator)
    {
        return nullptr;
    }

    Py_INCREF(state->type_StatusBarProgressIndicator);

    state->type_UISettings = py::register_python_type(module.get(), type_name_UISettings, &type_spec_UISettings, bases.get());
    if (!state->type_UISettings)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UISettings);

    state->type_UISettingsAnimationsEnabledChangedEventArgs = py::register_python_type(module.get(), type_name_UISettingsAnimationsEnabledChangedEventArgs, &type_spec_UISettingsAnimationsEnabledChangedEventArgs, bases.get());
    if (!state->type_UISettingsAnimationsEnabledChangedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UISettingsAnimationsEnabledChangedEventArgs);

    state->type_UISettingsAutoHideScrollBarsChangedEventArgs = py::register_python_type(module.get(), type_name_UISettingsAutoHideScrollBarsChangedEventArgs, &type_spec_UISettingsAutoHideScrollBarsChangedEventArgs, bases.get());
    if (!state->type_UISettingsAutoHideScrollBarsChangedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UISettingsAutoHideScrollBarsChangedEventArgs);

    state->type_UISettingsMessageDurationChangedEventArgs = py::register_python_type(module.get(), type_name_UISettingsMessageDurationChangedEventArgs, &type_spec_UISettingsMessageDurationChangedEventArgs, bases.get());
    if (!state->type_UISettingsMessageDurationChangedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UISettingsMessageDurationChangedEventArgs);

    state->type_UIViewSettings = py::register_python_type(module.get(), type_name_UIViewSettings, &type_spec_UIViewSettings, bases.get());
    if (!state->type_UIViewSettings)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UIViewSettings);

    state->type_ViewModePreferences = py::register_python_type(module.get(), type_name_ViewModePreferences, &type_spec_ViewModePreferences, bases.get());
    if (!state->type_ViewModePreferences)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ViewModePreferences);


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::UI::ViewManagement::ApplicationViewBoundsMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ApplicationViewBoundsMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::ApplicationViewBoundsMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::ViewManagement::ApplicationViewMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ApplicationViewMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::ApplicationViewMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::ViewManagement::ApplicationViewOrientation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ApplicationViewOrientation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::ApplicationViewOrientation is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::ViewManagement::ApplicationViewState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ApplicationViewState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::ApplicationViewState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::ViewManagement::ApplicationViewSwitchingOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ApplicationViewSwitchingOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::ApplicationViewSwitchingOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::ViewManagement::ApplicationViewWindowingMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ApplicationViewWindowingMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::ApplicationViewWindowingMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::ViewManagement::FullScreenSystemOverlayMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FullScreenSystemOverlayMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::FullScreenSystemOverlayMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::ViewManagement::HandPreference>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HandPreference;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::HandPreference is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::ViewManagement::ScreenCaptureDisabledBehavior>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ScreenCaptureDisabledBehavior;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::ScreenCaptureDisabledBehavior is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::ViewManagement::UIColorType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UIColorType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::UIColorType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::ViewManagement::UIElementType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UIElementType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::UIElementType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::ViewManagement::UserInteractionMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UserInteractionMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::UserInteractionMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::ViewManagement::ViewSizePreference>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ViewSizePreference;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::ViewSizePreference is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::ViewManagement::AccessibilitySettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AccessibilitySettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::AccessibilitySettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::ViewManagement::ActivationViewSwitcher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ActivationViewSwitcher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::ActivationViewSwitcher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::ViewManagement::ApplicationView>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ApplicationView;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::ApplicationView is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::ViewManagement::ApplicationViewConsolidatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ApplicationViewConsolidatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::ApplicationViewConsolidatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::ViewManagement::ApplicationViewScaling>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ApplicationViewScaling;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::ApplicationViewScaling is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ApplicationViewSwitcher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::ApplicationViewSwitcher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::ViewManagement::ApplicationViewTitleBar>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ApplicationViewTitleBar;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::ApplicationViewTitleBar is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::ViewManagement::ApplicationViewTransferContext>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ApplicationViewTransferContext;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::ApplicationViewTransferContext is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::ViewManagement::InputPane>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InputPane;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::InputPane is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::ViewManagement::InputPaneVisibilityEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InputPaneVisibilityEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::InputPaneVisibilityEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::ViewManagement::ProjectionManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProjectionManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::ProjectionManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::ViewManagement::StatusBar>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StatusBar;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::StatusBar is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::ViewManagement::StatusBarProgressIndicator>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StatusBarProgressIndicator;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::StatusBarProgressIndicator is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::ViewManagement::UISettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UISettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::UISettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::ViewManagement::UISettingsAnimationsEnabledChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UISettingsAnimationsEnabledChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::UISettingsAnimationsEnabledChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::ViewManagement::UISettingsAutoHideScrollBarsChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UISettingsAutoHideScrollBarsChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::UISettingsAutoHideScrollBarsChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::ViewManagement::UISettingsMessageDurationChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UISettingsMessageDurationChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::UISettingsMessageDurationChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::ViewManagement::UIViewSettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UIViewSettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::UIViewSettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::ViewManagement::ViewModePreferences>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::ViewManagement;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::ViewManagement");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ViewModePreferences;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::ViewManagement::ViewModePreferences is not registered");
        return nullptr;
    }

    return python_type;
}
