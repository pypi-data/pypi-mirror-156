// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.6

#include "pybase.h"
#include "py.Windows.Graphics.Imaging.h"


PyObject* py::converter<winrt::Windows::Graphics::Imaging::BitmapBounds>::convert(winrt::Windows::Graphics::Imaging::BitmapBounds instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapBounds>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Graphics::Imaging::BitmapBounds py::converter<winrt::Windows::Graphics::Imaging::BitmapBounds>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapBounds>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapBounds>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Graphics::Imaging::BitmapBounds");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>::convert(winrt::Windows::Graphics::Imaging::BitmapPlaneDescription instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Graphics::Imaging::BitmapPlaneDescription py::converter<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Graphics::Imaging::BitmapPlaneDescription");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::Graphics::Imaging::BitmapSize>::convert(winrt::Windows::Graphics::Imaging::BitmapSize instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapSize>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Graphics::Imaging::BitmapSize py::converter<winrt::Windows::Graphics::Imaging::BitmapSize>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Graphics::Imaging::BitmapSize>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Graphics::Imaging::BitmapSize>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Graphics::Imaging::BitmapSize");
    throw python_exception();
}

namespace py::cpp::Windows::Graphics::Imaging
{
    struct module_state
    {
        PyObject* type_BitmapAlphaMode;
        PyObject* type_BitmapBufferAccessMode;
        PyObject* type_BitmapFlip;
        PyObject* type_BitmapInterpolationMode;
        PyObject* type_BitmapPixelFormat;
        PyObject* type_BitmapRotation;
        PyObject* type_ColorManagementMode;
        PyObject* type_ExifOrientationMode;
        PyObject* type_JpegSubsamplingMode;
        PyObject* type_PngFilterMode;
        PyObject* type_TiffCompressionMode;
        PyTypeObject* type_BitmapBuffer;
        PyTypeObject* type_BitmapCodecInformation;
        PyTypeObject* type_BitmapDecoder;
        PyTypeObject* type_BitmapEncoder;
        PyTypeObject* type_BitmapFrame;
        PyTypeObject* type_BitmapProperties;
        PyTypeObject* type_BitmapPropertiesView;
        PyTypeObject* type_BitmapPropertySet;
        PyTypeObject* type_BitmapTransform;
        PyTypeObject* type_BitmapTypedValue;
        PyTypeObject* type_ImageStream;
        PyTypeObject* type_PixelDataProvider;
        PyTypeObject* type_SoftwareBitmap;
        PyTypeObject* type_IBitmapFrame;
        PyTypeObject* type_IBitmapFrameWithSoftwareBitmap;
        PyTypeObject* type_IBitmapPropertiesView;
        PyTypeObject* type_BitmapBounds;
        PyTypeObject* type_BitmapPlaneDescription;
        PyTypeObject* type_BitmapSize;
    };

    static PyObject* register_BitmapAlphaMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BitmapAlphaMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BitmapAlphaMode = type;
        Py_INCREF(state->type_BitmapAlphaMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_BitmapBufferAccessMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BitmapBufferAccessMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BitmapBufferAccessMode = type;
        Py_INCREF(state->type_BitmapBufferAccessMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_BitmapFlip(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BitmapFlip)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BitmapFlip = type;
        Py_INCREF(state->type_BitmapFlip);


        Py_RETURN_NONE;
    }

    static PyObject* register_BitmapInterpolationMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BitmapInterpolationMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BitmapInterpolationMode = type;
        Py_INCREF(state->type_BitmapInterpolationMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_BitmapPixelFormat(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BitmapPixelFormat)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BitmapPixelFormat = type;
        Py_INCREF(state->type_BitmapPixelFormat);


        Py_RETURN_NONE;
    }

    static PyObject* register_BitmapRotation(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BitmapRotation)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BitmapRotation = type;
        Py_INCREF(state->type_BitmapRotation);


        Py_RETURN_NONE;
    }

    static PyObject* register_ColorManagementMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ColorManagementMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ColorManagementMode = type;
        Py_INCREF(state->type_ColorManagementMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_ExifOrientationMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ExifOrientationMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ExifOrientationMode = type;
        Py_INCREF(state->type_ExifOrientationMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_JpegSubsamplingMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_JpegSubsamplingMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_JpegSubsamplingMode = type;
        Py_INCREF(state->type_JpegSubsamplingMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_PngFilterMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PngFilterMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PngFilterMode = type;
        Py_INCREF(state->type_PngFilterMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_TiffCompressionMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TiffCompressionMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TiffCompressionMode = type;
        Py_INCREF(state->type_TiffCompressionMode);


        Py_RETURN_NONE;
    }

    // ----- BitmapBuffer class --------------------
    constexpr const char* const type_name_BitmapBuffer = "BitmapBuffer";

    static PyObject* _new_BitmapBuffer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BitmapBuffer);
        return nullptr;
    }

    static void _dealloc_BitmapBuffer(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapBuffer_Close(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapBuffer_CreateReference(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapBuffer_GetPlaneCount(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPlaneCount());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapBuffer_GetPlaneDescription(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.GetPlaneDescription(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_BitmapBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_BitmapBuffer(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_BitmapBuffer(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapBuffer[] = {
        { "close", reinterpret_cast<PyCFunction>(BitmapBuffer_Close), METH_VARARGS, nullptr },
        { "create_reference", reinterpret_cast<PyCFunction>(BitmapBuffer_CreateReference), METH_VARARGS, nullptr },
        { "get_plane_count", reinterpret_cast<PyCFunction>(BitmapBuffer_GetPlaneCount), METH_VARARGS, nullptr },
        { "get_plane_description", reinterpret_cast<PyCFunction>(BitmapBuffer_GetPlaneDescription), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapBuffer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_BitmapBuffer), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_BitmapBuffer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapBuffer[] = {
        { }
    };

    static PyType_Slot _type_slots_BitmapBuffer[] = 
    {
        { Py_tp_new, _new_BitmapBuffer },
        { Py_tp_dealloc, _dealloc_BitmapBuffer },
        { Py_tp_methods, _methods_BitmapBuffer },
        { Py_tp_getset, _getset_BitmapBuffer },
        { },
    };

    static PyType_Spec type_spec_BitmapBuffer =
    {
        "_winsdk_Windows_Graphics_Imaging.BitmapBuffer",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapBuffer
    };

    // ----- BitmapCodecInformation class --------------------
    constexpr const char* const type_name_BitmapCodecInformation = "BitmapCodecInformation";

    static PyObject* _new_BitmapCodecInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BitmapCodecInformation);
        return nullptr;
    }

    static void _dealloc_BitmapCodecInformation(py::wrapper::Windows::Graphics::Imaging::BitmapCodecInformation* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapCodecInformation_get_CodecId(py::wrapper::Windows::Graphics::Imaging::BitmapCodecInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CodecId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapCodecInformation_get_FileExtensions(py::wrapper::Windows::Graphics::Imaging::BitmapCodecInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileExtensions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapCodecInformation_get_FriendlyName(py::wrapper::Windows::Graphics::Imaging::BitmapCodecInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapCodecInformation_get_MimeTypes(py::wrapper::Windows::Graphics::Imaging::BitmapCodecInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MimeTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BitmapCodecInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapCodecInformation[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapCodecInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapCodecInformation[] = {
        { "codec_id", reinterpret_cast<getter>(BitmapCodecInformation_get_CodecId), nullptr, nullptr, nullptr },
        { "file_extensions", reinterpret_cast<getter>(BitmapCodecInformation_get_FileExtensions), nullptr, nullptr, nullptr },
        { "friendly_name", reinterpret_cast<getter>(BitmapCodecInformation_get_FriendlyName), nullptr, nullptr, nullptr },
        { "mime_types", reinterpret_cast<getter>(BitmapCodecInformation_get_MimeTypes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BitmapCodecInformation[] = 
    {
        { Py_tp_new, _new_BitmapCodecInformation },
        { Py_tp_dealloc, _dealloc_BitmapCodecInformation },
        { Py_tp_methods, _methods_BitmapCodecInformation },
        { Py_tp_getset, _getset_BitmapCodecInformation },
        { },
    };

    static PyType_Spec type_spec_BitmapCodecInformation =
    {
        "_winsdk_Windows_Graphics_Imaging.BitmapCodecInformation",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapCodecInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapCodecInformation
    };

    // ----- BitmapDecoder class --------------------
    constexpr const char* const type_name_BitmapDecoder = "BitmapDecoder";

    static PyObject* _new_BitmapDecoder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BitmapDecoder);
        return nullptr;
    }

    static void _dealloc_BitmapDecoder(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapDecoder_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::CreateAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::CreateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_GetDecoderInformationEnumerator(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::GetDecoderInformationEnumerator());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_GetFrameAsync(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetFrameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_GetPixelDataAsync(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPixelDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

                return py::convert(self->obj.GetPixelDataAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_GetPreviewAsync(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPreviewAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_GetSoftwareBitmapAsync(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSoftwareBitmapAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);

                return py::convert(self->obj.GetSoftwareBitmapAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

                return py::convert(self->obj.GetSoftwareBitmapAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_GetThumbnailAsync(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetThumbnailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_BitmapContainerProperties(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapContainerProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_DecoderInformation(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecoderInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_FrameCount(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_BitmapAlphaMode(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_BitmapPixelFormat(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_BitmapProperties(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_DpiX(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_DpiY(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_OrientedPixelHeight(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OrientedPixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_OrientedPixelWidth(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OrientedPixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_PixelHeight(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_PixelWidth(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_BmpDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::BmpDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_GifDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::GifDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_IcoDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::IcoDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_JpegDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::JpegDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_JpegXRDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::JpegXRDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_PngDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::PngDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_TiffDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::TiffDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_HeifDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::HeifDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapDecoder_get_WebpDecoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapDecoder::WebpDecoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BitmapDecoder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapDecoder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapDecoder[] = {
        { "create_async", reinterpret_cast<PyCFunction>(BitmapDecoder_CreateAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_decoder_information_enumerator", reinterpret_cast<PyCFunction>(BitmapDecoder_GetDecoderInformationEnumerator), METH_VARARGS | METH_STATIC, nullptr },
        { "get_frame_async", reinterpret_cast<PyCFunction>(BitmapDecoder_GetFrameAsync), METH_VARARGS, nullptr },
        { "get_pixel_data_async", reinterpret_cast<PyCFunction>(BitmapDecoder_GetPixelDataAsync), METH_VARARGS, nullptr },
        { "get_preview_async", reinterpret_cast<PyCFunction>(BitmapDecoder_GetPreviewAsync), METH_VARARGS, nullptr },
        { "get_software_bitmap_async", reinterpret_cast<PyCFunction>(BitmapDecoder_GetSoftwareBitmapAsync), METH_VARARGS, nullptr },
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(BitmapDecoder_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "get_bmp_decoder_id", reinterpret_cast<PyCFunction>(BitmapDecoder_get_BmpDecoderId), METH_NOARGS | METH_STATIC, nullptr },
        { "get_gif_decoder_id", reinterpret_cast<PyCFunction>(BitmapDecoder_get_GifDecoderId), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ico_decoder_id", reinterpret_cast<PyCFunction>(BitmapDecoder_get_IcoDecoderId), METH_NOARGS | METH_STATIC, nullptr },
        { "get_jpeg_decoder_id", reinterpret_cast<PyCFunction>(BitmapDecoder_get_JpegDecoderId), METH_NOARGS | METH_STATIC, nullptr },
        { "get_jpeg_x_r_decoder_id", reinterpret_cast<PyCFunction>(BitmapDecoder_get_JpegXRDecoderId), METH_NOARGS | METH_STATIC, nullptr },
        { "get_png_decoder_id", reinterpret_cast<PyCFunction>(BitmapDecoder_get_PngDecoderId), METH_NOARGS | METH_STATIC, nullptr },
        { "get_tiff_decoder_id", reinterpret_cast<PyCFunction>(BitmapDecoder_get_TiffDecoderId), METH_NOARGS | METH_STATIC, nullptr },
        { "get_heif_decoder_id", reinterpret_cast<PyCFunction>(BitmapDecoder_get_HeifDecoderId), METH_NOARGS | METH_STATIC, nullptr },
        { "get_webp_decoder_id", reinterpret_cast<PyCFunction>(BitmapDecoder_get_WebpDecoderId), METH_NOARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapDecoder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapDecoder[] = {
        { "bitmap_container_properties", reinterpret_cast<getter>(BitmapDecoder_get_BitmapContainerProperties), nullptr, nullptr, nullptr },
        { "decoder_information", reinterpret_cast<getter>(BitmapDecoder_get_DecoderInformation), nullptr, nullptr, nullptr },
        { "frame_count", reinterpret_cast<getter>(BitmapDecoder_get_FrameCount), nullptr, nullptr, nullptr },
        { "bitmap_alpha_mode", reinterpret_cast<getter>(BitmapDecoder_get_BitmapAlphaMode), nullptr, nullptr, nullptr },
        { "bitmap_pixel_format", reinterpret_cast<getter>(BitmapDecoder_get_BitmapPixelFormat), nullptr, nullptr, nullptr },
        { "bitmap_properties", reinterpret_cast<getter>(BitmapDecoder_get_BitmapProperties), nullptr, nullptr, nullptr },
        { "dpi_x", reinterpret_cast<getter>(BitmapDecoder_get_DpiX), nullptr, nullptr, nullptr },
        { "dpi_y", reinterpret_cast<getter>(BitmapDecoder_get_DpiY), nullptr, nullptr, nullptr },
        { "oriented_pixel_height", reinterpret_cast<getter>(BitmapDecoder_get_OrientedPixelHeight), nullptr, nullptr, nullptr },
        { "oriented_pixel_width", reinterpret_cast<getter>(BitmapDecoder_get_OrientedPixelWidth), nullptr, nullptr, nullptr },
        { "pixel_height", reinterpret_cast<getter>(BitmapDecoder_get_PixelHeight), nullptr, nullptr, nullptr },
        { "pixel_width", reinterpret_cast<getter>(BitmapDecoder_get_PixelWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BitmapDecoder[] = 
    {
        { Py_tp_new, _new_BitmapDecoder },
        { Py_tp_dealloc, _dealloc_BitmapDecoder },
        { Py_tp_methods, _methods_BitmapDecoder },
        { Py_tp_getset, _getset_BitmapDecoder },
        { },
    };

    static PyType_Spec type_spec_BitmapDecoder =
    {
        "_winsdk_Windows_Graphics_Imaging.BitmapDecoder",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapDecoder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapDecoder
    };

    // ----- BitmapEncoder class --------------------
    constexpr const char* const type_name_BitmapEncoder = "BitmapEncoder";

    static PyObject* _new_BitmapEncoder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BitmapEncoder);
        return nullptr;
    }

    static void _dealloc_BitmapEncoder(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapEncoder_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::CreateAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Graphics::Imaging::BitmapTypedValue>>>(args, 2);

                return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::CreateAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_CreateForInPlacePropertyEncodingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapDecoder>(args, 0);

                return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::CreateForInPlacePropertyEncodingAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_CreateForTranscodingAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapDecoder>(args, 1);

                return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::CreateForTranscodingAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_FlushAsync(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_GetEncoderInformationEnumerator(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::GetEncoderInformationEnumerator());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_GoToNextFrameAsync(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GoToNextFrameAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Graphics::Imaging::BitmapTypedValue>>>(args, 0);

                return py::convert(self->obj.GoToNextFrameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_SetPixelData(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<double>(args, 4);
                auto param5 = py::convert_to<double>(args, 5);
                auto param6 = py::convert_to<winrt::array_view<uint8_t>>(args, 6);

                self->obj.SetPixelData(param0, param1, param2, param3, param4, param5, param6);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_SetSoftwareBitmap(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);

                self->obj.SetSoftwareBitmap(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_IsThumbnailGenerated(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsThumbnailGenerated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapEncoder_put_IsThumbnailGenerated(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsThumbnailGenerated(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapEncoder_get_GeneratedThumbnailWidth(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.GeneratedThumbnailWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapEncoder_put_GeneratedThumbnailWidth(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.GeneratedThumbnailWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapEncoder_get_GeneratedThumbnailHeight(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.GeneratedThumbnailHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapEncoder_put_GeneratedThumbnailHeight(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.GeneratedThumbnailHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapEncoder_get_BitmapContainerProperties(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapContainerProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_BitmapProperties(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_BitmapTransform(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_EncoderInformation(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncoderInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_BmpEncoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::BmpEncoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_GifEncoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::GifEncoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_JpegEncoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::JpegEncoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_JpegXREncoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::JpegXREncoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_PngEncoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::PngEncoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_TiffEncoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::TiffEncoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapEncoder_get_HeifEncoderId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Graphics::Imaging::BitmapEncoder::HeifEncoderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BitmapEncoder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapEncoder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapEncoder[] = {
        { "create_async", reinterpret_cast<PyCFunction>(BitmapEncoder_CreateAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "create_for_in_place_property_encoding_async", reinterpret_cast<PyCFunction>(BitmapEncoder_CreateForInPlacePropertyEncodingAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "create_for_transcoding_async", reinterpret_cast<PyCFunction>(BitmapEncoder_CreateForTranscodingAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "flush_async", reinterpret_cast<PyCFunction>(BitmapEncoder_FlushAsync), METH_VARARGS, nullptr },
        { "get_encoder_information_enumerator", reinterpret_cast<PyCFunction>(BitmapEncoder_GetEncoderInformationEnumerator), METH_VARARGS | METH_STATIC, nullptr },
        { "go_to_next_frame_async", reinterpret_cast<PyCFunction>(BitmapEncoder_GoToNextFrameAsync), METH_VARARGS, nullptr },
        { "set_pixel_data", reinterpret_cast<PyCFunction>(BitmapEncoder_SetPixelData), METH_VARARGS, nullptr },
        { "set_software_bitmap", reinterpret_cast<PyCFunction>(BitmapEncoder_SetSoftwareBitmap), METH_VARARGS, nullptr },
        { "get_bmp_encoder_id", reinterpret_cast<PyCFunction>(BitmapEncoder_get_BmpEncoderId), METH_NOARGS | METH_STATIC, nullptr },
        { "get_gif_encoder_id", reinterpret_cast<PyCFunction>(BitmapEncoder_get_GifEncoderId), METH_NOARGS | METH_STATIC, nullptr },
        { "get_jpeg_encoder_id", reinterpret_cast<PyCFunction>(BitmapEncoder_get_JpegEncoderId), METH_NOARGS | METH_STATIC, nullptr },
        { "get_jpeg_x_r_encoder_id", reinterpret_cast<PyCFunction>(BitmapEncoder_get_JpegXREncoderId), METH_NOARGS | METH_STATIC, nullptr },
        { "get_png_encoder_id", reinterpret_cast<PyCFunction>(BitmapEncoder_get_PngEncoderId), METH_NOARGS | METH_STATIC, nullptr },
        { "get_tiff_encoder_id", reinterpret_cast<PyCFunction>(BitmapEncoder_get_TiffEncoderId), METH_NOARGS | METH_STATIC, nullptr },
        { "get_heif_encoder_id", reinterpret_cast<PyCFunction>(BitmapEncoder_get_HeifEncoderId), METH_NOARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapEncoder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapEncoder[] = {
        { "is_thumbnail_generated", reinterpret_cast<getter>(BitmapEncoder_get_IsThumbnailGenerated), reinterpret_cast<setter>(BitmapEncoder_put_IsThumbnailGenerated), nullptr, nullptr },
        { "generated_thumbnail_width", reinterpret_cast<getter>(BitmapEncoder_get_GeneratedThumbnailWidth), reinterpret_cast<setter>(BitmapEncoder_put_GeneratedThumbnailWidth), nullptr, nullptr },
        { "generated_thumbnail_height", reinterpret_cast<getter>(BitmapEncoder_get_GeneratedThumbnailHeight), reinterpret_cast<setter>(BitmapEncoder_put_GeneratedThumbnailHeight), nullptr, nullptr },
        { "bitmap_container_properties", reinterpret_cast<getter>(BitmapEncoder_get_BitmapContainerProperties), nullptr, nullptr, nullptr },
        { "bitmap_properties", reinterpret_cast<getter>(BitmapEncoder_get_BitmapProperties), nullptr, nullptr, nullptr },
        { "bitmap_transform", reinterpret_cast<getter>(BitmapEncoder_get_BitmapTransform), nullptr, nullptr, nullptr },
        { "encoder_information", reinterpret_cast<getter>(BitmapEncoder_get_EncoderInformation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BitmapEncoder[] = 
    {
        { Py_tp_new, _new_BitmapEncoder },
        { Py_tp_dealloc, _dealloc_BitmapEncoder },
        { Py_tp_methods, _methods_BitmapEncoder },
        { Py_tp_getset, _getset_BitmapEncoder },
        { },
    };

    static PyType_Spec type_spec_BitmapEncoder =
    {
        "_winsdk_Windows_Graphics_Imaging.BitmapEncoder",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapEncoder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapEncoder
    };

    // ----- BitmapFrame class --------------------
    constexpr const char* const type_name_BitmapFrame = "BitmapFrame";

    static PyObject* _new_BitmapFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BitmapFrame);
        return nullptr;
    }

    static void _dealloc_BitmapFrame(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapFrame_GetPixelDataAsync(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPixelDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

                return py::convert(self->obj.GetPixelDataAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_GetSoftwareBitmapAsync(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSoftwareBitmapAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);

                return py::convert(self->obj.GetSoftwareBitmapAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

                return py::convert(self->obj.GetSoftwareBitmapAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_GetThumbnailAsync(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetThumbnailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_BitmapAlphaMode(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_BitmapPixelFormat(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_BitmapProperties(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_DpiX(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_DpiY(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_OrientedPixelHeight(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OrientedPixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_OrientedPixelWidth(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OrientedPixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_PixelHeight(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapFrame_get_PixelWidth(py::wrapper::Windows::Graphics::Imaging::BitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BitmapFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapFrame[] = {
        { "get_pixel_data_async", reinterpret_cast<PyCFunction>(BitmapFrame_GetPixelDataAsync), METH_VARARGS, nullptr },
        { "get_software_bitmap_async", reinterpret_cast<PyCFunction>(BitmapFrame_GetSoftwareBitmapAsync), METH_VARARGS, nullptr },
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(BitmapFrame_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapFrame[] = {
        { "bitmap_alpha_mode", reinterpret_cast<getter>(BitmapFrame_get_BitmapAlphaMode), nullptr, nullptr, nullptr },
        { "bitmap_pixel_format", reinterpret_cast<getter>(BitmapFrame_get_BitmapPixelFormat), nullptr, nullptr, nullptr },
        { "bitmap_properties", reinterpret_cast<getter>(BitmapFrame_get_BitmapProperties), nullptr, nullptr, nullptr },
        { "dpi_x", reinterpret_cast<getter>(BitmapFrame_get_DpiX), nullptr, nullptr, nullptr },
        { "dpi_y", reinterpret_cast<getter>(BitmapFrame_get_DpiY), nullptr, nullptr, nullptr },
        { "oriented_pixel_height", reinterpret_cast<getter>(BitmapFrame_get_OrientedPixelHeight), nullptr, nullptr, nullptr },
        { "oriented_pixel_width", reinterpret_cast<getter>(BitmapFrame_get_OrientedPixelWidth), nullptr, nullptr, nullptr },
        { "pixel_height", reinterpret_cast<getter>(BitmapFrame_get_PixelHeight), nullptr, nullptr, nullptr },
        { "pixel_width", reinterpret_cast<getter>(BitmapFrame_get_PixelWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BitmapFrame[] = 
    {
        { Py_tp_new, _new_BitmapFrame },
        { Py_tp_dealloc, _dealloc_BitmapFrame },
        { Py_tp_methods, _methods_BitmapFrame },
        { Py_tp_getset, _getset_BitmapFrame },
        { },
    };

    static PyType_Spec type_spec_BitmapFrame =
    {
        "_winsdk_Windows_Graphics_Imaging.BitmapFrame",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapFrame
    };

    // ----- BitmapProperties class --------------------
    constexpr const char* const type_name_BitmapProperties = "BitmapProperties";

    static PyObject* _new_BitmapProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BitmapProperties);
        return nullptr;
    }

    static void _dealloc_BitmapProperties(py::wrapper::Windows::Graphics::Imaging::BitmapProperties* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapProperties_GetPropertiesAsync(py::wrapper::Windows::Graphics::Imaging::BitmapProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetPropertiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapProperties_SetPropertiesAsync(py::wrapper::Windows::Graphics::Imaging::BitmapProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::hstring, winrt::Windows::Graphics::Imaging::BitmapTypedValue>>>(args, 0);

                return py::convert(self->obj.SetPropertiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_BitmapProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapProperties[] = {
        { "get_properties_async", reinterpret_cast<PyCFunction>(BitmapProperties_GetPropertiesAsync), METH_VARARGS, nullptr },
        { "set_properties_async", reinterpret_cast<PyCFunction>(BitmapProperties_SetPropertiesAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_BitmapProperties[] = 
    {
        { Py_tp_new, _new_BitmapProperties },
        { Py_tp_dealloc, _dealloc_BitmapProperties },
        { Py_tp_methods, _methods_BitmapProperties },
        { Py_tp_getset, _getset_BitmapProperties },
        { },
    };

    static PyType_Spec type_spec_BitmapProperties =
    {
        "_winsdk_Windows_Graphics_Imaging.BitmapProperties",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapProperties
    };

    // ----- BitmapPropertiesView class --------------------
    constexpr const char* const type_name_BitmapPropertiesView = "BitmapPropertiesView";

    static PyObject* _new_BitmapPropertiesView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BitmapPropertiesView);
        return nullptr;
    }

    static void _dealloc_BitmapPropertiesView(py::wrapper::Windows::Graphics::Imaging::BitmapPropertiesView* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapPropertiesView_GetPropertiesAsync(py::wrapper::Windows::Graphics::Imaging::BitmapPropertiesView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetPropertiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_BitmapPropertiesView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapPropertiesView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapPropertiesView[] = {
        { "get_properties_async", reinterpret_cast<PyCFunction>(BitmapPropertiesView_GetPropertiesAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapPropertiesView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapPropertiesView[] = {
        { }
    };

    static PyType_Slot _type_slots_BitmapPropertiesView[] = 
    {
        { Py_tp_new, _new_BitmapPropertiesView },
        { Py_tp_dealloc, _dealloc_BitmapPropertiesView },
        { Py_tp_methods, _methods_BitmapPropertiesView },
        { Py_tp_getset, _getset_BitmapPropertiesView },
        { },
    };

    static PyType_Spec type_spec_BitmapPropertiesView =
    {
        "_winsdk_Windows_Graphics_Imaging.BitmapPropertiesView",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapPropertiesView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapPropertiesView
    };

    // ----- BitmapPropertySet class --------------------
    constexpr const char* const type_name_BitmapPropertySet = "BitmapPropertySet";

    static PyObject* _new_BitmapPropertySet(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Imaging::BitmapPropertySet instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BitmapPropertySet(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapPropertySet_Clear(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapPropertySet_First(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapPropertySet_GetView(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapPropertySet_HasKey(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapPropertySet_Insert(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTypedValue>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapPropertySet_Lookup(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapPropertySet_Remove(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BitmapPropertySet_get_Size(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BitmapPropertySet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapPropertySet>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_BitmapPropertySet(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert(self->obj.First())};
            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_BitmapPropertySet(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_BitmapPropertySet(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_BitmapPropertySet(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* key) noexcept
    {
        try
        {
            auto value = self->obj.TryLookup(py::convert_to<winrt::hstring>(key));

            if (!value) {
                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_BitmapPropertySet(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);

            if (value == nullptr) {
                if (!self->obj.TryRemove(_key)) {
                    PyErr_SetObject(PyExc_KeyError, key);
                    return -1;
                }

                return 0;
            }

            self->obj.Insert(_key, py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTypedValue>(value));

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_BitmapPropertySet[] = {
        { "clear", reinterpret_cast<PyCFunction>(BitmapPropertySet_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(BitmapPropertySet_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(BitmapPropertySet_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(BitmapPropertySet_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(BitmapPropertySet_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(BitmapPropertySet_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(BitmapPropertySet_Remove), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapPropertySet), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapPropertySet[] = {
        { "size", reinterpret_cast<getter>(BitmapPropertySet_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BitmapPropertySet[] = 
    {
        { Py_tp_new, _new_BitmapPropertySet },
        { Py_tp_dealloc, _dealloc_BitmapPropertySet },
        { Py_tp_methods, _methods_BitmapPropertySet },
        { Py_tp_getset, _getset_BitmapPropertySet },
        { Py_tp_iter, _iterator_BitmapPropertySet },
        { Py_sq_contains, _map_contains_BitmapPropertySet },
        { Py_mp_length, _map_length_BitmapPropertySet },
        { Py_mp_subscript, _map_subscript_BitmapPropertySet },
        { Py_mp_ass_subscript, _map_assign_BitmapPropertySet },
        { },
    };

    static PyType_Spec type_spec_BitmapPropertySet =
    {
        "_winsdk_Windows_Graphics_Imaging.BitmapPropertySet",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapPropertySet),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapPropertySet
    };

    // ----- BitmapTransform class --------------------
    constexpr const char* const type_name_BitmapTransform = "BitmapTransform";

    static PyObject* _new_BitmapTransform(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Graphics::Imaging::BitmapTransform instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BitmapTransform(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapTransform_get_ScaledWidth(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScaledWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapTransform_put_ScaledWidth(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ScaledWidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapTransform_get_ScaledHeight(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScaledHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapTransform_put_ScaledHeight(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ScaledHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapTransform_get_Rotation(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Rotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapTransform_put_Rotation(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapRotation>(arg);

            self->obj.Rotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapTransform_get_InterpolationMode(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InterpolationMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapTransform_put_InterpolationMode(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapInterpolationMode>(arg);

            self->obj.InterpolationMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapTransform_get_Flip(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Flip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapTransform_put_Flip(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapFlip>(arg);

            self->obj.Flip(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapTransform_get_Bounds(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapTransform_put_Bounds(py::wrapper::Windows::Graphics::Imaging::BitmapTransform* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapBounds>(arg);

            self->obj.Bounds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_BitmapTransform(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapTransform>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapTransform[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapTransform), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapTransform[] = {
        { "scaled_width", reinterpret_cast<getter>(BitmapTransform_get_ScaledWidth), reinterpret_cast<setter>(BitmapTransform_put_ScaledWidth), nullptr, nullptr },
        { "scaled_height", reinterpret_cast<getter>(BitmapTransform_get_ScaledHeight), reinterpret_cast<setter>(BitmapTransform_put_ScaledHeight), nullptr, nullptr },
        { "rotation", reinterpret_cast<getter>(BitmapTransform_get_Rotation), reinterpret_cast<setter>(BitmapTransform_put_Rotation), nullptr, nullptr },
        { "interpolation_mode", reinterpret_cast<getter>(BitmapTransform_get_InterpolationMode), reinterpret_cast<setter>(BitmapTransform_put_InterpolationMode), nullptr, nullptr },
        { "flip", reinterpret_cast<getter>(BitmapTransform_get_Flip), reinterpret_cast<setter>(BitmapTransform_put_Flip), nullptr, nullptr },
        { "bounds", reinterpret_cast<getter>(BitmapTransform_get_Bounds), reinterpret_cast<setter>(BitmapTransform_put_Bounds), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BitmapTransform[] = 
    {
        { Py_tp_new, _new_BitmapTransform },
        { Py_tp_dealloc, _dealloc_BitmapTransform },
        { Py_tp_methods, _methods_BitmapTransform },
        { Py_tp_getset, _getset_BitmapTransform },
        { },
    };

    static PyType_Spec type_spec_BitmapTransform =
    {
        "_winsdk_Windows_Graphics_Imaging.BitmapTransform",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapTransform),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapTransform
    };

    // ----- BitmapTypedValue class --------------------
    constexpr const char* const type_name_BitmapTypedValue = "BitmapTypedValue";

    static PyObject* _new_BitmapTypedValue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::PropertyType>(args, 1);

                winrt::Windows::Graphics::Imaging::BitmapTypedValue instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BitmapTypedValue(py::wrapper::Windows::Graphics::Imaging::BitmapTypedValue* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BitmapTypedValue_get_Type(py::wrapper::Windows::Graphics::Imaging::BitmapTypedValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BitmapTypedValue_get_Value(py::wrapper::Windows::Graphics::Imaging::BitmapTypedValue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BitmapTypedValue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::BitmapTypedValue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BitmapTypedValue[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_BitmapTypedValue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BitmapTypedValue[] = {
        { "type", reinterpret_cast<getter>(BitmapTypedValue_get_Type), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(BitmapTypedValue_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BitmapTypedValue[] = 
    {
        { Py_tp_new, _new_BitmapTypedValue },
        { Py_tp_dealloc, _dealloc_BitmapTypedValue },
        { Py_tp_methods, _methods_BitmapTypedValue },
        { Py_tp_getset, _getset_BitmapTypedValue },
        { },
    };

    static PyType_Spec type_spec_BitmapTypedValue =
    {
        "_winsdk_Windows_Graphics_Imaging.BitmapTypedValue",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapTypedValue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapTypedValue
    };

    // ----- ImageStream class --------------------
    constexpr const char* const type_name_ImageStream = "ImageStream";

    static PyObject* _new_ImageStream(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ImageStream);
        return nullptr;
    }

    static void _dealloc_ImageStream(py::wrapper::Windows::Graphics::Imaging::ImageStream* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageStream_CloneStream(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CloneStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_Close(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_FlushAsync(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_GetInputStreamAt(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetInputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_GetOutputStreamAt(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetOutputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_ReadAsync(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_Seek(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_WriteAsync(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageStream_get_ContentType(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageStream_get_Size(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageStream_put_Size(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageStream_get_CanRead(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageStream_get_CanWrite(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageStream_get_Position(py::wrapper::Windows::Graphics::Imaging::ImageStream* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ImageStream(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::ImageStream>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ImageStream(py::wrapper::Windows::Graphics::Imaging::ImageStream* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ImageStream(py::wrapper::Windows::Graphics::Imaging::ImageStream* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageStream[] = {
        { "clone_stream", reinterpret_cast<PyCFunction>(ImageStream_CloneStream), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(ImageStream_Close), METH_VARARGS, nullptr },
        { "flush_async", reinterpret_cast<PyCFunction>(ImageStream_FlushAsync), METH_VARARGS, nullptr },
        { "get_input_stream_at", reinterpret_cast<PyCFunction>(ImageStream_GetInputStreamAt), METH_VARARGS, nullptr },
        { "get_output_stream_at", reinterpret_cast<PyCFunction>(ImageStream_GetOutputStreamAt), METH_VARARGS, nullptr },
        { "read_async", reinterpret_cast<PyCFunction>(ImageStream_ReadAsync), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(ImageStream_Seek), METH_VARARGS, nullptr },
        { "write_async", reinterpret_cast<PyCFunction>(ImageStream_WriteAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageStream), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ImageStream), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ImageStream), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageStream[] = {
        { "content_type", reinterpret_cast<getter>(ImageStream_get_ContentType), nullptr, nullptr, nullptr },
        { "size", reinterpret_cast<getter>(ImageStream_get_Size), reinterpret_cast<setter>(ImageStream_put_Size), nullptr, nullptr },
        { "can_read", reinterpret_cast<getter>(ImageStream_get_CanRead), nullptr, nullptr, nullptr },
        { "can_write", reinterpret_cast<getter>(ImageStream_get_CanWrite), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ImageStream_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageStream[] = 
    {
        { Py_tp_new, _new_ImageStream },
        { Py_tp_dealloc, _dealloc_ImageStream },
        { Py_tp_methods, _methods_ImageStream },
        { Py_tp_getset, _getset_ImageStream },
        { },
    };

    static PyType_Spec type_spec_ImageStream =
    {
        "_winsdk_Windows_Graphics_Imaging.ImageStream",
        sizeof(py::wrapper::Windows::Graphics::Imaging::ImageStream),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageStream
    };

    // ----- PixelDataProvider class --------------------
    constexpr const char* const type_name_PixelDataProvider = "PixelDataProvider";

    static PyObject* _new_PixelDataProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PixelDataProvider);
        return nullptr;
    }

    static void _dealloc_PixelDataProvider(py::wrapper::Windows::Graphics::Imaging::PixelDataProvider* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PixelDataProvider_DetachPixelData(py::wrapper::Windows::Graphics::Imaging::PixelDataProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DetachPixelData());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_PixelDataProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::PixelDataProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PixelDataProvider[] = {
        { "detach_pixel_data", reinterpret_cast<PyCFunction>(PixelDataProvider_DetachPixelData), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PixelDataProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PixelDataProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_PixelDataProvider[] = 
    {
        { Py_tp_new, _new_PixelDataProvider },
        { Py_tp_dealloc, _dealloc_PixelDataProvider },
        { Py_tp_methods, _methods_PixelDataProvider },
        { Py_tp_getset, _getset_PixelDataProvider },
        { },
    };

    static PyType_Spec type_spec_PixelDataProvider =
    {
        "_winsdk_Windows_Graphics_Imaging.PixelDataProvider",
        sizeof(py::wrapper::Windows::Graphics::Imaging::PixelDataProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PixelDataProvider
    };

    // ----- SoftwareBitmap class --------------------
    constexpr const char* const type_name_SoftwareBitmap = "SoftwareBitmap";

    static PyObject* _new_SoftwareBitmap(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                winrt::Windows::Graphics::Imaging::SoftwareBitmap instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 3);

                winrt::Windows::Graphics::Imaging::SoftwareBitmap instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SoftwareBitmap(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SoftwareBitmap_Close(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_Convert(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 1);

                return py::convert(winrt::Windows::Graphics::Imaging::SoftwareBitmap::Convert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 2);

                return py::convert(winrt::Windows::Graphics::Imaging::SoftwareBitmap::Convert(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_Copy(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);

                return py::convert(winrt::Windows::Graphics::Imaging::SoftwareBitmap::Copy(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_CopyFromBuffer(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.CopyFromBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_CopyTo(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);

                self->obj.CopyTo(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_CopyToBuffer(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.CopyToBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_CreateCopyFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                return py::convert(winrt::Windows::Graphics::Imaging::SoftwareBitmap::CreateCopyFromBuffer(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 4);

                return py::convert(winrt::Windows::Graphics::Imaging::SoftwareBitmap::CreateCopyFromBuffer(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_CreateCopyFromSurfaceAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);

                return py::convert(winrt::Windows::Graphics::Imaging::SoftwareBitmap::CreateCopyFromSurfaceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);

                return py::convert(winrt::Windows::Graphics::Imaging::SoftwareBitmap::CreateCopyFromSurfaceAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_GetReadOnlyView(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetReadOnlyView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_LockBuffer(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapBufferAccessMode>(args, 0);

                return py::convert(self->obj.LockBuffer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_get_DpiY(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SoftwareBitmap_put_DpiY(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DpiY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SoftwareBitmap_get_DpiX(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SoftwareBitmap_put_DpiX(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DpiX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SoftwareBitmap_get_BitmapAlphaMode(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_get_BitmapPixelFormat(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_get_IsReadOnly(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_get_PixelHeight(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SoftwareBitmap_get_PixelWidth(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SoftwareBitmap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::SoftwareBitmap>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_SoftwareBitmap(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_SoftwareBitmap(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SoftwareBitmap[] = {
        { "close", reinterpret_cast<PyCFunction>(SoftwareBitmap_Close), METH_VARARGS, nullptr },
        { "convert", reinterpret_cast<PyCFunction>(SoftwareBitmap_Convert), METH_VARARGS | METH_STATIC, nullptr },
        { "copy", reinterpret_cast<PyCFunction>(SoftwareBitmap_Copy), METH_VARARGS | METH_STATIC, nullptr },
        { "copy_from_buffer", reinterpret_cast<PyCFunction>(SoftwareBitmap_CopyFromBuffer), METH_VARARGS, nullptr },
        { "copy_to", reinterpret_cast<PyCFunction>(SoftwareBitmap_CopyTo), METH_VARARGS, nullptr },
        { "copy_to_buffer", reinterpret_cast<PyCFunction>(SoftwareBitmap_CopyToBuffer), METH_VARARGS, nullptr },
        { "create_copy_from_buffer", reinterpret_cast<PyCFunction>(SoftwareBitmap_CreateCopyFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_copy_from_surface_async", reinterpret_cast<PyCFunction>(SoftwareBitmap_CreateCopyFromSurfaceAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_read_only_view", reinterpret_cast<PyCFunction>(SoftwareBitmap_GetReadOnlyView), METH_VARARGS, nullptr },
        { "lock_buffer", reinterpret_cast<PyCFunction>(SoftwareBitmap_LockBuffer), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SoftwareBitmap), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_SoftwareBitmap), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_SoftwareBitmap), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_SoftwareBitmap[] = {
        { "dpi_y", reinterpret_cast<getter>(SoftwareBitmap_get_DpiY), reinterpret_cast<setter>(SoftwareBitmap_put_DpiY), nullptr, nullptr },
        { "dpi_x", reinterpret_cast<getter>(SoftwareBitmap_get_DpiX), reinterpret_cast<setter>(SoftwareBitmap_put_DpiX), nullptr, nullptr },
        { "bitmap_alpha_mode", reinterpret_cast<getter>(SoftwareBitmap_get_BitmapAlphaMode), nullptr, nullptr, nullptr },
        { "bitmap_pixel_format", reinterpret_cast<getter>(SoftwareBitmap_get_BitmapPixelFormat), nullptr, nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(SoftwareBitmap_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "pixel_height", reinterpret_cast<getter>(SoftwareBitmap_get_PixelHeight), nullptr, nullptr, nullptr },
        { "pixel_width", reinterpret_cast<getter>(SoftwareBitmap_get_PixelWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SoftwareBitmap[] = 
    {
        { Py_tp_new, _new_SoftwareBitmap },
        { Py_tp_dealloc, _dealloc_SoftwareBitmap },
        { Py_tp_methods, _methods_SoftwareBitmap },
        { Py_tp_getset, _getset_SoftwareBitmap },
        { },
    };

    static PyType_Spec type_spec_SoftwareBitmap =
    {
        "_winsdk_Windows_Graphics_Imaging.SoftwareBitmap",
        sizeof(py::wrapper::Windows::Graphics::Imaging::SoftwareBitmap),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SoftwareBitmap
    };

    // ----- IBitmapFrame interface --------------------
    constexpr const char* const type_name_IBitmapFrame = "IBitmapFrame";

    static PyObject* _new_IBitmapFrame(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IBitmapFrame);
        return nullptr;
    }

    static void _dealloc_IBitmapFrame(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBitmapFrame_GetPixelDataAsync(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPixelDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

                return py::convert(self->obj.GetPixelDataAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_GetThumbnailAsync(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetThumbnailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_BitmapAlphaMode(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_BitmapPixelFormat(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_BitmapProperties(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_DpiX(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_DpiY(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_OrientedPixelHeight(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OrientedPixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_OrientedPixelWidth(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OrientedPixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_PixelHeight(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrame_get_PixelWidth(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IBitmapFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::IBitmapFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBitmapFrame[] = {
        { "get_pixel_data_async", reinterpret_cast<PyCFunction>(IBitmapFrame_GetPixelDataAsync), METH_VARARGS, nullptr },
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(IBitmapFrame_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBitmapFrame), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBitmapFrame[] = {
        { "bitmap_alpha_mode", reinterpret_cast<getter>(IBitmapFrame_get_BitmapAlphaMode), nullptr, nullptr, nullptr },
        { "bitmap_pixel_format", reinterpret_cast<getter>(IBitmapFrame_get_BitmapPixelFormat), nullptr, nullptr, nullptr },
        { "bitmap_properties", reinterpret_cast<getter>(IBitmapFrame_get_BitmapProperties), nullptr, nullptr, nullptr },
        { "dpi_x", reinterpret_cast<getter>(IBitmapFrame_get_DpiX), nullptr, nullptr, nullptr },
        { "dpi_y", reinterpret_cast<getter>(IBitmapFrame_get_DpiY), nullptr, nullptr, nullptr },
        { "oriented_pixel_height", reinterpret_cast<getter>(IBitmapFrame_get_OrientedPixelHeight), nullptr, nullptr, nullptr },
        { "oriented_pixel_width", reinterpret_cast<getter>(IBitmapFrame_get_OrientedPixelWidth), nullptr, nullptr, nullptr },
        { "pixel_height", reinterpret_cast<getter>(IBitmapFrame_get_PixelHeight), nullptr, nullptr, nullptr },
        { "pixel_width", reinterpret_cast<getter>(IBitmapFrame_get_PixelWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBitmapFrame[] = 
    {
        { Py_tp_new, _new_IBitmapFrame },
        { Py_tp_dealloc, _dealloc_IBitmapFrame },
        { Py_tp_methods, _methods_IBitmapFrame },
        { Py_tp_getset, _getset_IBitmapFrame },
        { },
    };

    static PyType_Spec type_spec_IBitmapFrame =
    {
        "_winsdk_Windows_Graphics_Imaging.IBitmapFrame",
        sizeof(py::wrapper::Windows::Graphics::Imaging::IBitmapFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBitmapFrame
    };

    // ----- IBitmapFrameWithSoftwareBitmap interface --------------------
    constexpr const char* const type_name_IBitmapFrameWithSoftwareBitmap = "IBitmapFrameWithSoftwareBitmap";

    static PyObject* _new_IBitmapFrameWithSoftwareBitmap(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IBitmapFrameWithSoftwareBitmap);
        return nullptr;
    }

    static void _dealloc_IBitmapFrameWithSoftwareBitmap(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_GetPixelDataAsync(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPixelDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

                return py::convert(self->obj.GetPixelDataAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_GetSoftwareBitmapAsync(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSoftwareBitmapAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);

                return py::convert(self->obj.GetSoftwareBitmapAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapTransform>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::Imaging::ExifOrientationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::Imaging::ColorManagementMode>(args, 4);

                return py::convert(self->obj.GetSoftwareBitmapAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_GetThumbnailAsync(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetThumbnailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_BitmapAlphaMode(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_BitmapPixelFormat(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_BitmapProperties(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_DpiX(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_DpiY(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DpiY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_OrientedPixelHeight(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OrientedPixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_OrientedPixelWidth(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OrientedPixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_PixelHeight(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBitmapFrameWithSoftwareBitmap_get_PixelWidth(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IBitmapFrameWithSoftwareBitmap(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBitmapFrameWithSoftwareBitmap[] = {
        { "get_pixel_data_async", reinterpret_cast<PyCFunction>(IBitmapFrameWithSoftwareBitmap_GetPixelDataAsync), METH_VARARGS, nullptr },
        { "get_software_bitmap_async", reinterpret_cast<PyCFunction>(IBitmapFrameWithSoftwareBitmap_GetSoftwareBitmapAsync), METH_VARARGS, nullptr },
        { "get_thumbnail_async", reinterpret_cast<PyCFunction>(IBitmapFrameWithSoftwareBitmap_GetThumbnailAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBitmapFrameWithSoftwareBitmap), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBitmapFrameWithSoftwareBitmap[] = {
        { "bitmap_alpha_mode", reinterpret_cast<getter>(IBitmapFrameWithSoftwareBitmap_get_BitmapAlphaMode), nullptr, nullptr, nullptr },
        { "bitmap_pixel_format", reinterpret_cast<getter>(IBitmapFrameWithSoftwareBitmap_get_BitmapPixelFormat), nullptr, nullptr, nullptr },
        { "bitmap_properties", reinterpret_cast<getter>(IBitmapFrameWithSoftwareBitmap_get_BitmapProperties), nullptr, nullptr, nullptr },
        { "dpi_x", reinterpret_cast<getter>(IBitmapFrameWithSoftwareBitmap_get_DpiX), nullptr, nullptr, nullptr },
        { "dpi_y", reinterpret_cast<getter>(IBitmapFrameWithSoftwareBitmap_get_DpiY), nullptr, nullptr, nullptr },
        { "oriented_pixel_height", reinterpret_cast<getter>(IBitmapFrameWithSoftwareBitmap_get_OrientedPixelHeight), nullptr, nullptr, nullptr },
        { "oriented_pixel_width", reinterpret_cast<getter>(IBitmapFrameWithSoftwareBitmap_get_OrientedPixelWidth), nullptr, nullptr, nullptr },
        { "pixel_height", reinterpret_cast<getter>(IBitmapFrameWithSoftwareBitmap_get_PixelHeight), nullptr, nullptr, nullptr },
        { "pixel_width", reinterpret_cast<getter>(IBitmapFrameWithSoftwareBitmap_get_PixelWidth), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBitmapFrameWithSoftwareBitmap[] = 
    {
        { Py_tp_new, _new_IBitmapFrameWithSoftwareBitmap },
        { Py_tp_dealloc, _dealloc_IBitmapFrameWithSoftwareBitmap },
        { Py_tp_methods, _methods_IBitmapFrameWithSoftwareBitmap },
        { Py_tp_getset, _getset_IBitmapFrameWithSoftwareBitmap },
        { },
    };

    static PyType_Spec type_spec_IBitmapFrameWithSoftwareBitmap =
    {
        "_winsdk_Windows_Graphics_Imaging.IBitmapFrameWithSoftwareBitmap",
        sizeof(py::wrapper::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBitmapFrameWithSoftwareBitmap
    };

    // ----- IBitmapPropertiesView interface --------------------
    constexpr const char* const type_name_IBitmapPropertiesView = "IBitmapPropertiesView";

    static PyObject* _new_IBitmapPropertiesView(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IBitmapPropertiesView);
        return nullptr;
    }

    static void _dealloc_IBitmapPropertiesView(py::wrapper::Windows::Graphics::Imaging::IBitmapPropertiesView* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBitmapPropertiesView_GetPropertiesAsync(py::wrapper::Windows::Graphics::Imaging::IBitmapPropertiesView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetPropertiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IBitmapPropertiesView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::Imaging::IBitmapPropertiesView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBitmapPropertiesView[] = {
        { "get_properties_async", reinterpret_cast<PyCFunction>(IBitmapPropertiesView_GetPropertiesAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBitmapPropertiesView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBitmapPropertiesView[] = {
        { }
    };

    static PyType_Slot _type_slots_IBitmapPropertiesView[] = 
    {
        { Py_tp_new, _new_IBitmapPropertiesView },
        { Py_tp_dealloc, _dealloc_IBitmapPropertiesView },
        { Py_tp_methods, _methods_IBitmapPropertiesView },
        { Py_tp_getset, _getset_IBitmapPropertiesView },
        { },
    };

    static PyType_Spec type_spec_IBitmapPropertiesView =
    {
        "_winsdk_Windows_Graphics_Imaging.IBitmapPropertiesView",
        sizeof(py::wrapper::Windows::Graphics::Imaging::IBitmapPropertiesView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBitmapPropertiesView
    };

    // ----- BitmapBounds struct --------------------
    constexpr const char* const type_name_BitmapBounds = "BitmapBounds";

    PyObject* _new_BitmapBounds(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Graphics::Imaging::BitmapBounds return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        uint32_t _X{};
        uint32_t _Y{};
        uint32_t _Width{};
        uint32_t _Height{};

        static const char* kwlist[] = {"x", "y", "width", "height", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IIII", const_cast<char**>(kwlist), &_X, &_Y, &_Width, &_Height))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Graphics::Imaging::BitmapBounds return_value{ _X, _Y, _Width, _Height };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_BitmapBounds(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self)
    {
    }

    static PyObject* BitmapBounds_get_X(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapBounds_set_X(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.X = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapBounds_get_Y(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapBounds_set_Y(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Y = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapBounds_get_Width(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapBounds_set_Width(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapBounds_get_Height(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapBounds_set_Height(py::wrapper::Windows::Graphics::Imaging::BitmapBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BitmapBounds[] = {
        { "x", reinterpret_cast<getter>(BitmapBounds_get_X), reinterpret_cast<setter>(BitmapBounds_set_X), nullptr, nullptr },
        { "y", reinterpret_cast<getter>(BitmapBounds_get_Y), reinterpret_cast<setter>(BitmapBounds_set_Y), nullptr, nullptr },
        { "width", reinterpret_cast<getter>(BitmapBounds_get_Width), reinterpret_cast<setter>(BitmapBounds_set_Width), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(BitmapBounds_get_Height), reinterpret_cast<setter>(BitmapBounds_set_Height), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BitmapBounds[] = 
    {
        { Py_tp_new, _new_BitmapBounds },
        { Py_tp_dealloc, _dealloc_BitmapBounds },
        { Py_tp_getset, _getset_BitmapBounds },
        { },
    };

    static PyType_Spec type_spec_BitmapBounds =
    {
        "_winsdk_Windows_Graphics_Imaging.BitmapBounds",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapBounds),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapBounds
    };

    // ----- BitmapPlaneDescription struct --------------------
    constexpr const char* const type_name_BitmapPlaneDescription = "BitmapPlaneDescription";

    PyObject* _new_BitmapPlaneDescription(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Graphics::Imaging::BitmapPlaneDescription return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        int32_t _StartIndex{};
        int32_t _Width{};
        int32_t _Height{};
        int32_t _Stride{};

        static const char* kwlist[] = {"start_index", "width", "height", "stride", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "iiii", const_cast<char**>(kwlist), &_StartIndex, &_Width, &_Height, &_Stride))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Graphics::Imaging::BitmapPlaneDescription return_value{ _StartIndex, _Width, _Height, _Stride };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_BitmapPlaneDescription(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self)
    {
    }

    static PyObject* BitmapPlaneDescription_get_StartIndex(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartIndex);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapPlaneDescription_set_StartIndex(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.StartIndex = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapPlaneDescription_get_Width(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapPlaneDescription_set_Width(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapPlaneDescription_get_Height(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapPlaneDescription_set_Height(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapPlaneDescription_get_Stride(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Stride);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapPlaneDescription_set_Stride(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Stride = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BitmapPlaneDescription[] = {
        { "start_index", reinterpret_cast<getter>(BitmapPlaneDescription_get_StartIndex), reinterpret_cast<setter>(BitmapPlaneDescription_set_StartIndex), nullptr, nullptr },
        { "width", reinterpret_cast<getter>(BitmapPlaneDescription_get_Width), reinterpret_cast<setter>(BitmapPlaneDescription_set_Width), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(BitmapPlaneDescription_get_Height), reinterpret_cast<setter>(BitmapPlaneDescription_set_Height), nullptr, nullptr },
        { "stride", reinterpret_cast<getter>(BitmapPlaneDescription_get_Stride), reinterpret_cast<setter>(BitmapPlaneDescription_set_Stride), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BitmapPlaneDescription[] = 
    {
        { Py_tp_new, _new_BitmapPlaneDescription },
        { Py_tp_dealloc, _dealloc_BitmapPlaneDescription },
        { Py_tp_getset, _getset_BitmapPlaneDescription },
        { },
    };

    static PyType_Spec type_spec_BitmapPlaneDescription =
    {
        "_winsdk_Windows_Graphics_Imaging.BitmapPlaneDescription",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapPlaneDescription),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapPlaneDescription
    };

    // ----- BitmapSize struct --------------------
    constexpr const char* const type_name_BitmapSize = "BitmapSize";

    PyObject* _new_BitmapSize(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Graphics::Imaging::BitmapSize return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        uint32_t _Width{};
        uint32_t _Height{};

        static const char* kwlist[] = {"width", "height", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "II", const_cast<char**>(kwlist), &_Width, &_Height))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Graphics::Imaging::BitmapSize return_value{ _Width, _Height };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_BitmapSize(py::wrapper::Windows::Graphics::Imaging::BitmapSize* self)
    {
    }

    static PyObject* BitmapSize_get_Width(py::wrapper::Windows::Graphics::Imaging::BitmapSize* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapSize_set_Width(py::wrapper::Windows::Graphics::Imaging::BitmapSize* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BitmapSize_get_Height(py::wrapper::Windows::Graphics::Imaging::BitmapSize* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BitmapSize_set_Height(py::wrapper::Windows::Graphics::Imaging::BitmapSize* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BitmapSize[] = {
        { "width", reinterpret_cast<getter>(BitmapSize_get_Width), reinterpret_cast<setter>(BitmapSize_set_Width), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(BitmapSize_get_Height), reinterpret_cast<setter>(BitmapSize_set_Height), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BitmapSize[] = 
    {
        { Py_tp_new, _new_BitmapSize },
        { Py_tp_dealloc, _dealloc_BitmapSize },
        { Py_tp_getset, _getset_BitmapSize },
        { },
    };

    static PyType_Spec type_spec_BitmapSize =
    {
        "_winsdk_Windows_Graphics_Imaging.BitmapSize",
        sizeof(py::wrapper::Windows::Graphics::Imaging::BitmapSize),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BitmapSize
    };

    // ----- Windows.Graphics.Imaging Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Graphics::Imaging");

    static PyMethodDef module_methods[] = {
        {"_register_BitmapAlphaMode", register_BitmapAlphaMode, METH_O, "registers type"},
        {"_register_BitmapBufferAccessMode", register_BitmapBufferAccessMode, METH_O, "registers type"},
        {"_register_BitmapFlip", register_BitmapFlip, METH_O, "registers type"},
        {"_register_BitmapInterpolationMode", register_BitmapInterpolationMode, METH_O, "registers type"},
        {"_register_BitmapPixelFormat", register_BitmapPixelFormat, METH_O, "registers type"},
        {"_register_BitmapRotation", register_BitmapRotation, METH_O, "registers type"},
        {"_register_ColorManagementMode", register_ColorManagementMode, METH_O, "registers type"},
        {"_register_ExifOrientationMode", register_ExifOrientationMode, METH_O, "registers type"},
        {"_register_JpegSubsamplingMode", register_JpegSubsamplingMode, METH_O, "registers type"},
        {"_register_PngFilterMode", register_PngFilterMode, METH_O, "registers type"},
        {"_register_TiffCompressionMode", register_TiffCompressionMode, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_BitmapAlphaMode);
        Py_VISIT(state->type_BitmapBufferAccessMode);
        Py_VISIT(state->type_BitmapFlip);
        Py_VISIT(state->type_BitmapInterpolationMode);
        Py_VISIT(state->type_BitmapPixelFormat);
        Py_VISIT(state->type_BitmapRotation);
        Py_VISIT(state->type_ColorManagementMode);
        Py_VISIT(state->type_ExifOrientationMode);
        Py_VISIT(state->type_JpegSubsamplingMode);
        Py_VISIT(state->type_PngFilterMode);
        Py_VISIT(state->type_TiffCompressionMode);
        Py_VISIT(state->type_BitmapBuffer);
        Py_VISIT(state->type_BitmapCodecInformation);
        Py_VISIT(state->type_BitmapDecoder);
        Py_VISIT(state->type_BitmapEncoder);
        Py_VISIT(state->type_BitmapFrame);
        Py_VISIT(state->type_BitmapProperties);
        Py_VISIT(state->type_BitmapPropertiesView);
        Py_VISIT(state->type_BitmapPropertySet);
        Py_VISIT(state->type_BitmapTransform);
        Py_VISIT(state->type_BitmapTypedValue);
        Py_VISIT(state->type_ImageStream);
        Py_VISIT(state->type_PixelDataProvider);
        Py_VISIT(state->type_SoftwareBitmap);
        Py_VISIT(state->type_IBitmapFrame);
        Py_VISIT(state->type_IBitmapFrameWithSoftwareBitmap);
        Py_VISIT(state->type_IBitmapPropertiesView);
        Py_VISIT(state->type_BitmapBounds);
        Py_VISIT(state->type_BitmapPlaneDescription);
        Py_VISIT(state->type_BitmapSize);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_BitmapAlphaMode);
        Py_CLEAR(state->type_BitmapBufferAccessMode);
        Py_CLEAR(state->type_BitmapFlip);
        Py_CLEAR(state->type_BitmapInterpolationMode);
        Py_CLEAR(state->type_BitmapPixelFormat);
        Py_CLEAR(state->type_BitmapRotation);
        Py_CLEAR(state->type_ColorManagementMode);
        Py_CLEAR(state->type_ExifOrientationMode);
        Py_CLEAR(state->type_JpegSubsamplingMode);
        Py_CLEAR(state->type_PngFilterMode);
        Py_CLEAR(state->type_TiffCompressionMode);
        Py_CLEAR(state->type_BitmapBuffer);
        Py_CLEAR(state->type_BitmapCodecInformation);
        Py_CLEAR(state->type_BitmapDecoder);
        Py_CLEAR(state->type_BitmapEncoder);
        Py_CLEAR(state->type_BitmapFrame);
        Py_CLEAR(state->type_BitmapProperties);
        Py_CLEAR(state->type_BitmapPropertiesView);
        Py_CLEAR(state->type_BitmapPropertySet);
        Py_CLEAR(state->type_BitmapTransform);
        Py_CLEAR(state->type_BitmapTypedValue);
        Py_CLEAR(state->type_ImageStream);
        Py_CLEAR(state->type_PixelDataProvider);
        Py_CLEAR(state->type_SoftwareBitmap);
        Py_CLEAR(state->type_IBitmapFrame);
        Py_CLEAR(state->type_IBitmapFrameWithSoftwareBitmap);
        Py_CLEAR(state->type_IBitmapPropertiesView);
        Py_CLEAR(state->type_BitmapBounds);
        Py_CLEAR(state->type_BitmapPlaneDescription);
        Py_CLEAR(state->type_BitmapSize);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Graphics_Imaging",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Graphics::Imaging

PyMODINIT_FUNC PyInit__winsdk_Windows_Graphics_Imaging(void) noexcept
{
    using namespace py::cpp::Windows::Graphics::Imaging;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_BitmapBuffer = py::register_python_type(module.get(), type_name_BitmapBuffer, &type_spec_BitmapBuffer, bases.get());
    if (!state->type_BitmapBuffer)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BitmapBuffer);

    state->type_BitmapCodecInformation = py::register_python_type(module.get(), type_name_BitmapCodecInformation, &type_spec_BitmapCodecInformation, bases.get());
    if (!state->type_BitmapCodecInformation)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BitmapCodecInformation);

    state->type_BitmapDecoder = py::register_python_type(module.get(), type_name_BitmapDecoder, &type_spec_BitmapDecoder, bases.get());
    if (!state->type_BitmapDecoder)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BitmapDecoder);

    state->type_BitmapEncoder = py::register_python_type(module.get(), type_name_BitmapEncoder, &type_spec_BitmapEncoder, bases.get());
    if (!state->type_BitmapEncoder)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BitmapEncoder);

    state->type_BitmapFrame = py::register_python_type(module.get(), type_name_BitmapFrame, &type_spec_BitmapFrame, bases.get());
    if (!state->type_BitmapFrame)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BitmapFrame);

    state->type_BitmapProperties = py::register_python_type(module.get(), type_name_BitmapProperties, &type_spec_BitmapProperties, bases.get());
    if (!state->type_BitmapProperties)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BitmapProperties);

    state->type_BitmapPropertiesView = py::register_python_type(module.get(), type_name_BitmapPropertiesView, &type_spec_BitmapPropertiesView, bases.get());
    if (!state->type_BitmapPropertiesView)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BitmapPropertiesView);

    state->type_BitmapPropertySet = py::register_python_type(module.get(), type_name_BitmapPropertySet, &type_spec_BitmapPropertySet, mutable_mapping_bases.get());
    if (!state->type_BitmapPropertySet)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BitmapPropertySet);

    state->type_BitmapTransform = py::register_python_type(module.get(), type_name_BitmapTransform, &type_spec_BitmapTransform, bases.get());
    if (!state->type_BitmapTransform)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BitmapTransform);

    state->type_BitmapTypedValue = py::register_python_type(module.get(), type_name_BitmapTypedValue, &type_spec_BitmapTypedValue, bases.get());
    if (!state->type_BitmapTypedValue)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BitmapTypedValue);

    state->type_ImageStream = py::register_python_type(module.get(), type_name_ImageStream, &type_spec_ImageStream, bases.get());
    if (!state->type_ImageStream)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ImageStream);

    state->type_PixelDataProvider = py::register_python_type(module.get(), type_name_PixelDataProvider, &type_spec_PixelDataProvider, bases.get());
    if (!state->type_PixelDataProvider)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PixelDataProvider);

    state->type_SoftwareBitmap = py::register_python_type(module.get(), type_name_SoftwareBitmap, &type_spec_SoftwareBitmap, bases.get());
    if (!state->type_SoftwareBitmap)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SoftwareBitmap);

    state->type_IBitmapFrame = py::register_python_type(module.get(), type_name_IBitmapFrame, &type_spec_IBitmapFrame, bases.get());
    if (!state->type_IBitmapFrame)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IBitmapFrame);

    state->type_IBitmapFrameWithSoftwareBitmap = py::register_python_type(module.get(), type_name_IBitmapFrameWithSoftwareBitmap, &type_spec_IBitmapFrameWithSoftwareBitmap, bases.get());
    if (!state->type_IBitmapFrameWithSoftwareBitmap)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IBitmapFrameWithSoftwareBitmap);

    state->type_IBitmapPropertiesView = py::register_python_type(module.get(), type_name_IBitmapPropertiesView, &type_spec_IBitmapPropertiesView, bases.get());
    if (!state->type_IBitmapPropertiesView)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IBitmapPropertiesView);

    state->type_BitmapBounds = py::register_python_type(module.get(), type_name_BitmapBounds, &type_spec_BitmapBounds, bases.get());
    if (!state->type_BitmapBounds)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BitmapBounds);

    state->type_BitmapPlaneDescription = py::register_python_type(module.get(), type_name_BitmapPlaneDescription, &type_spec_BitmapPlaneDescription, bases.get());
    if (!state->type_BitmapPlaneDescription)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BitmapPlaneDescription);

    state->type_BitmapSize = py::register_python_type(module.get(), type_name_BitmapSize, &type_spec_BitmapSize, bases.get());
    if (!state->type_BitmapSize)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BitmapSize);


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Graphics::Imaging::BitmapAlphaMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BitmapAlphaMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::BitmapAlphaMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Graphics::Imaging::BitmapBufferAccessMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BitmapBufferAccessMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::BitmapBufferAccessMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Graphics::Imaging::BitmapFlip>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BitmapFlip;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::BitmapFlip is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Graphics::Imaging::BitmapInterpolationMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BitmapInterpolationMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::BitmapInterpolationMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Graphics::Imaging::BitmapPixelFormat>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BitmapPixelFormat;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::BitmapPixelFormat is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Graphics::Imaging::BitmapRotation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BitmapRotation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::BitmapRotation is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Graphics::Imaging::ColorManagementMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ColorManagementMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::ColorManagementMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Graphics::Imaging::ExifOrientationMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ExifOrientationMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::ExifOrientationMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Graphics::Imaging::JpegSubsamplingMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_JpegSubsamplingMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::JpegSubsamplingMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Graphics::Imaging::PngFilterMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PngFilterMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::PngFilterMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Graphics::Imaging::TiffCompressionMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TiffCompressionMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::TiffCompressionMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapBuffer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BitmapBuffer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::BitmapBuffer is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapCodecInformation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BitmapCodecInformation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::BitmapCodecInformation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapDecoder>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BitmapDecoder;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::BitmapDecoder is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapEncoder>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BitmapEncoder;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::BitmapEncoder is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapFrame>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BitmapFrame;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::BitmapFrame is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BitmapProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::BitmapProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapPropertiesView>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BitmapPropertiesView;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::BitmapPropertiesView is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapPropertySet>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BitmapPropertySet;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::BitmapPropertySet is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapTransform>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BitmapTransform;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::BitmapTransform is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapTypedValue>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BitmapTypedValue;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::BitmapTypedValue is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::ImageStream>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ImageStream;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::ImageStream is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::PixelDataProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PixelDataProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::PixelDataProvider is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::SoftwareBitmap>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SoftwareBitmap;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::SoftwareBitmap is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::IBitmapFrame>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IBitmapFrame;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::IBitmapFrame is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IBitmapFrameWithSoftwareBitmap;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::IBitmapFrameWithSoftwareBitmap is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::IBitmapPropertiesView>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IBitmapPropertiesView;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::IBitmapPropertiesView is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapBounds>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BitmapBounds;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::BitmapBounds is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapPlaneDescription>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BitmapPlaneDescription;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::BitmapPlaneDescription is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::Imaging::BitmapSize>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Graphics::Imaging;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Graphics::Imaging");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BitmapSize;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Graphics::Imaging::BitmapSize is not registered");
        return nullptr;
    }

    return python_type;
}
