// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.6

#include "pybase.h"
#include "py.Windows.Security.Cryptography.Core.h"


namespace py::cpp::Windows::Security::Cryptography::Core
{
    struct module_state
    {
        PyObject* type_Capi1KdfTargetAlgorithm;
        PyObject* type_CryptographicPadding;
        PyObject* type_CryptographicPrivateKeyBlobType;
        PyObject* type_CryptographicPublicKeyBlobType;
        PyTypeObject* type_AsymmetricAlgorithmNames;
        PyTypeObject* type_AsymmetricKeyAlgorithmProvider;
        PyTypeObject* type_CryptographicEngine;
        PyTypeObject* type_CryptographicHash;
        PyTypeObject* type_CryptographicKey;
        PyTypeObject* type_EccCurveNames;
        PyTypeObject* type_EncryptedAndAuthenticatedData;
        PyTypeObject* type_HashAlgorithmNames;
        PyTypeObject* type_HashAlgorithmProvider;
        PyTypeObject* type_KeyDerivationAlgorithmNames;
        PyTypeObject* type_KeyDerivationAlgorithmProvider;
        PyTypeObject* type_KeyDerivationParameters;
        PyTypeObject* type_MacAlgorithmNames;
        PyTypeObject* type_MacAlgorithmProvider;
        PyTypeObject* type_PersistedKeyProvider;
        PyTypeObject* type_SymmetricAlgorithmNames;
        PyTypeObject* type_SymmetricKeyAlgorithmProvider;
    };

    static PyObject* register_Capi1KdfTargetAlgorithm(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_Capi1KdfTargetAlgorithm)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_Capi1KdfTargetAlgorithm = type;
        Py_INCREF(state->type_Capi1KdfTargetAlgorithm);


        Py_RETURN_NONE;
    }

    static PyObject* register_CryptographicPadding(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CryptographicPadding)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CryptographicPadding = type;
        Py_INCREF(state->type_CryptographicPadding);


        Py_RETURN_NONE;
    }

    static PyObject* register_CryptographicPrivateKeyBlobType(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CryptographicPrivateKeyBlobType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CryptographicPrivateKeyBlobType = type;
        Py_INCREF(state->type_CryptographicPrivateKeyBlobType);


        Py_RETURN_NONE;
    }

    static PyObject* register_CryptographicPublicKeyBlobType(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CryptographicPublicKeyBlobType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CryptographicPublicKeyBlobType = type;
        Py_INCREF(state->type_CryptographicPublicKeyBlobType);


        Py_RETURN_NONE;
    }

    // ----- AsymmetricAlgorithmNames class --------------------
    constexpr const char* const type_name_AsymmetricAlgorithmNames = "AsymmetricAlgorithmNames";

    static PyObject* _new_AsymmetricAlgorithmNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AsymmetricAlgorithmNames);
        return nullptr;
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaP521Sha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaP521Sha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_DsaSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::DsaSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_DsaSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::DsaSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaP256Sha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaP256Sha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaP384Sha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaP384Sha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPkcs1Sha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaOaepSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaOaepSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaOaepSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaOaepSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaOaepSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaOaepSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaOaepSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaOaepSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaPkcs1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaPkcs1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPkcs1Sha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPkcs1Sha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPkcs1Sha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPssSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPssSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPssSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPssSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPssSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPssSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_RsaSignPssSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::RsaSignPssSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsymmetricAlgorithmNames_get_EcdsaSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames::EcdsaSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AsymmetricAlgorithmNames[] = {
        { "get_ecdsa_p521_sha512", reinterpret_cast<PyCFunction>(AsymmetricAlgorithmNames_get_EcdsaP521Sha512), METH_NOARGS | METH_STATIC, nullptr },
        { "get_dsa_sha1", reinterpret_cast<PyCFunction>(AsymmetricAlgorithmNames_get_DsaSha1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_dsa_sha256", reinterpret_cast<PyCFunction>(AsymmetricAlgorithmNames_get_DsaSha256), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdsa_p256_sha256", reinterpret_cast<PyCFunction>(AsymmetricAlgorithmNames_get_EcdsaP256Sha256), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdsa_p384_sha384", reinterpret_cast<PyCFunction>(AsymmetricAlgorithmNames_get_EcdsaP384Sha384), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_sign_pkcs1_sha256", reinterpret_cast<PyCFunction>(AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha256), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_oaep_sha1", reinterpret_cast<PyCFunction>(AsymmetricAlgorithmNames_get_RsaOaepSha1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_oaep_sha256", reinterpret_cast<PyCFunction>(AsymmetricAlgorithmNames_get_RsaOaepSha256), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_oaep_sha384", reinterpret_cast<PyCFunction>(AsymmetricAlgorithmNames_get_RsaOaepSha384), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_oaep_sha512", reinterpret_cast<PyCFunction>(AsymmetricAlgorithmNames_get_RsaOaepSha512), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_pkcs1", reinterpret_cast<PyCFunction>(AsymmetricAlgorithmNames_get_RsaPkcs1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_sign_pkcs1_sha1", reinterpret_cast<PyCFunction>(AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_sign_pkcs1_sha384", reinterpret_cast<PyCFunction>(AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha384), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_sign_pkcs1_sha512", reinterpret_cast<PyCFunction>(AsymmetricAlgorithmNames_get_RsaSignPkcs1Sha512), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_sign_pss_sha1", reinterpret_cast<PyCFunction>(AsymmetricAlgorithmNames_get_RsaSignPssSha1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_sign_pss_sha256", reinterpret_cast<PyCFunction>(AsymmetricAlgorithmNames_get_RsaSignPssSha256), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_sign_pss_sha384", reinterpret_cast<PyCFunction>(AsymmetricAlgorithmNames_get_RsaSignPssSha384), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rsa_sign_pss_sha512", reinterpret_cast<PyCFunction>(AsymmetricAlgorithmNames_get_RsaSignPssSha512), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdsa_sha384", reinterpret_cast<PyCFunction>(AsymmetricAlgorithmNames_get_EcdsaSha384), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdsa_sha512", reinterpret_cast<PyCFunction>(AsymmetricAlgorithmNames_get_EcdsaSha512), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ecdsa_sha256", reinterpret_cast<PyCFunction>(AsymmetricAlgorithmNames_get_EcdsaSha256), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AsymmetricAlgorithmNames[] = {
        { }
    };

    static PyType_Slot _type_slots_AsymmetricAlgorithmNames[] = 
    {
        { Py_tp_new, _new_AsymmetricAlgorithmNames },
        { Py_tp_methods, _methods_AsymmetricAlgorithmNames },
        { Py_tp_getset, _getset_AsymmetricAlgorithmNames },
        { },
    };

    static PyType_Spec type_spec_AsymmetricAlgorithmNames =
    {
        "_winsdk_Windows_Security_Cryptography_Core.AsymmetricAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AsymmetricAlgorithmNames
    };

    // ----- AsymmetricKeyAlgorithmProvider class --------------------
    constexpr const char* const type_name_AsymmetricKeyAlgorithmProvider = "AsymmetricKeyAlgorithmProvider";

    static PyObject* _new_AsymmetricKeyAlgorithmProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AsymmetricKeyAlgorithmProvider);
        return nullptr;
    }

    static void _dealloc_AsymmetricKeyAlgorithmProvider(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_CreateKeyPair(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.CreateKeyPair(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_CreateKeyPairWithCurveName(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateKeyPairWithCurveName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_CreateKeyPairWithCurveParameters(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(self->obj.CreateKeyPairWithCurveParameters(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_ImportKeyPair(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.ImportKeyPair(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPrivateKeyBlobType>(args, 1);

                return py::convert(self->obj.ImportKeyPair(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_ImportPublicKey(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.ImportPublicKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPublicKeyBlobType>(args, 1);

                return py::convert(self->obj.ImportPublicKey(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_OpenAlgorithm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider::OpenAlgorithm(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsymmetricKeyAlgorithmProvider_get_AlgorithmName(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AsymmetricKeyAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AsymmetricKeyAlgorithmProvider[] = {
        { "create_key_pair", reinterpret_cast<PyCFunction>(AsymmetricKeyAlgorithmProvider_CreateKeyPair), METH_VARARGS, nullptr },
        { "create_key_pair_with_curve_name", reinterpret_cast<PyCFunction>(AsymmetricKeyAlgorithmProvider_CreateKeyPairWithCurveName), METH_VARARGS, nullptr },
        { "create_key_pair_with_curve_parameters", reinterpret_cast<PyCFunction>(AsymmetricKeyAlgorithmProvider_CreateKeyPairWithCurveParameters), METH_VARARGS, nullptr },
        { "import_key_pair", reinterpret_cast<PyCFunction>(AsymmetricKeyAlgorithmProvider_ImportKeyPair), METH_VARARGS, nullptr },
        { "import_public_key", reinterpret_cast<PyCFunction>(AsymmetricKeyAlgorithmProvider_ImportPublicKey), METH_VARARGS, nullptr },
        { "open_algorithm", reinterpret_cast<PyCFunction>(AsymmetricKeyAlgorithmProvider_OpenAlgorithm), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AsymmetricKeyAlgorithmProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AsymmetricKeyAlgorithmProvider[] = {
        { "algorithm_name", reinterpret_cast<getter>(AsymmetricKeyAlgorithmProvider_get_AlgorithmName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AsymmetricKeyAlgorithmProvider[] = 
    {
        { Py_tp_new, _new_AsymmetricKeyAlgorithmProvider },
        { Py_tp_dealloc, _dealloc_AsymmetricKeyAlgorithmProvider },
        { Py_tp_methods, _methods_AsymmetricKeyAlgorithmProvider },
        { Py_tp_getset, _getset_AsymmetricKeyAlgorithmProvider },
        { },
    };

    static PyType_Spec type_spec_AsymmetricKeyAlgorithmProvider =
    {
        "_winsdk_Windows_Security_Cryptography_Core.AsymmetricKeyAlgorithmProvider",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AsymmetricKeyAlgorithmProvider
    };

    // ----- CryptographicEngine class --------------------
    constexpr const char* const type_name_CryptographicEngine = "CryptographicEngine";

    static PyObject* _new_CryptographicEngine(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CryptographicEngine);
        return nullptr;
    }

    static PyObject* CryptographicEngine_Decrypt(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::Decrypt(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_DecryptAndAuthenticate(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 4);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::DecryptAndAuthenticate(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_DecryptAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::DecryptAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_DeriveKeyMaterial(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::DeriveKeyMaterial(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_Encrypt(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::Encrypt(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_EncryptAndAuthenticate(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 3);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::EncryptAndAuthenticate(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_Sign(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::Sign(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_SignAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::SignAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_SignHashedData(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::SignHashedData(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_SignHashedDataAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::SignHashedDataAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_VerifySignature(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::VerifySignature(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicEngine_VerifySignatureWithHashInput(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::CryptographicEngine::VerifySignatureWithHashInput(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_CryptographicEngine[] = {
        { "decrypt", reinterpret_cast<PyCFunction>(CryptographicEngine_Decrypt), METH_VARARGS | METH_STATIC, nullptr },
        { "decrypt_and_authenticate", reinterpret_cast<PyCFunction>(CryptographicEngine_DecryptAndAuthenticate), METH_VARARGS | METH_STATIC, nullptr },
        { "decrypt_async", reinterpret_cast<PyCFunction>(CryptographicEngine_DecryptAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "derive_key_material", reinterpret_cast<PyCFunction>(CryptographicEngine_DeriveKeyMaterial), METH_VARARGS | METH_STATIC, nullptr },
        { "encrypt", reinterpret_cast<PyCFunction>(CryptographicEngine_Encrypt), METH_VARARGS | METH_STATIC, nullptr },
        { "encrypt_and_authenticate", reinterpret_cast<PyCFunction>(CryptographicEngine_EncryptAndAuthenticate), METH_VARARGS | METH_STATIC, nullptr },
        { "sign", reinterpret_cast<PyCFunction>(CryptographicEngine_Sign), METH_VARARGS | METH_STATIC, nullptr },
        { "sign_async", reinterpret_cast<PyCFunction>(CryptographicEngine_SignAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "sign_hashed_data", reinterpret_cast<PyCFunction>(CryptographicEngine_SignHashedData), METH_VARARGS | METH_STATIC, nullptr },
        { "sign_hashed_data_async", reinterpret_cast<PyCFunction>(CryptographicEngine_SignHashedDataAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "verify_signature", reinterpret_cast<PyCFunction>(CryptographicEngine_VerifySignature), METH_VARARGS | METH_STATIC, nullptr },
        { "verify_signature_with_hash_input", reinterpret_cast<PyCFunction>(CryptographicEngine_VerifySignatureWithHashInput), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CryptographicEngine[] = {
        { }
    };

    static PyType_Slot _type_slots_CryptographicEngine[] = 
    {
        { Py_tp_new, _new_CryptographicEngine },
        { Py_tp_methods, _methods_CryptographicEngine },
        { Py_tp_getset, _getset_CryptographicEngine },
        { },
    };

    static PyType_Spec type_spec_CryptographicEngine =
    {
        "_winsdk_Windows_Security_Cryptography_Core.CryptographicEngine",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CryptographicEngine
    };

    // ----- CryptographicHash class --------------------
    constexpr const char* const type_name_CryptographicHash = "CryptographicHash";

    static PyObject* _new_CryptographicHash(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CryptographicHash);
        return nullptr;
    }

    static void _dealloc_CryptographicHash(py::wrapper::Windows::Security::Cryptography::Core::CryptographicHash* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CryptographicHash_Append(py::wrapper::Windows::Security::Cryptography::Core::CryptographicHash* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicHash_GetValueAndReset(py::wrapper::Windows::Security::Cryptography::Core::CryptographicHash* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetValueAndReset());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_CryptographicHash(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::CryptographicHash>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CryptographicHash[] = {
        { "append", reinterpret_cast<PyCFunction>(CryptographicHash_Append), METH_VARARGS, nullptr },
        { "get_value_and_reset", reinterpret_cast<PyCFunction>(CryptographicHash_GetValueAndReset), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CryptographicHash), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CryptographicHash[] = {
        { }
    };

    static PyType_Slot _type_slots_CryptographicHash[] = 
    {
        { Py_tp_new, _new_CryptographicHash },
        { Py_tp_dealloc, _dealloc_CryptographicHash },
        { Py_tp_methods, _methods_CryptographicHash },
        { Py_tp_getset, _getset_CryptographicHash },
        { },
    };

    static PyType_Spec type_spec_CryptographicHash =
    {
        "_winsdk_Windows_Security_Cryptography_Core.CryptographicHash",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::CryptographicHash),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CryptographicHash
    };

    // ----- CryptographicKey class --------------------
    constexpr const char* const type_name_CryptographicKey = "CryptographicKey";

    static PyObject* _new_CryptographicKey(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CryptographicKey);
        return nullptr;
    }

    static void _dealloc_CryptographicKey(py::wrapper::Windows::Security::Cryptography::Core::CryptographicKey* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CryptographicKey_Export(py::wrapper::Windows::Security::Cryptography::Core::CryptographicKey* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Export());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPrivateKeyBlobType>(args, 0);

                return py::convert(self->obj.Export(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicKey_ExportPublicKey(py::wrapper::Windows::Security::Cryptography::Core::CryptographicKey* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ExportPublicKey());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPublicKeyBlobType>(args, 0);

                return py::convert(self->obj.ExportPublicKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CryptographicKey_get_KeySize(py::wrapper::Windows::Security::Cryptography::Core::CryptographicKey* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeySize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CryptographicKey(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::CryptographicKey>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CryptographicKey[] = {
        { "export", reinterpret_cast<PyCFunction>(CryptographicKey_Export), METH_VARARGS, nullptr },
        { "export_public_key", reinterpret_cast<PyCFunction>(CryptographicKey_ExportPublicKey), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CryptographicKey), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CryptographicKey[] = {
        { "key_size", reinterpret_cast<getter>(CryptographicKey_get_KeySize), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CryptographicKey[] = 
    {
        { Py_tp_new, _new_CryptographicKey },
        { Py_tp_dealloc, _dealloc_CryptographicKey },
        { Py_tp_methods, _methods_CryptographicKey },
        { Py_tp_getset, _getset_CryptographicKey },
        { },
    };

    static PyType_Spec type_spec_CryptographicKey =
    {
        "_winsdk_Windows_Security_Cryptography_Core.CryptographicKey",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::CryptographicKey),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CryptographicKey
    };

    // ----- EccCurveNames class --------------------
    constexpr const char* const type_name_EccCurveNames = "EccCurveNames";

    static PyObject* _new_EccCurveNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EccCurveNames);
        return nullptr;
    }

    static PyObject* EccCurveNames_get_AllEccCurveNames(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::AllEccCurveNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP160r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP160r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP160t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP160t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP192r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP192r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP192t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP192t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP224r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP224r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP224t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP224t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP256r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP256r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP256t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP256t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP320r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP320r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP320t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP320t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP384r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP384r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP384t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP384t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP512r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP512r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_BrainpoolP512t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::BrainpoolP512t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_Curve25519(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::Curve25519());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_Ec192wapi(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::Ec192wapi());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NistP192(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NistP192());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NistP224(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NistP224());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NistP256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NistP256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NistP384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NistP384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NistP521(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NistP521());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NumsP256t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NumsP256t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NumsP384t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NumsP384t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_NumsP512t1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::NumsP512t1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP160k1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP160k1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP160r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP160r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP160r2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP160r2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP192k1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP192k1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP192r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP192r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP224k1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP224k1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP224r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP224r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP256k1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP256k1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP256r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP256r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP384r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP384r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_SecP521r1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::SecP521r1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_Wtls12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::Wtls12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_Wtls7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::Wtls7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_Wtls9(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::Wtls9());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P192v1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P192v1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P192v2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P192v2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P192v3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P192v3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P239v1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P239v1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P239v2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P239v2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P239v3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P239v3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EccCurveNames_get_X962P256v1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::EccCurveNames::X962P256v1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EccCurveNames[] = {
        { "get_all_ecc_curve_names", reinterpret_cast<PyCFunction>(EccCurveNames_get_AllEccCurveNames), METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p160r1", reinterpret_cast<PyCFunction>(EccCurveNames_get_BrainpoolP160r1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p160t1", reinterpret_cast<PyCFunction>(EccCurveNames_get_BrainpoolP160t1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p192r1", reinterpret_cast<PyCFunction>(EccCurveNames_get_BrainpoolP192r1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p192t1", reinterpret_cast<PyCFunction>(EccCurveNames_get_BrainpoolP192t1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p224r1", reinterpret_cast<PyCFunction>(EccCurveNames_get_BrainpoolP224r1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p224t1", reinterpret_cast<PyCFunction>(EccCurveNames_get_BrainpoolP224t1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p256r1", reinterpret_cast<PyCFunction>(EccCurveNames_get_BrainpoolP256r1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p256t1", reinterpret_cast<PyCFunction>(EccCurveNames_get_BrainpoolP256t1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p320r1", reinterpret_cast<PyCFunction>(EccCurveNames_get_BrainpoolP320r1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p320t1", reinterpret_cast<PyCFunction>(EccCurveNames_get_BrainpoolP320t1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p384r1", reinterpret_cast<PyCFunction>(EccCurveNames_get_BrainpoolP384r1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p384t1", reinterpret_cast<PyCFunction>(EccCurveNames_get_BrainpoolP384t1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p512r1", reinterpret_cast<PyCFunction>(EccCurveNames_get_BrainpoolP512r1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_brainpool_p512t1", reinterpret_cast<PyCFunction>(EccCurveNames_get_BrainpoolP512t1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_curve25519", reinterpret_cast<PyCFunction>(EccCurveNames_get_Curve25519), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ec192wapi", reinterpret_cast<PyCFunction>(EccCurveNames_get_Ec192wapi), METH_NOARGS | METH_STATIC, nullptr },
        { "get_nist_p192", reinterpret_cast<PyCFunction>(EccCurveNames_get_NistP192), METH_NOARGS | METH_STATIC, nullptr },
        { "get_nist_p224", reinterpret_cast<PyCFunction>(EccCurveNames_get_NistP224), METH_NOARGS | METH_STATIC, nullptr },
        { "get_nist_p256", reinterpret_cast<PyCFunction>(EccCurveNames_get_NistP256), METH_NOARGS | METH_STATIC, nullptr },
        { "get_nist_p384", reinterpret_cast<PyCFunction>(EccCurveNames_get_NistP384), METH_NOARGS | METH_STATIC, nullptr },
        { "get_nist_p521", reinterpret_cast<PyCFunction>(EccCurveNames_get_NistP521), METH_NOARGS | METH_STATIC, nullptr },
        { "get_nums_p256t1", reinterpret_cast<PyCFunction>(EccCurveNames_get_NumsP256t1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_nums_p384t1", reinterpret_cast<PyCFunction>(EccCurveNames_get_NumsP384t1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_nums_p512t1", reinterpret_cast<PyCFunction>(EccCurveNames_get_NumsP512t1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sec_p160k1", reinterpret_cast<PyCFunction>(EccCurveNames_get_SecP160k1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sec_p160r1", reinterpret_cast<PyCFunction>(EccCurveNames_get_SecP160r1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sec_p160r2", reinterpret_cast<PyCFunction>(EccCurveNames_get_SecP160r2), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sec_p192k1", reinterpret_cast<PyCFunction>(EccCurveNames_get_SecP192k1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sec_p192r1", reinterpret_cast<PyCFunction>(EccCurveNames_get_SecP192r1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sec_p224k1", reinterpret_cast<PyCFunction>(EccCurveNames_get_SecP224k1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sec_p224r1", reinterpret_cast<PyCFunction>(EccCurveNames_get_SecP224r1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sec_p256k1", reinterpret_cast<PyCFunction>(EccCurveNames_get_SecP256k1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sec_p256r1", reinterpret_cast<PyCFunction>(EccCurveNames_get_SecP256r1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sec_p384r1", reinterpret_cast<PyCFunction>(EccCurveNames_get_SecP384r1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sec_p521r1", reinterpret_cast<PyCFunction>(EccCurveNames_get_SecP521r1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_wtls12", reinterpret_cast<PyCFunction>(EccCurveNames_get_Wtls12), METH_NOARGS | METH_STATIC, nullptr },
        { "get_wtls7", reinterpret_cast<PyCFunction>(EccCurveNames_get_Wtls7), METH_NOARGS | METH_STATIC, nullptr },
        { "get_wtls9", reinterpret_cast<PyCFunction>(EccCurveNames_get_Wtls9), METH_NOARGS | METH_STATIC, nullptr },
        { "get_x962_p192v1", reinterpret_cast<PyCFunction>(EccCurveNames_get_X962P192v1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_x962_p192v2", reinterpret_cast<PyCFunction>(EccCurveNames_get_X962P192v2), METH_NOARGS | METH_STATIC, nullptr },
        { "get_x962_p192v3", reinterpret_cast<PyCFunction>(EccCurveNames_get_X962P192v3), METH_NOARGS | METH_STATIC, nullptr },
        { "get_x962_p239v1", reinterpret_cast<PyCFunction>(EccCurveNames_get_X962P239v1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_x962_p239v2", reinterpret_cast<PyCFunction>(EccCurveNames_get_X962P239v2), METH_NOARGS | METH_STATIC, nullptr },
        { "get_x962_p239v3", reinterpret_cast<PyCFunction>(EccCurveNames_get_X962P239v3), METH_NOARGS | METH_STATIC, nullptr },
        { "get_x962_p256v1", reinterpret_cast<PyCFunction>(EccCurveNames_get_X962P256v1), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EccCurveNames[] = {
        { }
    };

    static PyType_Slot _type_slots_EccCurveNames[] = 
    {
        { Py_tp_new, _new_EccCurveNames },
        { Py_tp_methods, _methods_EccCurveNames },
        { Py_tp_getset, _getset_EccCurveNames },
        { },
    };

    static PyType_Spec type_spec_EccCurveNames =
    {
        "_winsdk_Windows_Security_Cryptography_Core.EccCurveNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EccCurveNames
    };

    // ----- EncryptedAndAuthenticatedData class --------------------
    constexpr const char* const type_name_EncryptedAndAuthenticatedData = "EncryptedAndAuthenticatedData";

    static PyObject* _new_EncryptedAndAuthenticatedData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_EncryptedAndAuthenticatedData);
        return nullptr;
    }

    static void _dealloc_EncryptedAndAuthenticatedData(py::wrapper::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* EncryptedAndAuthenticatedData_get_AuthenticationTag(py::wrapper::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AuthenticationTag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EncryptedAndAuthenticatedData_get_EncryptedData(py::wrapper::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncryptedData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EncryptedAndAuthenticatedData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EncryptedAndAuthenticatedData[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_EncryptedAndAuthenticatedData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EncryptedAndAuthenticatedData[] = {
        { "authentication_tag", reinterpret_cast<getter>(EncryptedAndAuthenticatedData_get_AuthenticationTag), nullptr, nullptr, nullptr },
        { "encrypted_data", reinterpret_cast<getter>(EncryptedAndAuthenticatedData_get_EncryptedData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EncryptedAndAuthenticatedData[] = 
    {
        { Py_tp_new, _new_EncryptedAndAuthenticatedData },
        { Py_tp_dealloc, _dealloc_EncryptedAndAuthenticatedData },
        { Py_tp_methods, _methods_EncryptedAndAuthenticatedData },
        { Py_tp_getset, _getset_EncryptedAndAuthenticatedData },
        { },
    };

    static PyType_Spec type_spec_EncryptedAndAuthenticatedData =
    {
        "_winsdk_Windows_Security_Cryptography_Core.EncryptedAndAuthenticatedData",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EncryptedAndAuthenticatedData
    };

    // ----- HashAlgorithmNames class --------------------
    constexpr const char* const type_name_HashAlgorithmNames = "HashAlgorithmNames";

    static PyObject* _new_HashAlgorithmNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HashAlgorithmNames);
        return nullptr;
    }

    static PyObject* HashAlgorithmNames_get_Md5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames::Md5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmNames_get_Sha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames::Sha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmNames_get_Sha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames::Sha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmNames_get_Sha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames::Sha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmNames_get_Sha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames::Sha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HashAlgorithmNames[] = {
        { "get_md5", reinterpret_cast<PyCFunction>(HashAlgorithmNames_get_Md5), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sha1", reinterpret_cast<PyCFunction>(HashAlgorithmNames_get_Sha1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sha256", reinterpret_cast<PyCFunction>(HashAlgorithmNames_get_Sha256), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sha384", reinterpret_cast<PyCFunction>(HashAlgorithmNames_get_Sha384), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sha512", reinterpret_cast<PyCFunction>(HashAlgorithmNames_get_Sha512), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HashAlgorithmNames[] = {
        { }
    };

    static PyType_Slot _type_slots_HashAlgorithmNames[] = 
    {
        { Py_tp_new, _new_HashAlgorithmNames },
        { Py_tp_methods, _methods_HashAlgorithmNames },
        { Py_tp_getset, _getset_HashAlgorithmNames },
        { },
    };

    static PyType_Spec type_spec_HashAlgorithmNames =
    {
        "_winsdk_Windows_Security_Cryptography_Core.HashAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HashAlgorithmNames
    };

    // ----- HashAlgorithmProvider class --------------------
    constexpr const char* const type_name_HashAlgorithmProvider = "HashAlgorithmProvider";

    static PyObject* _new_HashAlgorithmProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HashAlgorithmProvider);
        return nullptr;
    }

    static void _dealloc_HashAlgorithmProvider(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HashAlgorithmProvider_CreateHash(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateHash());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmProvider_HashData(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.HashData(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmProvider_OpenAlgorithm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::HashAlgorithmProvider::OpenAlgorithm(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmProvider_get_AlgorithmName(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HashAlgorithmProvider_get_HashLength(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HashLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HashAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::HashAlgorithmProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HashAlgorithmProvider[] = {
        { "create_hash", reinterpret_cast<PyCFunction>(HashAlgorithmProvider_CreateHash), METH_VARARGS, nullptr },
        { "hash_data", reinterpret_cast<PyCFunction>(HashAlgorithmProvider_HashData), METH_VARARGS, nullptr },
        { "open_algorithm", reinterpret_cast<PyCFunction>(HashAlgorithmProvider_OpenAlgorithm), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HashAlgorithmProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HashAlgorithmProvider[] = {
        { "algorithm_name", reinterpret_cast<getter>(HashAlgorithmProvider_get_AlgorithmName), nullptr, nullptr, nullptr },
        { "hash_length", reinterpret_cast<getter>(HashAlgorithmProvider_get_HashLength), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HashAlgorithmProvider[] = 
    {
        { Py_tp_new, _new_HashAlgorithmProvider },
        { Py_tp_dealloc, _dealloc_HashAlgorithmProvider },
        { Py_tp_methods, _methods_HashAlgorithmProvider },
        { Py_tp_getset, _getset_HashAlgorithmProvider },
        { },
    };

    static PyType_Spec type_spec_HashAlgorithmProvider =
    {
        "_winsdk_Windows_Security_Cryptography_Core.HashAlgorithmProvider",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::HashAlgorithmProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HashAlgorithmProvider
    };

    // ----- KeyDerivationAlgorithmNames class --------------------
    constexpr const char* const type_name_KeyDerivationAlgorithmNames = "KeyDerivationAlgorithmNames";

    static PyObject* _new_KeyDerivationAlgorithmNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KeyDerivationAlgorithmNames);
        return nullptr;
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Pbkdf2Sha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Pbkdf2Sha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Pbkdf2Md5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Pbkdf2Md5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Pbkdf2Sha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Pbkdf2Sha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp800108CtrHmacSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Pbkdf2Sha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Pbkdf2Sha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Pbkdf2Sha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Pbkdf2Sha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp800108CtrHmacMd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp800108CtrHmacMd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp800108CtrHmacSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp800108CtrHmacSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp800108CtrHmacSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp80056aConcatMd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp80056aConcatMd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp80056aConcatSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp80056aConcatSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp80056aConcatSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp80056aConcatSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp80056aConcatSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp80056aConcatSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_Sp80056aConcatSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::Sp80056aConcatSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_CapiKdfSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::CapiKdfSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_CapiKdfSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::CapiKdfSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_CapiKdfSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::CapiKdfSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_CapiKdfSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::CapiKdfSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmNames_get_CapiKdfMd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames::CapiKdfMd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyDerivationAlgorithmNames[] = {
        { "get_pbkdf2_sha256", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmNames_get_Pbkdf2Sha256), METH_NOARGS | METH_STATIC, nullptr },
        { "get_pbkdf2_md5", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmNames_get_Pbkdf2Md5), METH_NOARGS | METH_STATIC, nullptr },
        { "get_pbkdf2_sha1", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmNames_get_Pbkdf2Sha1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sp800108_ctr_hmac_sha512", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha512), METH_NOARGS | METH_STATIC, nullptr },
        { "get_pbkdf2_sha384", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmNames_get_Pbkdf2Sha384), METH_NOARGS | METH_STATIC, nullptr },
        { "get_pbkdf2_sha512", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmNames_get_Pbkdf2Sha512), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sp800108_ctr_hmac_md5", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmNames_get_Sp800108CtrHmacMd5), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sp800108_ctr_hmac_sha1", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sp800108_ctr_hmac_sha256", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha256), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sp800108_ctr_hmac_sha384", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmNames_get_Sp800108CtrHmacSha384), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sp80056a_concat_md5", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmNames_get_Sp80056aConcatMd5), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sp80056a_concat_sha1", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmNames_get_Sp80056aConcatSha1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sp80056a_concat_sha256", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmNames_get_Sp80056aConcatSha256), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sp80056a_concat_sha384", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmNames_get_Sp80056aConcatSha384), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sp80056a_concat_sha512", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmNames_get_Sp80056aConcatSha512), METH_NOARGS | METH_STATIC, nullptr },
        { "get_capi_kdf_sha1", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmNames_get_CapiKdfSha1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_capi_kdf_sha256", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmNames_get_CapiKdfSha256), METH_NOARGS | METH_STATIC, nullptr },
        { "get_capi_kdf_sha384", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmNames_get_CapiKdfSha384), METH_NOARGS | METH_STATIC, nullptr },
        { "get_capi_kdf_sha512", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmNames_get_CapiKdfSha512), METH_NOARGS | METH_STATIC, nullptr },
        { "get_capi_kdf_md5", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmNames_get_CapiKdfMd5), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KeyDerivationAlgorithmNames[] = {
        { }
    };

    static PyType_Slot _type_slots_KeyDerivationAlgorithmNames[] = 
    {
        { Py_tp_new, _new_KeyDerivationAlgorithmNames },
        { Py_tp_methods, _methods_KeyDerivationAlgorithmNames },
        { Py_tp_getset, _getset_KeyDerivationAlgorithmNames },
        { },
    };

    static PyType_Spec type_spec_KeyDerivationAlgorithmNames =
    {
        "_winsdk_Windows_Security_Cryptography_Core.KeyDerivationAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyDerivationAlgorithmNames
    };

    // ----- KeyDerivationAlgorithmProvider class --------------------
    constexpr const char* const type_name_KeyDerivationAlgorithmProvider = "KeyDerivationAlgorithmProvider";

    static PyObject* _new_KeyDerivationAlgorithmProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KeyDerivationAlgorithmProvider);
        return nullptr;
    }

    static void _dealloc_KeyDerivationAlgorithmProvider(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeyDerivationAlgorithmProvider_CreateKey(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.CreateKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmProvider_OpenAlgorithm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider::OpenAlgorithm(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationAlgorithmProvider_get_AlgorithmName(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_KeyDerivationAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyDerivationAlgorithmProvider[] = {
        { "create_key", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmProvider_CreateKey), METH_VARARGS, nullptr },
        { "open_algorithm", reinterpret_cast<PyCFunction>(KeyDerivationAlgorithmProvider_OpenAlgorithm), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeyDerivationAlgorithmProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KeyDerivationAlgorithmProvider[] = {
        { "algorithm_name", reinterpret_cast<getter>(KeyDerivationAlgorithmProvider_get_AlgorithmName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_KeyDerivationAlgorithmProvider[] = 
    {
        { Py_tp_new, _new_KeyDerivationAlgorithmProvider },
        { Py_tp_dealloc, _dealloc_KeyDerivationAlgorithmProvider },
        { Py_tp_methods, _methods_KeyDerivationAlgorithmProvider },
        { Py_tp_getset, _getset_KeyDerivationAlgorithmProvider },
        { },
    };

    static PyType_Spec type_spec_KeyDerivationAlgorithmProvider =
    {
        "_winsdk_Windows_Security_Cryptography_Core.KeyDerivationAlgorithmProvider",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyDerivationAlgorithmProvider
    };

    // ----- KeyDerivationParameters class --------------------
    constexpr const char* const type_name_KeyDerivationParameters = "KeyDerivationParameters";

    static PyObject* _new_KeyDerivationParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KeyDerivationParameters);
        return nullptr;
    }

    static void _dealloc_KeyDerivationParameters(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* KeyDerivationParameters_BuildForCapi1Kdf(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::Capi1KdfTargetAlgorithm>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters::BuildForCapi1Kdf(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationParameters_BuildForPbkdf2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters::BuildForPbkdf2(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationParameters_BuildForSP800108(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters::BuildForSP800108(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationParameters_BuildForSP80056a(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 4);

                return py::convert(winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters::BuildForSP80056a(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* KeyDerivationParameters_get_KdfGenericBinary(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KdfGenericBinary());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyDerivationParameters_put_KdfGenericBinary(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.KdfGenericBinary(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* KeyDerivationParameters_get_IterationCount(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IterationCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KeyDerivationParameters_get_Capi1KdfTargetAlgorithm(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Capi1KdfTargetAlgorithm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int KeyDerivationParameters_put_Capi1KdfTargetAlgorithm(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Core::Capi1KdfTargetAlgorithm>(arg);

            self->obj.Capi1KdfTargetAlgorithm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_KeyDerivationParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KeyDerivationParameters[] = {
        { "build_for_capi1_kdf", reinterpret_cast<PyCFunction>(KeyDerivationParameters_BuildForCapi1Kdf), METH_VARARGS | METH_STATIC, nullptr },
        { "build_for_pbkdf2", reinterpret_cast<PyCFunction>(KeyDerivationParameters_BuildForPbkdf2), METH_VARARGS | METH_STATIC, nullptr },
        { "build_for_s_p800108", reinterpret_cast<PyCFunction>(KeyDerivationParameters_BuildForSP800108), METH_VARARGS | METH_STATIC, nullptr },
        { "build_for_s_p80056a", reinterpret_cast<PyCFunction>(KeyDerivationParameters_BuildForSP80056a), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_KeyDerivationParameters), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KeyDerivationParameters[] = {
        { "kdf_generic_binary", reinterpret_cast<getter>(KeyDerivationParameters_get_KdfGenericBinary), reinterpret_cast<setter>(KeyDerivationParameters_put_KdfGenericBinary), nullptr, nullptr },
        { "iteration_count", reinterpret_cast<getter>(KeyDerivationParameters_get_IterationCount), nullptr, nullptr, nullptr },
        { "capi1_kdf_target_algorithm", reinterpret_cast<getter>(KeyDerivationParameters_get_Capi1KdfTargetAlgorithm), reinterpret_cast<setter>(KeyDerivationParameters_put_Capi1KdfTargetAlgorithm), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_KeyDerivationParameters[] = 
    {
        { Py_tp_new, _new_KeyDerivationParameters },
        { Py_tp_dealloc, _dealloc_KeyDerivationParameters },
        { Py_tp_methods, _methods_KeyDerivationParameters },
        { Py_tp_getset, _getset_KeyDerivationParameters },
        { },
    };

    static PyType_Spec type_spec_KeyDerivationParameters =
    {
        "_winsdk_Windows_Security_Cryptography_Core.KeyDerivationParameters",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::KeyDerivationParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KeyDerivationParameters
    };

    // ----- MacAlgorithmNames class --------------------
    constexpr const char* const type_name_MacAlgorithmNames = "MacAlgorithmNames";

    static PyObject* _new_MacAlgorithmNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MacAlgorithmNames);
        return nullptr;
    }

    static PyObject* MacAlgorithmNames_get_AesCmac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::AesCmac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmNames_get_HmacMd5(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::HmacMd5());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmNames_get_HmacSha1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::HmacSha1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmNames_get_HmacSha256(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::HmacSha256());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmNames_get_HmacSha384(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::HmacSha384());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmNames_get_HmacSha512(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames::HmacSha512());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MacAlgorithmNames[] = {
        { "get_aes_cmac", reinterpret_cast<PyCFunction>(MacAlgorithmNames_get_AesCmac), METH_NOARGS | METH_STATIC, nullptr },
        { "get_hmac_md5", reinterpret_cast<PyCFunction>(MacAlgorithmNames_get_HmacMd5), METH_NOARGS | METH_STATIC, nullptr },
        { "get_hmac_sha1", reinterpret_cast<PyCFunction>(MacAlgorithmNames_get_HmacSha1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_hmac_sha256", reinterpret_cast<PyCFunction>(MacAlgorithmNames_get_HmacSha256), METH_NOARGS | METH_STATIC, nullptr },
        { "get_hmac_sha384", reinterpret_cast<PyCFunction>(MacAlgorithmNames_get_HmacSha384), METH_NOARGS | METH_STATIC, nullptr },
        { "get_hmac_sha512", reinterpret_cast<PyCFunction>(MacAlgorithmNames_get_HmacSha512), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MacAlgorithmNames[] = {
        { }
    };

    static PyType_Slot _type_slots_MacAlgorithmNames[] = 
    {
        { Py_tp_new, _new_MacAlgorithmNames },
        { Py_tp_methods, _methods_MacAlgorithmNames },
        { Py_tp_getset, _getset_MacAlgorithmNames },
        { },
    };

    static PyType_Spec type_spec_MacAlgorithmNames =
    {
        "_winsdk_Windows_Security_Cryptography_Core.MacAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MacAlgorithmNames
    };

    // ----- MacAlgorithmProvider class --------------------
    constexpr const char* const type_name_MacAlgorithmProvider = "MacAlgorithmProvider";

    static PyObject* _new_MacAlgorithmProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MacAlgorithmProvider);
        return nullptr;
    }

    static void _dealloc_MacAlgorithmProvider(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MacAlgorithmProvider_CreateHash(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.CreateHash(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmProvider_CreateKey(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.CreateKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmProvider_OpenAlgorithm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::MacAlgorithmProvider::OpenAlgorithm(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmProvider_get_AlgorithmName(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MacAlgorithmProvider_get_MacLength(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MacLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MacAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::MacAlgorithmProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MacAlgorithmProvider[] = {
        { "create_hash", reinterpret_cast<PyCFunction>(MacAlgorithmProvider_CreateHash), METH_VARARGS, nullptr },
        { "create_key", reinterpret_cast<PyCFunction>(MacAlgorithmProvider_CreateKey), METH_VARARGS, nullptr },
        { "open_algorithm", reinterpret_cast<PyCFunction>(MacAlgorithmProvider_OpenAlgorithm), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MacAlgorithmProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MacAlgorithmProvider[] = {
        { "algorithm_name", reinterpret_cast<getter>(MacAlgorithmProvider_get_AlgorithmName), nullptr, nullptr, nullptr },
        { "mac_length", reinterpret_cast<getter>(MacAlgorithmProvider_get_MacLength), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MacAlgorithmProvider[] = 
    {
        { Py_tp_new, _new_MacAlgorithmProvider },
        { Py_tp_dealloc, _dealloc_MacAlgorithmProvider },
        { Py_tp_methods, _methods_MacAlgorithmProvider },
        { Py_tp_getset, _getset_MacAlgorithmProvider },
        { },
    };

    static PyType_Spec type_spec_MacAlgorithmProvider =
    {
        "_winsdk_Windows_Security_Cryptography_Core.MacAlgorithmProvider",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::MacAlgorithmProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MacAlgorithmProvider
    };

    // ----- PersistedKeyProvider class --------------------
    constexpr const char* const type_name_PersistedKeyProvider = "PersistedKeyProvider";

    static PyObject* _new_PersistedKeyProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PersistedKeyProvider);
        return nullptr;
    }

    static PyObject* PersistedKeyProvider_OpenKeyPairFromCertificateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPadding>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::PersistedKeyProvider::OpenKeyPairFromCertificateAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PersistedKeyProvider_OpenPublicKeyFromCertificate(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Security::Cryptography::Core::CryptographicPadding>(args, 2);

                return py::convert(winrt::Windows::Security::Cryptography::Core::PersistedKeyProvider::OpenPublicKeyFromCertificate(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PersistedKeyProvider[] = {
        { "open_key_pair_from_certificate_async", reinterpret_cast<PyCFunction>(PersistedKeyProvider_OpenKeyPairFromCertificateAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "open_public_key_from_certificate", reinterpret_cast<PyCFunction>(PersistedKeyProvider_OpenPublicKeyFromCertificate), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PersistedKeyProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_PersistedKeyProvider[] = 
    {
        { Py_tp_new, _new_PersistedKeyProvider },
        { Py_tp_methods, _methods_PersistedKeyProvider },
        { Py_tp_getset, _getset_PersistedKeyProvider },
        { },
    };

    static PyType_Spec type_spec_PersistedKeyProvider =
    {
        "_winsdk_Windows_Security_Cryptography_Core.PersistedKeyProvider",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PersistedKeyProvider
    };

    // ----- SymmetricAlgorithmNames class --------------------
    constexpr const char* const type_name_SymmetricAlgorithmNames = "SymmetricAlgorithmNames";

    static PyObject* _new_SymmetricAlgorithmNames(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SymmetricAlgorithmNames);
        return nullptr;
    }

    static PyObject* SymmetricAlgorithmNames_get_AesCbc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesCbc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_AesCbcPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesCbcPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_AesCcm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesCcm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_AesEcb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesEcb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_AesEcbPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesEcbPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_AesGcm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::AesGcm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_DesCbc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::DesCbc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_DesCbcPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::DesCbcPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_DesEcb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::DesEcb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_DesEcbPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::DesEcbPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_Rc2Cbc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::Rc2Cbc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_Rc2CbcPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::Rc2CbcPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_Rc2Ecb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::Rc2Ecb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_Rc2EcbPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::Rc2EcbPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_Rc4(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::Rc4());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_TripleDesCbc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::TripleDesCbc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_TripleDesCbcPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::TripleDesCbcPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_TripleDesEcb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::TripleDesEcb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricAlgorithmNames_get_TripleDesEcbPkcs7(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames::TripleDesEcbPkcs7());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SymmetricAlgorithmNames[] = {
        { "get_aes_cbc", reinterpret_cast<PyCFunction>(SymmetricAlgorithmNames_get_AesCbc), METH_NOARGS | METH_STATIC, nullptr },
        { "get_aes_cbc_pkcs7", reinterpret_cast<PyCFunction>(SymmetricAlgorithmNames_get_AesCbcPkcs7), METH_NOARGS | METH_STATIC, nullptr },
        { "get_aes_ccm", reinterpret_cast<PyCFunction>(SymmetricAlgorithmNames_get_AesCcm), METH_NOARGS | METH_STATIC, nullptr },
        { "get_aes_ecb", reinterpret_cast<PyCFunction>(SymmetricAlgorithmNames_get_AesEcb), METH_NOARGS | METH_STATIC, nullptr },
        { "get_aes_ecb_pkcs7", reinterpret_cast<PyCFunction>(SymmetricAlgorithmNames_get_AesEcbPkcs7), METH_NOARGS | METH_STATIC, nullptr },
        { "get_aes_gcm", reinterpret_cast<PyCFunction>(SymmetricAlgorithmNames_get_AesGcm), METH_NOARGS | METH_STATIC, nullptr },
        { "get_des_cbc", reinterpret_cast<PyCFunction>(SymmetricAlgorithmNames_get_DesCbc), METH_NOARGS | METH_STATIC, nullptr },
        { "get_des_cbc_pkcs7", reinterpret_cast<PyCFunction>(SymmetricAlgorithmNames_get_DesCbcPkcs7), METH_NOARGS | METH_STATIC, nullptr },
        { "get_des_ecb", reinterpret_cast<PyCFunction>(SymmetricAlgorithmNames_get_DesEcb), METH_NOARGS | METH_STATIC, nullptr },
        { "get_des_ecb_pkcs7", reinterpret_cast<PyCFunction>(SymmetricAlgorithmNames_get_DesEcbPkcs7), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rc2_cbc", reinterpret_cast<PyCFunction>(SymmetricAlgorithmNames_get_Rc2Cbc), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rc2_cbc_pkcs7", reinterpret_cast<PyCFunction>(SymmetricAlgorithmNames_get_Rc2CbcPkcs7), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rc2_ecb", reinterpret_cast<PyCFunction>(SymmetricAlgorithmNames_get_Rc2Ecb), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rc2_ecb_pkcs7", reinterpret_cast<PyCFunction>(SymmetricAlgorithmNames_get_Rc2EcbPkcs7), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rc4", reinterpret_cast<PyCFunction>(SymmetricAlgorithmNames_get_Rc4), METH_NOARGS | METH_STATIC, nullptr },
        { "get_triple_des_cbc", reinterpret_cast<PyCFunction>(SymmetricAlgorithmNames_get_TripleDesCbc), METH_NOARGS | METH_STATIC, nullptr },
        { "get_triple_des_cbc_pkcs7", reinterpret_cast<PyCFunction>(SymmetricAlgorithmNames_get_TripleDesCbcPkcs7), METH_NOARGS | METH_STATIC, nullptr },
        { "get_triple_des_ecb", reinterpret_cast<PyCFunction>(SymmetricAlgorithmNames_get_TripleDesEcb), METH_NOARGS | METH_STATIC, nullptr },
        { "get_triple_des_ecb_pkcs7", reinterpret_cast<PyCFunction>(SymmetricAlgorithmNames_get_TripleDesEcbPkcs7), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SymmetricAlgorithmNames[] = {
        { }
    };

    static PyType_Slot _type_slots_SymmetricAlgorithmNames[] = 
    {
        { Py_tp_new, _new_SymmetricAlgorithmNames },
        { Py_tp_methods, _methods_SymmetricAlgorithmNames },
        { Py_tp_getset, _getset_SymmetricAlgorithmNames },
        { },
    };

    static PyType_Spec type_spec_SymmetricAlgorithmNames =
    {
        "_winsdk_Windows_Security_Cryptography_Core.SymmetricAlgorithmNames",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SymmetricAlgorithmNames
    };

    // ----- SymmetricKeyAlgorithmProvider class --------------------
    constexpr const char* const type_name_SymmetricKeyAlgorithmProvider = "SymmetricKeyAlgorithmProvider";

    static PyObject* _new_SymmetricKeyAlgorithmProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SymmetricKeyAlgorithmProvider);
        return nullptr;
    }

    static void _dealloc_SymmetricKeyAlgorithmProvider(py::wrapper::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SymmetricKeyAlgorithmProvider_CreateSymmetricKey(py::wrapper::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.CreateSymmetricKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SymmetricKeyAlgorithmProvider_OpenAlgorithm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider::OpenAlgorithm(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SymmetricKeyAlgorithmProvider_get_AlgorithmName(py::wrapper::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlgorithmName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SymmetricKeyAlgorithmProvider_get_BlockLength(py::wrapper::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BlockLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SymmetricKeyAlgorithmProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SymmetricKeyAlgorithmProvider[] = {
        { "create_symmetric_key", reinterpret_cast<PyCFunction>(SymmetricKeyAlgorithmProvider_CreateSymmetricKey), METH_VARARGS, nullptr },
        { "open_algorithm", reinterpret_cast<PyCFunction>(SymmetricKeyAlgorithmProvider_OpenAlgorithm), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SymmetricKeyAlgorithmProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SymmetricKeyAlgorithmProvider[] = {
        { "algorithm_name", reinterpret_cast<getter>(SymmetricKeyAlgorithmProvider_get_AlgorithmName), nullptr, nullptr, nullptr },
        { "block_length", reinterpret_cast<getter>(SymmetricKeyAlgorithmProvider_get_BlockLength), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SymmetricKeyAlgorithmProvider[] = 
    {
        { Py_tp_new, _new_SymmetricKeyAlgorithmProvider },
        { Py_tp_dealloc, _dealloc_SymmetricKeyAlgorithmProvider },
        { Py_tp_methods, _methods_SymmetricKeyAlgorithmProvider },
        { Py_tp_getset, _getset_SymmetricKeyAlgorithmProvider },
        { },
    };

    static PyType_Spec type_spec_SymmetricKeyAlgorithmProvider =
    {
        "_winsdk_Windows_Security_Cryptography_Core.SymmetricKeyAlgorithmProvider",
        sizeof(py::wrapper::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SymmetricKeyAlgorithmProvider
    };

    // ----- Windows.Security.Cryptography.Core Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Security::Cryptography::Core");

    static PyMethodDef module_methods[] = {
        {"_register_Capi1KdfTargetAlgorithm", register_Capi1KdfTargetAlgorithm, METH_O, "registers type"},
        {"_register_CryptographicPadding", register_CryptographicPadding, METH_O, "registers type"},
        {"_register_CryptographicPrivateKeyBlobType", register_CryptographicPrivateKeyBlobType, METH_O, "registers type"},
        {"_register_CryptographicPublicKeyBlobType", register_CryptographicPublicKeyBlobType, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_Capi1KdfTargetAlgorithm);
        Py_VISIT(state->type_CryptographicPadding);
        Py_VISIT(state->type_CryptographicPrivateKeyBlobType);
        Py_VISIT(state->type_CryptographicPublicKeyBlobType);
        Py_VISIT(state->type_AsymmetricAlgorithmNames);
        Py_VISIT(state->type_AsymmetricKeyAlgorithmProvider);
        Py_VISIT(state->type_CryptographicEngine);
        Py_VISIT(state->type_CryptographicHash);
        Py_VISIT(state->type_CryptographicKey);
        Py_VISIT(state->type_EccCurveNames);
        Py_VISIT(state->type_EncryptedAndAuthenticatedData);
        Py_VISIT(state->type_HashAlgorithmNames);
        Py_VISIT(state->type_HashAlgorithmProvider);
        Py_VISIT(state->type_KeyDerivationAlgorithmNames);
        Py_VISIT(state->type_KeyDerivationAlgorithmProvider);
        Py_VISIT(state->type_KeyDerivationParameters);
        Py_VISIT(state->type_MacAlgorithmNames);
        Py_VISIT(state->type_MacAlgorithmProvider);
        Py_VISIT(state->type_PersistedKeyProvider);
        Py_VISIT(state->type_SymmetricAlgorithmNames);
        Py_VISIT(state->type_SymmetricKeyAlgorithmProvider);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_Capi1KdfTargetAlgorithm);
        Py_CLEAR(state->type_CryptographicPadding);
        Py_CLEAR(state->type_CryptographicPrivateKeyBlobType);
        Py_CLEAR(state->type_CryptographicPublicKeyBlobType);
        Py_CLEAR(state->type_AsymmetricAlgorithmNames);
        Py_CLEAR(state->type_AsymmetricKeyAlgorithmProvider);
        Py_CLEAR(state->type_CryptographicEngine);
        Py_CLEAR(state->type_CryptographicHash);
        Py_CLEAR(state->type_CryptographicKey);
        Py_CLEAR(state->type_EccCurveNames);
        Py_CLEAR(state->type_EncryptedAndAuthenticatedData);
        Py_CLEAR(state->type_HashAlgorithmNames);
        Py_CLEAR(state->type_HashAlgorithmProvider);
        Py_CLEAR(state->type_KeyDerivationAlgorithmNames);
        Py_CLEAR(state->type_KeyDerivationAlgorithmProvider);
        Py_CLEAR(state->type_KeyDerivationParameters);
        Py_CLEAR(state->type_MacAlgorithmNames);
        Py_CLEAR(state->type_MacAlgorithmProvider);
        Py_CLEAR(state->type_PersistedKeyProvider);
        Py_CLEAR(state->type_SymmetricAlgorithmNames);
        Py_CLEAR(state->type_SymmetricKeyAlgorithmProvider);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Security_Cryptography_Core",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Security::Cryptography::Core

PyMODINIT_FUNC PyInit__winsdk_Windows_Security_Cryptography_Core(void) noexcept
{
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_AsymmetricAlgorithmNames = py::register_python_type(module.get(), type_name_AsymmetricAlgorithmNames, &type_spec_AsymmetricAlgorithmNames, nullptr);
    if (!state->type_AsymmetricAlgorithmNames)
    {
        return nullptr;
    }

    Py_INCREF(state->type_AsymmetricAlgorithmNames);

    state->type_AsymmetricKeyAlgorithmProvider = py::register_python_type(module.get(), type_name_AsymmetricKeyAlgorithmProvider, &type_spec_AsymmetricKeyAlgorithmProvider, bases.get());
    if (!state->type_AsymmetricKeyAlgorithmProvider)
    {
        return nullptr;
    }

    Py_INCREF(state->type_AsymmetricKeyAlgorithmProvider);

    state->type_CryptographicEngine = py::register_python_type(module.get(), type_name_CryptographicEngine, &type_spec_CryptographicEngine, nullptr);
    if (!state->type_CryptographicEngine)
    {
        return nullptr;
    }

    Py_INCREF(state->type_CryptographicEngine);

    state->type_CryptographicHash = py::register_python_type(module.get(), type_name_CryptographicHash, &type_spec_CryptographicHash, bases.get());
    if (!state->type_CryptographicHash)
    {
        return nullptr;
    }

    Py_INCREF(state->type_CryptographicHash);

    state->type_CryptographicKey = py::register_python_type(module.get(), type_name_CryptographicKey, &type_spec_CryptographicKey, bases.get());
    if (!state->type_CryptographicKey)
    {
        return nullptr;
    }

    Py_INCREF(state->type_CryptographicKey);

    state->type_EccCurveNames = py::register_python_type(module.get(), type_name_EccCurveNames, &type_spec_EccCurveNames, nullptr);
    if (!state->type_EccCurveNames)
    {
        return nullptr;
    }

    Py_INCREF(state->type_EccCurveNames);

    state->type_EncryptedAndAuthenticatedData = py::register_python_type(module.get(), type_name_EncryptedAndAuthenticatedData, &type_spec_EncryptedAndAuthenticatedData, bases.get());
    if (!state->type_EncryptedAndAuthenticatedData)
    {
        return nullptr;
    }

    Py_INCREF(state->type_EncryptedAndAuthenticatedData);

    state->type_HashAlgorithmNames = py::register_python_type(module.get(), type_name_HashAlgorithmNames, &type_spec_HashAlgorithmNames, nullptr);
    if (!state->type_HashAlgorithmNames)
    {
        return nullptr;
    }

    Py_INCREF(state->type_HashAlgorithmNames);

    state->type_HashAlgorithmProvider = py::register_python_type(module.get(), type_name_HashAlgorithmProvider, &type_spec_HashAlgorithmProvider, bases.get());
    if (!state->type_HashAlgorithmProvider)
    {
        return nullptr;
    }

    Py_INCREF(state->type_HashAlgorithmProvider);

    state->type_KeyDerivationAlgorithmNames = py::register_python_type(module.get(), type_name_KeyDerivationAlgorithmNames, &type_spec_KeyDerivationAlgorithmNames, nullptr);
    if (!state->type_KeyDerivationAlgorithmNames)
    {
        return nullptr;
    }

    Py_INCREF(state->type_KeyDerivationAlgorithmNames);

    state->type_KeyDerivationAlgorithmProvider = py::register_python_type(module.get(), type_name_KeyDerivationAlgorithmProvider, &type_spec_KeyDerivationAlgorithmProvider, bases.get());
    if (!state->type_KeyDerivationAlgorithmProvider)
    {
        return nullptr;
    }

    Py_INCREF(state->type_KeyDerivationAlgorithmProvider);

    state->type_KeyDerivationParameters = py::register_python_type(module.get(), type_name_KeyDerivationParameters, &type_spec_KeyDerivationParameters, bases.get());
    if (!state->type_KeyDerivationParameters)
    {
        return nullptr;
    }

    Py_INCREF(state->type_KeyDerivationParameters);

    state->type_MacAlgorithmNames = py::register_python_type(module.get(), type_name_MacAlgorithmNames, &type_spec_MacAlgorithmNames, nullptr);
    if (!state->type_MacAlgorithmNames)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MacAlgorithmNames);

    state->type_MacAlgorithmProvider = py::register_python_type(module.get(), type_name_MacAlgorithmProvider, &type_spec_MacAlgorithmProvider, bases.get());
    if (!state->type_MacAlgorithmProvider)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MacAlgorithmProvider);

    state->type_PersistedKeyProvider = py::register_python_type(module.get(), type_name_PersistedKeyProvider, &type_spec_PersistedKeyProvider, nullptr);
    if (!state->type_PersistedKeyProvider)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PersistedKeyProvider);

    state->type_SymmetricAlgorithmNames = py::register_python_type(module.get(), type_name_SymmetricAlgorithmNames, &type_spec_SymmetricAlgorithmNames, nullptr);
    if (!state->type_SymmetricAlgorithmNames)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SymmetricAlgorithmNames);

    state->type_SymmetricKeyAlgorithmProvider = py::register_python_type(module.get(), type_name_SymmetricKeyAlgorithmProvider, &type_spec_SymmetricKeyAlgorithmProvider, bases.get());
    if (!state->type_SymmetricKeyAlgorithmProvider)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SymmetricKeyAlgorithmProvider);


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Security::Cryptography::Core::Capi1KdfTargetAlgorithm>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Capi1KdfTargetAlgorithm;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::Capi1KdfTargetAlgorithm is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Cryptography::Core::CryptographicPadding>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CryptographicPadding;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::CryptographicPadding is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Cryptography::Core::CryptographicPrivateKeyBlobType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CryptographicPrivateKeyBlobType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::CryptographicPrivateKeyBlobType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Security::Cryptography::Core::CryptographicPublicKeyBlobType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CryptographicPublicKeyBlobType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::CryptographicPublicKeyBlobType is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AsymmetricAlgorithmNames;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::AsymmetricAlgorithmNames is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AsymmetricKeyAlgorithmProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::AsymmetricKeyAlgorithmProvider is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::CryptographicEngine>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CryptographicEngine;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::CryptographicEngine is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::CryptographicHash>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CryptographicHash;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::CryptographicHash is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::CryptographicKey>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CryptographicKey;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::CryptographicKey is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::EccCurveNames>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EccCurveNames;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::EccCurveNames is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_EncryptedAndAuthenticatedData;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::EncryptedAndAuthenticatedData is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HashAlgorithmNames;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::HashAlgorithmNames is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::HashAlgorithmProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HashAlgorithmProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::HashAlgorithmProvider is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KeyDerivationAlgorithmNames;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmNames is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KeyDerivationAlgorithmProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::KeyDerivationAlgorithmProvider is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KeyDerivationParameters;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::KeyDerivationParameters is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MacAlgorithmNames;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::MacAlgorithmNames is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::MacAlgorithmProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MacAlgorithmProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::MacAlgorithmProvider is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::PersistedKeyProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PersistedKeyProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::PersistedKeyProvider is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SymmetricAlgorithmNames;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::SymmetricAlgorithmNames is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Security::Cryptography::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Security::Cryptography::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SymmetricKeyAlgorithmProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Security::Cryptography::Core::SymmetricKeyAlgorithmProvider is not registered");
        return nullptr;
    }

    return python_type;
}
