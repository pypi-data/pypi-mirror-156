// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.6

#include "pybase.h"
#include "py.Windows.Devices.Bluetooth.h"


namespace py::cpp::Windows::Devices::Bluetooth
{
    struct module_state
    {
        PyObject* type_BluetoothAddressType;
        PyObject* type_BluetoothCacheMode;
        PyObject* type_BluetoothConnectionStatus;
        PyObject* type_BluetoothError;
        PyObject* type_BluetoothLEPreferredConnectionParametersRequestStatus;
        PyObject* type_BluetoothMajorClass;
        PyObject* type_BluetoothMinorClass;
        PyObject* type_BluetoothServiceCapabilities;
        PyTypeObject* type_BluetoothAdapter;
        PyTypeObject* type_BluetoothClassOfDevice;
        PyTypeObject* type_BluetoothDevice;
        PyTypeObject* type_BluetoothDeviceId;
        PyTypeObject* type_BluetoothLEAppearance;
        PyTypeObject* type_BluetoothLEAppearanceCategories;
        PyTypeObject* type_BluetoothLEAppearanceSubcategories;
        PyTypeObject* type_BluetoothLEConnectionParameters;
        PyTypeObject* type_BluetoothLEConnectionPhy;
        PyTypeObject* type_BluetoothLEConnectionPhyInfo;
        PyTypeObject* type_BluetoothLEDevice;
        PyTypeObject* type_BluetoothLEPreferredConnectionParameters;
        PyTypeObject* type_BluetoothLEPreferredConnectionParametersRequest;
        PyTypeObject* type_BluetoothSignalStrengthFilter;
        PyTypeObject* type_BluetoothUuidHelper;
    };

    static PyObject* register_BluetoothAddressType(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BluetoothAddressType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BluetoothAddressType = type;
        Py_INCREF(state->type_BluetoothAddressType);


        Py_RETURN_NONE;
    }

    static PyObject* register_BluetoothCacheMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BluetoothCacheMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BluetoothCacheMode = type;
        Py_INCREF(state->type_BluetoothCacheMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_BluetoothConnectionStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BluetoothConnectionStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BluetoothConnectionStatus = type;
        Py_INCREF(state->type_BluetoothConnectionStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_BluetoothError(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BluetoothError)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BluetoothError = type;
        Py_INCREF(state->type_BluetoothError);


        Py_RETURN_NONE;
    }

    static PyObject* register_BluetoothLEPreferredConnectionParametersRequestStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BluetoothLEPreferredConnectionParametersRequestStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BluetoothLEPreferredConnectionParametersRequestStatus = type;
        Py_INCREF(state->type_BluetoothLEPreferredConnectionParametersRequestStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_BluetoothMajorClass(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BluetoothMajorClass)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BluetoothMajorClass = type;
        Py_INCREF(state->type_BluetoothMajorClass);


        Py_RETURN_NONE;
    }

    static PyObject* register_BluetoothMinorClass(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BluetoothMinorClass)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BluetoothMinorClass = type;
        Py_INCREF(state->type_BluetoothMinorClass);


        Py_RETURN_NONE;
    }

    static PyObject* register_BluetoothServiceCapabilities(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BluetoothServiceCapabilities)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BluetoothServiceCapabilities = type;
        Py_INCREF(state->type_BluetoothServiceCapabilities);


        Py_RETURN_NONE;
    }

    // ----- BluetoothAdapter class --------------------
    constexpr const char* const type_name_BluetoothAdapter = "BluetoothAdapter";

    static PyObject* _new_BluetoothAdapter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BluetoothAdapter);
        return nullptr;
    }

    static void _dealloc_BluetoothAdapter(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothAdapter_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothAdapter::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_GetDefaultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothAdapter::GetDefaultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothAdapter::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_GetRadioAsync(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetRadioAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_BluetoothAddress(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BluetoothAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_DeviceId(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_IsAdvertisementOffloadSupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAdvertisementOffloadSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_IsCentralRoleSupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCentralRoleSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_IsClassicSupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsClassicSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_IsLowEnergySupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLowEnergySupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_IsPeripheralRoleSupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPeripheralRoleSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_AreClassicSecureConnectionsSupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AreClassicSecureConnectionsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_AreLowEnergySecureConnectionsSupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AreLowEnergySecureConnectionsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_IsExtendedAdvertisingSupported(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsExtendedAdvertisingSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothAdapter_get_MaxAdvertisementDataLength(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxAdvertisementDataLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BluetoothAdapter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothAdapter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothAdapter[] = {
        { "from_id_async", reinterpret_cast<PyCFunction>(BluetoothAdapter_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_async", reinterpret_cast<PyCFunction>(BluetoothAdapter_GetDefaultAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(BluetoothAdapter_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_radio_async", reinterpret_cast<PyCFunction>(BluetoothAdapter_GetRadioAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothAdapter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothAdapter[] = {
        { "bluetooth_address", reinterpret_cast<getter>(BluetoothAdapter_get_BluetoothAddress), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(BluetoothAdapter_get_DeviceId), nullptr, nullptr, nullptr },
        { "is_advertisement_offload_supported", reinterpret_cast<getter>(BluetoothAdapter_get_IsAdvertisementOffloadSupported), nullptr, nullptr, nullptr },
        { "is_central_role_supported", reinterpret_cast<getter>(BluetoothAdapter_get_IsCentralRoleSupported), nullptr, nullptr, nullptr },
        { "is_classic_supported", reinterpret_cast<getter>(BluetoothAdapter_get_IsClassicSupported), nullptr, nullptr, nullptr },
        { "is_low_energy_supported", reinterpret_cast<getter>(BluetoothAdapter_get_IsLowEnergySupported), nullptr, nullptr, nullptr },
        { "is_peripheral_role_supported", reinterpret_cast<getter>(BluetoothAdapter_get_IsPeripheralRoleSupported), nullptr, nullptr, nullptr },
        { "are_classic_secure_connections_supported", reinterpret_cast<getter>(BluetoothAdapter_get_AreClassicSecureConnectionsSupported), nullptr, nullptr, nullptr },
        { "are_low_energy_secure_connections_supported", reinterpret_cast<getter>(BluetoothAdapter_get_AreLowEnergySecureConnectionsSupported), nullptr, nullptr, nullptr },
        { "is_extended_advertising_supported", reinterpret_cast<getter>(BluetoothAdapter_get_IsExtendedAdvertisingSupported), nullptr, nullptr, nullptr },
        { "max_advertisement_data_length", reinterpret_cast<getter>(BluetoothAdapter_get_MaxAdvertisementDataLength), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothAdapter[] = 
    {
        { Py_tp_new, _new_BluetoothAdapter },
        { Py_tp_dealloc, _dealloc_BluetoothAdapter },
        { Py_tp_methods, _methods_BluetoothAdapter },
        { Py_tp_getset, _getset_BluetoothAdapter },
        { },
    };

    static PyType_Spec type_spec_BluetoothAdapter =
    {
        "_winsdk_Windows_Devices_Bluetooth.BluetoothAdapter",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothAdapter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothAdapter
    };

    // ----- BluetoothClassOfDevice class --------------------
    constexpr const char* const type_name_BluetoothClassOfDevice = "BluetoothClassOfDevice";

    static PyObject* _new_BluetoothClassOfDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BluetoothClassOfDevice);
        return nullptr;
    }

    static void _dealloc_BluetoothClassOfDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothClassOfDevice* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothClassOfDevice_FromParts(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothMajorClass>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothMinorClass>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothServiceCapabilities>(args, 2);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothClassOfDevice::FromParts(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothClassOfDevice_FromRawValue(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothClassOfDevice::FromRawValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothClassOfDevice_get_MajorClass(py::wrapper::Windows::Devices::Bluetooth::BluetoothClassOfDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MajorClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothClassOfDevice_get_MinorClass(py::wrapper::Windows::Devices::Bluetooth::BluetoothClassOfDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinorClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothClassOfDevice_get_RawValue(py::wrapper::Windows::Devices::Bluetooth::BluetoothClassOfDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothClassOfDevice_get_ServiceCapabilities(py::wrapper::Windows::Devices::Bluetooth::BluetoothClassOfDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BluetoothClassOfDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothClassOfDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothClassOfDevice[] = {
        { "from_parts", reinterpret_cast<PyCFunction>(BluetoothClassOfDevice_FromParts), METH_VARARGS | METH_STATIC, nullptr },
        { "from_raw_value", reinterpret_cast<PyCFunction>(BluetoothClassOfDevice_FromRawValue), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothClassOfDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothClassOfDevice[] = {
        { "major_class", reinterpret_cast<getter>(BluetoothClassOfDevice_get_MajorClass), nullptr, nullptr, nullptr },
        { "minor_class", reinterpret_cast<getter>(BluetoothClassOfDevice_get_MinorClass), nullptr, nullptr, nullptr },
        { "raw_value", reinterpret_cast<getter>(BluetoothClassOfDevice_get_RawValue), nullptr, nullptr, nullptr },
        { "service_capabilities", reinterpret_cast<getter>(BluetoothClassOfDevice_get_ServiceCapabilities), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothClassOfDevice[] = 
    {
        { Py_tp_new, _new_BluetoothClassOfDevice },
        { Py_tp_dealloc, _dealloc_BluetoothClassOfDevice },
        { Py_tp_methods, _methods_BluetoothClassOfDevice },
        { Py_tp_getset, _getset_BluetoothClassOfDevice },
        { },
    };

    static PyType_Spec type_spec_BluetoothClassOfDevice =
    {
        "_winsdk_Windows_Devices_Bluetooth.BluetoothClassOfDevice",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothClassOfDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothClassOfDevice
    };

    // ----- BluetoothDevice class --------------------
    constexpr const char* const type_name_BluetoothDevice = "BluetoothDevice";

    static PyObject* _new_BluetoothDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BluetoothDevice);
        return nullptr;
    }

    static void _dealloc_BluetoothDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothDevice_Close(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_FromBluetoothAddressAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::FromBluetoothAddressAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_FromHostNameAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::FromHostNameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetDeviceSelectorFromBluetoothAddress(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelectorFromBluetoothAddress(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetDeviceSelectorFromClassOfDevice(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothClassOfDevice>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelectorFromClassOfDevice(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetDeviceSelectorFromConnectionStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothConnectionStatus>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelectorFromConnectionStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetDeviceSelectorFromDeviceName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelectorFromDeviceName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetDeviceSelectorFromPairingState(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDevice::GetDeviceSelectorFromPairingState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetRfcommServicesAsync(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetRfcommServicesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>(args, 0);

                return py::convert(self->obj.GetRfcommServicesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_GetRfcommServicesForIdAsync(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::Rfcomm::RfcommServiceId>(args, 0);

                return py::convert(self->obj.GetRfcommServicesForIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::Rfcomm::RfcommServiceId>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>(args, 1);

                return py::convert(self->obj.GetRfcommServicesForIdAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_RequestAccessAsync(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_BluetoothAddress(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BluetoothAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_ClassOfDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ClassOfDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_ConnectionStatus(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_DeviceId(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_HostName(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HostName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_Name(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_RfcommServices(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RfcommServices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_SdpRecords(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SdpRecords());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_DeviceInformation(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_DeviceAccessInformation(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceAccessInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_BluetoothDeviceId(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BluetoothDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_get_WasSecureConnectionUsedForPairing(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WasSecureConnectionUsedForPairing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_add_ConnectionStatusChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ConnectionStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_remove_ConnectionStatusChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_add_NameChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.NameChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_remove_NameChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NameChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_add_SdpRecordsChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SdpRecordsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDevice_remove_SdpRecordsChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SdpRecordsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BluetoothDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_BluetoothDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_BluetoothDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothDevice[] = {
        { "close", reinterpret_cast<PyCFunction>(BluetoothDevice_Close), METH_VARARGS, nullptr },
        { "from_bluetooth_address_async", reinterpret_cast<PyCFunction>(BluetoothDevice_FromBluetoothAddressAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "from_host_name_async", reinterpret_cast<PyCFunction>(BluetoothDevice_FromHostNameAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(BluetoothDevice_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(BluetoothDevice_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector_from_bluetooth_address", reinterpret_cast<PyCFunction>(BluetoothDevice_GetDeviceSelectorFromBluetoothAddress), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector_from_class_of_device", reinterpret_cast<PyCFunction>(BluetoothDevice_GetDeviceSelectorFromClassOfDevice), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector_from_connection_status", reinterpret_cast<PyCFunction>(BluetoothDevice_GetDeviceSelectorFromConnectionStatus), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector_from_device_name", reinterpret_cast<PyCFunction>(BluetoothDevice_GetDeviceSelectorFromDeviceName), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector_from_pairing_state", reinterpret_cast<PyCFunction>(BluetoothDevice_GetDeviceSelectorFromPairingState), METH_VARARGS | METH_STATIC, nullptr },
        { "get_rfcomm_services_async", reinterpret_cast<PyCFunction>(BluetoothDevice_GetRfcommServicesAsync), METH_VARARGS, nullptr },
        { "get_rfcomm_services_for_id_async", reinterpret_cast<PyCFunction>(BluetoothDevice_GetRfcommServicesForIdAsync), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(BluetoothDevice_RequestAccessAsync), METH_VARARGS, nullptr },
        { "add_connection_status_changed", reinterpret_cast<PyCFunction>(BluetoothDevice_add_ConnectionStatusChanged), METH_O, nullptr },
        { "remove_connection_status_changed", reinterpret_cast<PyCFunction>(BluetoothDevice_remove_ConnectionStatusChanged), METH_O, nullptr },
        { "add_name_changed", reinterpret_cast<PyCFunction>(BluetoothDevice_add_NameChanged), METH_O, nullptr },
        { "remove_name_changed", reinterpret_cast<PyCFunction>(BluetoothDevice_remove_NameChanged), METH_O, nullptr },
        { "add_sdp_records_changed", reinterpret_cast<PyCFunction>(BluetoothDevice_add_SdpRecordsChanged), METH_O, nullptr },
        { "remove_sdp_records_changed", reinterpret_cast<PyCFunction>(BluetoothDevice_remove_SdpRecordsChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothDevice), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_BluetoothDevice), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_BluetoothDevice), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothDevice[] = {
        { "bluetooth_address", reinterpret_cast<getter>(BluetoothDevice_get_BluetoothAddress), nullptr, nullptr, nullptr },
        { "class_of_device", reinterpret_cast<getter>(BluetoothDevice_get_ClassOfDevice), nullptr, nullptr, nullptr },
        { "connection_status", reinterpret_cast<getter>(BluetoothDevice_get_ConnectionStatus), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(BluetoothDevice_get_DeviceId), nullptr, nullptr, nullptr },
        { "host_name", reinterpret_cast<getter>(BluetoothDevice_get_HostName), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(BluetoothDevice_get_Name), nullptr, nullptr, nullptr },
        { "rfcomm_services", reinterpret_cast<getter>(BluetoothDevice_get_RfcommServices), nullptr, nullptr, nullptr },
        { "sdp_records", reinterpret_cast<getter>(BluetoothDevice_get_SdpRecords), nullptr, nullptr, nullptr },
        { "device_information", reinterpret_cast<getter>(BluetoothDevice_get_DeviceInformation), nullptr, nullptr, nullptr },
        { "device_access_information", reinterpret_cast<getter>(BluetoothDevice_get_DeviceAccessInformation), nullptr, nullptr, nullptr },
        { "bluetooth_device_id", reinterpret_cast<getter>(BluetoothDevice_get_BluetoothDeviceId), nullptr, nullptr, nullptr },
        { "was_secure_connection_used_for_pairing", reinterpret_cast<getter>(BluetoothDevice_get_WasSecureConnectionUsedForPairing), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothDevice[] = 
    {
        { Py_tp_new, _new_BluetoothDevice },
        { Py_tp_dealloc, _dealloc_BluetoothDevice },
        { Py_tp_methods, _methods_BluetoothDevice },
        { Py_tp_getset, _getset_BluetoothDevice },
        { },
    };

    static PyType_Spec type_spec_BluetoothDevice =
    {
        "_winsdk_Windows_Devices_Bluetooth.BluetoothDevice",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothDevice
    };

    // ----- BluetoothDeviceId class --------------------
    constexpr const char* const type_name_BluetoothDeviceId = "BluetoothDeviceId";

    static PyObject* _new_BluetoothDeviceId(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BluetoothDeviceId);
        return nullptr;
    }

    static void _dealloc_BluetoothDeviceId(py::wrapper::Windows::Devices::Bluetooth::BluetoothDeviceId* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothDeviceId_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothDeviceId::FromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothDeviceId_get_Id(py::wrapper::Windows::Devices::Bluetooth::BluetoothDeviceId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDeviceId_get_IsClassicDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothDeviceId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsClassicDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothDeviceId_get_IsLowEnergyDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothDeviceId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLowEnergyDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BluetoothDeviceId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothDeviceId>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothDeviceId[] = {
        { "from_id", reinterpret_cast<PyCFunction>(BluetoothDeviceId_FromId), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothDeviceId), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothDeviceId[] = {
        { "id", reinterpret_cast<getter>(BluetoothDeviceId_get_Id), nullptr, nullptr, nullptr },
        { "is_classic_device", reinterpret_cast<getter>(BluetoothDeviceId_get_IsClassicDevice), nullptr, nullptr, nullptr },
        { "is_low_energy_device", reinterpret_cast<getter>(BluetoothDeviceId_get_IsLowEnergyDevice), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothDeviceId[] = 
    {
        { Py_tp_new, _new_BluetoothDeviceId },
        { Py_tp_dealloc, _dealloc_BluetoothDeviceId },
        { Py_tp_methods, _methods_BluetoothDeviceId },
        { Py_tp_getset, _getset_BluetoothDeviceId },
        { },
    };

    static PyType_Spec type_spec_BluetoothDeviceId =
    {
        "_winsdk_Windows_Devices_Bluetooth.BluetoothDeviceId",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothDeviceId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothDeviceId
    };

    // ----- BluetoothLEAppearance class --------------------
    constexpr const char* const type_name_BluetoothLEAppearance = "BluetoothLEAppearance";

    static PyObject* _new_BluetoothLEAppearance(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BluetoothLEAppearance);
        return nullptr;
    }

    static void _dealloc_BluetoothLEAppearance(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEAppearance* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEAppearance_FromParts(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearance::FromParts(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearance_FromRawValue(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearance::FromRawValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearance_get_Category(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEAppearance* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Category());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearance_get_RawValue(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEAppearance* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearance_get_SubCategory(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEAppearance* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SubCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BluetoothLEAppearance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothLEAppearance>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAppearance[] = {
        { "from_parts", reinterpret_cast<PyCFunction>(BluetoothLEAppearance_FromParts), METH_VARARGS | METH_STATIC, nullptr },
        { "from_raw_value", reinterpret_cast<PyCFunction>(BluetoothLEAppearance_FromRawValue), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEAppearance), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothLEAppearance[] = {
        { "category", reinterpret_cast<getter>(BluetoothLEAppearance_get_Category), nullptr, nullptr, nullptr },
        { "raw_value", reinterpret_cast<getter>(BluetoothLEAppearance_get_RawValue), nullptr, nullptr, nullptr },
        { "sub_category", reinterpret_cast<getter>(BluetoothLEAppearance_get_SubCategory), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothLEAppearance[] = 
    {
        { Py_tp_new, _new_BluetoothLEAppearance },
        { Py_tp_dealloc, _dealloc_BluetoothLEAppearance },
        { Py_tp_methods, _methods_BluetoothLEAppearance },
        { Py_tp_getset, _getset_BluetoothLEAppearance },
        { },
    };

    static PyType_Spec type_spec_BluetoothLEAppearance =
    {
        "_winsdk_Windows_Devices_Bluetooth.BluetoothLEAppearance",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEAppearance),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAppearance
    };

    // ----- BluetoothLEAppearanceCategories class --------------------
    constexpr const char* const type_name_BluetoothLEAppearanceCategories = "BluetoothLEAppearanceCategories";

    static PyObject* _new_BluetoothLEAppearanceCategories(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BluetoothLEAppearanceCategories);
        return nullptr;
    }

    static PyObject* BluetoothLEAppearanceCategories_get_BarcodeScanner(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::BarcodeScanner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_BloodPressure(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::BloodPressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Clock(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Clock());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Computer(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Computer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Cycling(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Cycling());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Display(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Display());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_EyeGlasses(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::EyeGlasses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_GlucoseMeter(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::GlucoseMeter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_HeartRate(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::HeartRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_HumanInterfaceDevice(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::HumanInterfaceDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Keyring(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Keyring());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_MediaPlayer(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::MediaPlayer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_OutdoorSportActivity(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::OutdoorSportActivity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Phone(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Phone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_PulseOximeter(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::PulseOximeter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_RemoteControl(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::RemoteControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_RunningWalking(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::RunningWalking());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Tag(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Thermometer(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Thermometer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Uncategorized(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Uncategorized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_Watch(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::Watch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceCategories_get_WeightScale(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories::WeightScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAppearanceCategories[] = {
        { "get_barcode_scanner", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceCategories_get_BarcodeScanner), METH_NOARGS | METH_STATIC, nullptr },
        { "get_blood_pressure", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceCategories_get_BloodPressure), METH_NOARGS | METH_STATIC, nullptr },
        { "get_clock", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceCategories_get_Clock), METH_NOARGS | METH_STATIC, nullptr },
        { "get_computer", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceCategories_get_Computer), METH_NOARGS | METH_STATIC, nullptr },
        { "get_cycling", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceCategories_get_Cycling), METH_NOARGS | METH_STATIC, nullptr },
        { "get_display", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceCategories_get_Display), METH_NOARGS | METH_STATIC, nullptr },
        { "get_eye_glasses", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceCategories_get_EyeGlasses), METH_NOARGS | METH_STATIC, nullptr },
        { "get_glucose_meter", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceCategories_get_GlucoseMeter), METH_NOARGS | METH_STATIC, nullptr },
        { "get_heart_rate", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceCategories_get_HeartRate), METH_NOARGS | METH_STATIC, nullptr },
        { "get_human_interface_device", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceCategories_get_HumanInterfaceDevice), METH_NOARGS | METH_STATIC, nullptr },
        { "get_keyring", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceCategories_get_Keyring), METH_NOARGS | METH_STATIC, nullptr },
        { "get_media_player", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceCategories_get_MediaPlayer), METH_NOARGS | METH_STATIC, nullptr },
        { "get_outdoor_sport_activity", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceCategories_get_OutdoorSportActivity), METH_NOARGS | METH_STATIC, nullptr },
        { "get_phone", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceCategories_get_Phone), METH_NOARGS | METH_STATIC, nullptr },
        { "get_pulse_oximeter", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceCategories_get_PulseOximeter), METH_NOARGS | METH_STATIC, nullptr },
        { "get_remote_control", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceCategories_get_RemoteControl), METH_NOARGS | METH_STATIC, nullptr },
        { "get_running_walking", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceCategories_get_RunningWalking), METH_NOARGS | METH_STATIC, nullptr },
        { "get_tag", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceCategories_get_Tag), METH_NOARGS | METH_STATIC, nullptr },
        { "get_thermometer", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceCategories_get_Thermometer), METH_NOARGS | METH_STATIC, nullptr },
        { "get_uncategorized", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceCategories_get_Uncategorized), METH_NOARGS | METH_STATIC, nullptr },
        { "get_watch", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceCategories_get_Watch), METH_NOARGS | METH_STATIC, nullptr },
        { "get_weight_scale", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceCategories_get_WeightScale), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothLEAppearanceCategories[] = {
        { }
    };

    static PyType_Slot _type_slots_BluetoothLEAppearanceCategories[] = 
    {
        { Py_tp_new, _new_BluetoothLEAppearanceCategories },
        { Py_tp_methods, _methods_BluetoothLEAppearanceCategories },
        { Py_tp_getset, _getset_BluetoothLEAppearanceCategories },
        { },
    };

    static PyType_Spec type_spec_BluetoothLEAppearanceCategories =
    {
        "_winsdk_Windows_Devices_Bluetooth.BluetoothLEAppearanceCategories",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAppearanceCategories
    };

    // ----- BluetoothLEAppearanceSubcategories class --------------------
    constexpr const char* const type_name_BluetoothLEAppearanceSubcategories = "BluetoothLEAppearanceSubcategories";

    static PyObject* _new_BluetoothLEAppearanceSubcategories(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BluetoothLEAppearanceSubcategories);
        return nullptr;
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_BarcodeScanner(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::BarcodeScanner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_BloodPressureArm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::BloodPressureArm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_BloodPressureWrist(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::BloodPressureWrist());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_CardReader(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CardReader());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_CyclingCadenceSensor(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CyclingCadenceSensor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_CyclingComputer(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CyclingComputer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_CyclingPowerSensor(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CyclingPowerSensor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_CyclingSpeedCadenceSensor(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CyclingSpeedCadenceSensor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_CyclingSpeedSensor(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::CyclingSpeedSensor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_DigitalPen(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::DigitalPen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_DigitizerTablet(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::DigitizerTablet());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_Gamepad(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::Gamepad());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_Generic(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::Generic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_HeartRateBelt(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::HeartRateBelt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_Joystick(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::Joystick());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_Keyboard(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::Keyboard());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_LocationDisplay(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::LocationDisplay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_LocationNavigationDisplay(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::LocationNavigationDisplay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_LocationNavigationPod(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::LocationNavigationPod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_LocationPod(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::LocationPod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_Mouse(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::Mouse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_OximeterFingertip(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::OximeterFingertip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_OximeterWristWorn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::OximeterWristWorn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_RunningWalkingInShoe(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::RunningWalkingInShoe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_RunningWalkingOnHip(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::RunningWalkingOnHip());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_RunningWalkingOnShoe(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::RunningWalkingOnShoe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_SportsWatch(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::SportsWatch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEAppearanceSubcategories_get_ThermometerEar(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories::ThermometerEar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEAppearanceSubcategories[] = {
        { "get_barcode_scanner", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_BarcodeScanner), METH_NOARGS | METH_STATIC, nullptr },
        { "get_blood_pressure_arm", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_BloodPressureArm), METH_NOARGS | METH_STATIC, nullptr },
        { "get_blood_pressure_wrist", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_BloodPressureWrist), METH_NOARGS | METH_STATIC, nullptr },
        { "get_card_reader", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_CardReader), METH_NOARGS | METH_STATIC, nullptr },
        { "get_cycling_cadence_sensor", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_CyclingCadenceSensor), METH_NOARGS | METH_STATIC, nullptr },
        { "get_cycling_computer", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_CyclingComputer), METH_NOARGS | METH_STATIC, nullptr },
        { "get_cycling_power_sensor", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_CyclingPowerSensor), METH_NOARGS | METH_STATIC, nullptr },
        { "get_cycling_speed_cadence_sensor", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_CyclingSpeedCadenceSensor), METH_NOARGS | METH_STATIC, nullptr },
        { "get_cycling_speed_sensor", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_CyclingSpeedSensor), METH_NOARGS | METH_STATIC, nullptr },
        { "get_digital_pen", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_DigitalPen), METH_NOARGS | METH_STATIC, nullptr },
        { "get_digitizer_tablet", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_DigitizerTablet), METH_NOARGS | METH_STATIC, nullptr },
        { "get_gamepad", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_Gamepad), METH_NOARGS | METH_STATIC, nullptr },
        { "get_generic", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_Generic), METH_NOARGS | METH_STATIC, nullptr },
        { "get_heart_rate_belt", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_HeartRateBelt), METH_NOARGS | METH_STATIC, nullptr },
        { "get_joystick", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_Joystick), METH_NOARGS | METH_STATIC, nullptr },
        { "get_keyboard", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_Keyboard), METH_NOARGS | METH_STATIC, nullptr },
        { "get_location_display", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_LocationDisplay), METH_NOARGS | METH_STATIC, nullptr },
        { "get_location_navigation_display", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_LocationNavigationDisplay), METH_NOARGS | METH_STATIC, nullptr },
        { "get_location_navigation_pod", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_LocationNavigationPod), METH_NOARGS | METH_STATIC, nullptr },
        { "get_location_pod", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_LocationPod), METH_NOARGS | METH_STATIC, nullptr },
        { "get_mouse", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_Mouse), METH_NOARGS | METH_STATIC, nullptr },
        { "get_oximeter_fingertip", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_OximeterFingertip), METH_NOARGS | METH_STATIC, nullptr },
        { "get_oximeter_wrist_worn", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_OximeterWristWorn), METH_NOARGS | METH_STATIC, nullptr },
        { "get_running_walking_in_shoe", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_RunningWalkingInShoe), METH_NOARGS | METH_STATIC, nullptr },
        { "get_running_walking_on_hip", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_RunningWalkingOnHip), METH_NOARGS | METH_STATIC, nullptr },
        { "get_running_walking_on_shoe", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_RunningWalkingOnShoe), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sports_watch", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_SportsWatch), METH_NOARGS | METH_STATIC, nullptr },
        { "get_thermometer_ear", reinterpret_cast<PyCFunction>(BluetoothLEAppearanceSubcategories_get_ThermometerEar), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothLEAppearanceSubcategories[] = {
        { }
    };

    static PyType_Slot _type_slots_BluetoothLEAppearanceSubcategories[] = 
    {
        { Py_tp_new, _new_BluetoothLEAppearanceSubcategories },
        { Py_tp_methods, _methods_BluetoothLEAppearanceSubcategories },
        { Py_tp_getset, _getset_BluetoothLEAppearanceSubcategories },
        { },
    };

    static PyType_Spec type_spec_BluetoothLEAppearanceSubcategories =
    {
        "_winsdk_Windows_Devices_Bluetooth.BluetoothLEAppearanceSubcategories",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEAppearanceSubcategories
    };

    // ----- BluetoothLEConnectionParameters class --------------------
    constexpr const char* const type_name_BluetoothLEConnectionParameters = "BluetoothLEConnectionParameters";

    static PyObject* _new_BluetoothLEConnectionParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BluetoothLEConnectionParameters);
        return nullptr;
    }

    static void _dealloc_BluetoothLEConnectionParameters(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEConnectionParameters_get_ConnectionInterval(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEConnectionParameters_get_ConnectionLatency(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEConnectionParameters_get_LinkTimeout(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LinkTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BluetoothLEConnectionParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEConnectionParameters[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEConnectionParameters), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothLEConnectionParameters[] = {
        { "connection_interval", reinterpret_cast<getter>(BluetoothLEConnectionParameters_get_ConnectionInterval), nullptr, nullptr, nullptr },
        { "connection_latency", reinterpret_cast<getter>(BluetoothLEConnectionParameters_get_ConnectionLatency), nullptr, nullptr, nullptr },
        { "link_timeout", reinterpret_cast<getter>(BluetoothLEConnectionParameters_get_LinkTimeout), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothLEConnectionParameters[] = 
    {
        { Py_tp_new, _new_BluetoothLEConnectionParameters },
        { Py_tp_dealloc, _dealloc_BluetoothLEConnectionParameters },
        { Py_tp_methods, _methods_BluetoothLEConnectionParameters },
        { Py_tp_getset, _getset_BluetoothLEConnectionParameters },
        { },
    };

    static PyType_Spec type_spec_BluetoothLEConnectionParameters =
    {
        "_winsdk_Windows_Devices_Bluetooth.BluetoothLEConnectionParameters",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEConnectionParameters
    };

    // ----- BluetoothLEConnectionPhy class --------------------
    constexpr const char* const type_name_BluetoothLEConnectionPhy = "BluetoothLEConnectionPhy";

    static PyObject* _new_BluetoothLEConnectionPhy(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BluetoothLEConnectionPhy);
        return nullptr;
    }

    static void _dealloc_BluetoothLEConnectionPhy(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhy* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEConnectionPhy_get_ReceiveInfo(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhy* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReceiveInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEConnectionPhy_get_TransmitInfo(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhy* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransmitInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BluetoothLEConnectionPhy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionPhy>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEConnectionPhy[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEConnectionPhy), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothLEConnectionPhy[] = {
        { "receive_info", reinterpret_cast<getter>(BluetoothLEConnectionPhy_get_ReceiveInfo), nullptr, nullptr, nullptr },
        { "transmit_info", reinterpret_cast<getter>(BluetoothLEConnectionPhy_get_TransmitInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothLEConnectionPhy[] = 
    {
        { Py_tp_new, _new_BluetoothLEConnectionPhy },
        { Py_tp_dealloc, _dealloc_BluetoothLEConnectionPhy },
        { Py_tp_methods, _methods_BluetoothLEConnectionPhy },
        { Py_tp_getset, _getset_BluetoothLEConnectionPhy },
        { },
    };

    static PyType_Spec type_spec_BluetoothLEConnectionPhy =
    {
        "_winsdk_Windows_Devices_Bluetooth.BluetoothLEConnectionPhy",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhy),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEConnectionPhy
    };

    // ----- BluetoothLEConnectionPhyInfo class --------------------
    constexpr const char* const type_name_BluetoothLEConnectionPhyInfo = "BluetoothLEConnectionPhyInfo";

    static PyObject* _new_BluetoothLEConnectionPhyInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BluetoothLEConnectionPhyInfo);
        return nullptr;
    }

    static void _dealloc_BluetoothLEConnectionPhyInfo(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEConnectionPhyInfo_get_IsCodedPhy(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCodedPhy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEConnectionPhyInfo_get_IsUncoded1MPhy(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUncoded1MPhy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEConnectionPhyInfo_get_IsUncoded2MPhy(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUncoded2MPhy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BluetoothLEConnectionPhyInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEConnectionPhyInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEConnectionPhyInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothLEConnectionPhyInfo[] = {
        { "is_coded_phy", reinterpret_cast<getter>(BluetoothLEConnectionPhyInfo_get_IsCodedPhy), nullptr, nullptr, nullptr },
        { "is_uncoded1_m_phy", reinterpret_cast<getter>(BluetoothLEConnectionPhyInfo_get_IsUncoded1MPhy), nullptr, nullptr, nullptr },
        { "is_uncoded2_m_phy", reinterpret_cast<getter>(BluetoothLEConnectionPhyInfo_get_IsUncoded2MPhy), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothLEConnectionPhyInfo[] = 
    {
        { Py_tp_new, _new_BluetoothLEConnectionPhyInfo },
        { Py_tp_dealloc, _dealloc_BluetoothLEConnectionPhyInfo },
        { Py_tp_methods, _methods_BluetoothLEConnectionPhyInfo },
        { Py_tp_getset, _getset_BluetoothLEConnectionPhyInfo },
        { },
    };

    static PyType_Spec type_spec_BluetoothLEConnectionPhyInfo =
    {
        "_winsdk_Windows_Devices_Bluetooth.BluetoothLEConnectionPhyInfo",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEConnectionPhyInfo
    };

    // ----- BluetoothLEDevice class --------------------
    constexpr const char* const type_name_BluetoothLEDevice = "BluetoothLEDevice";

    static PyObject* _new_BluetoothLEDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BluetoothLEDevice);
        return nullptr;
    }

    static void _dealloc_BluetoothLEDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEDevice_Close(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_FromBluetoothAddressAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::FromBluetoothAddressAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothAddressType>(args, 1);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::FromBluetoothAddressAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetConnectionParameters(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConnectionParameters());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetConnectionPhy(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConnectionPhy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetDeviceSelectorFromAppearance(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothLEAppearance>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromAppearance(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetDeviceSelectorFromBluetoothAddress(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromBluetoothAddress(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothAddressType>(args, 1);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromBluetoothAddress(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetDeviceSelectorFromConnectionStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothConnectionStatus>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromConnectionStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetDeviceSelectorFromDeviceName(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromDeviceName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetDeviceSelectorFromPairingState(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEDevice::GetDeviceSelectorFromPairingState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetGattService(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.GetGattService(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetGattServicesAsync(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetGattServicesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>(args, 0);

                return py::convert(self->obj.GetGattServicesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_GetGattServicesForUuidAsync(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.GetGattServicesForUuidAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>(args, 1);

                return py::convert(self->obj.GetGattServicesForUuidAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_RequestAccessAsync(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_RequestPreferredConnectionParameters(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters>(args, 0);

                return py::convert(self->obj.RequestPreferredConnectionParameters(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_BluetoothAddress(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BluetoothAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_ConnectionStatus(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_DeviceId(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_GattServices(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.GattServices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_Name(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_Appearance(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Appearance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_BluetoothAddressType(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BluetoothAddressType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_DeviceInformation(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_DeviceAccessInformation(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceAccessInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_BluetoothDeviceId(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BluetoothDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_get_WasSecureConnectionUsedForPairing(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WasSecureConnectionUsedForPairing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_add_ConnectionStatusChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ConnectionStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_remove_ConnectionStatusChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_add_GattServicesChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.GattServicesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_remove_GattServicesChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.GattServicesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_add_NameChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.NameChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_remove_NameChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.NameChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_add_ConnectionParametersChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ConnectionParametersChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_remove_ConnectionParametersChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionParametersChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_add_ConnectionPhyChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ConnectionPhyChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEDevice_remove_ConnectionPhyChanged(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionPhyChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BluetoothLEDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_BluetoothLEDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_BluetoothLEDevice(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEDevice[] = {
        { "close", reinterpret_cast<PyCFunction>(BluetoothLEDevice_Close), METH_VARARGS, nullptr },
        { "from_bluetooth_address_async", reinterpret_cast<PyCFunction>(BluetoothLEDevice_FromBluetoothAddressAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(BluetoothLEDevice_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_connection_parameters", reinterpret_cast<PyCFunction>(BluetoothLEDevice_GetConnectionParameters), METH_VARARGS, nullptr },
        { "get_connection_phy", reinterpret_cast<PyCFunction>(BluetoothLEDevice_GetConnectionPhy), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(BluetoothLEDevice_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector_from_appearance", reinterpret_cast<PyCFunction>(BluetoothLEDevice_GetDeviceSelectorFromAppearance), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector_from_bluetooth_address", reinterpret_cast<PyCFunction>(BluetoothLEDevice_GetDeviceSelectorFromBluetoothAddress), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector_from_connection_status", reinterpret_cast<PyCFunction>(BluetoothLEDevice_GetDeviceSelectorFromConnectionStatus), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector_from_device_name", reinterpret_cast<PyCFunction>(BluetoothLEDevice_GetDeviceSelectorFromDeviceName), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector_from_pairing_state", reinterpret_cast<PyCFunction>(BluetoothLEDevice_GetDeviceSelectorFromPairingState), METH_VARARGS | METH_STATIC, nullptr },
        { "get_gatt_service", reinterpret_cast<PyCFunction>(BluetoothLEDevice_GetGattService), METH_VARARGS, nullptr },
        { "get_gatt_services_async", reinterpret_cast<PyCFunction>(BluetoothLEDevice_GetGattServicesAsync), METH_VARARGS, nullptr },
        { "get_gatt_services_for_uuid_async", reinterpret_cast<PyCFunction>(BluetoothLEDevice_GetGattServicesForUuidAsync), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(BluetoothLEDevice_RequestAccessAsync), METH_VARARGS, nullptr },
        { "request_preferred_connection_parameters", reinterpret_cast<PyCFunction>(BluetoothLEDevice_RequestPreferredConnectionParameters), METH_VARARGS, nullptr },
        { "add_connection_status_changed", reinterpret_cast<PyCFunction>(BluetoothLEDevice_add_ConnectionStatusChanged), METH_O, nullptr },
        { "remove_connection_status_changed", reinterpret_cast<PyCFunction>(BluetoothLEDevice_remove_ConnectionStatusChanged), METH_O, nullptr },
        { "add_gatt_services_changed", reinterpret_cast<PyCFunction>(BluetoothLEDevice_add_GattServicesChanged), METH_O, nullptr },
        { "remove_gatt_services_changed", reinterpret_cast<PyCFunction>(BluetoothLEDevice_remove_GattServicesChanged), METH_O, nullptr },
        { "add_name_changed", reinterpret_cast<PyCFunction>(BluetoothLEDevice_add_NameChanged), METH_O, nullptr },
        { "remove_name_changed", reinterpret_cast<PyCFunction>(BluetoothLEDevice_remove_NameChanged), METH_O, nullptr },
        { "add_connection_parameters_changed", reinterpret_cast<PyCFunction>(BluetoothLEDevice_add_ConnectionParametersChanged), METH_O, nullptr },
        { "remove_connection_parameters_changed", reinterpret_cast<PyCFunction>(BluetoothLEDevice_remove_ConnectionParametersChanged), METH_O, nullptr },
        { "add_connection_phy_changed", reinterpret_cast<PyCFunction>(BluetoothLEDevice_add_ConnectionPhyChanged), METH_O, nullptr },
        { "remove_connection_phy_changed", reinterpret_cast<PyCFunction>(BluetoothLEDevice_remove_ConnectionPhyChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEDevice), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_BluetoothLEDevice), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_BluetoothLEDevice), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothLEDevice[] = {
        { "bluetooth_address", reinterpret_cast<getter>(BluetoothLEDevice_get_BluetoothAddress), nullptr, nullptr, nullptr },
        { "connection_status", reinterpret_cast<getter>(BluetoothLEDevice_get_ConnectionStatus), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(BluetoothLEDevice_get_DeviceId), nullptr, nullptr, nullptr },
        { "gatt_services", reinterpret_cast<getter>(BluetoothLEDevice_get_GattServices), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(BluetoothLEDevice_get_Name), nullptr, nullptr, nullptr },
        { "appearance", reinterpret_cast<getter>(BluetoothLEDevice_get_Appearance), nullptr, nullptr, nullptr },
        { "bluetooth_address_type", reinterpret_cast<getter>(BluetoothLEDevice_get_BluetoothAddressType), nullptr, nullptr, nullptr },
        { "device_information", reinterpret_cast<getter>(BluetoothLEDevice_get_DeviceInformation), nullptr, nullptr, nullptr },
        { "device_access_information", reinterpret_cast<getter>(BluetoothLEDevice_get_DeviceAccessInformation), nullptr, nullptr, nullptr },
        { "bluetooth_device_id", reinterpret_cast<getter>(BluetoothLEDevice_get_BluetoothDeviceId), nullptr, nullptr, nullptr },
        { "was_secure_connection_used_for_pairing", reinterpret_cast<getter>(BluetoothLEDevice_get_WasSecureConnectionUsedForPairing), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothLEDevice[] = 
    {
        { Py_tp_new, _new_BluetoothLEDevice },
        { Py_tp_dealloc, _dealloc_BluetoothLEDevice },
        { Py_tp_methods, _methods_BluetoothLEDevice },
        { Py_tp_getset, _getset_BluetoothLEDevice },
        { },
    };

    static PyType_Spec type_spec_BluetoothLEDevice =
    {
        "_winsdk_Windows_Devices_Bluetooth.BluetoothLEDevice",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEDevice
    };

    // ----- BluetoothLEPreferredConnectionParameters class --------------------
    constexpr const char* const type_name_BluetoothLEPreferredConnectionParameters = "BluetoothLEPreferredConnectionParameters";

    static PyObject* _new_BluetoothLEPreferredConnectionParameters(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BluetoothLEPreferredConnectionParameters);
        return nullptr;
    }

    static void _dealloc_BluetoothLEPreferredConnectionParameters(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEPreferredConnectionParameters_get_ConnectionLatency(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionLatency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEPreferredConnectionParameters_get_LinkTimeout(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LinkTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEPreferredConnectionParameters_get_MaxConnectionInterval(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxConnectionInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEPreferredConnectionParameters_get_MinConnectionInterval(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinConnectionInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEPreferredConnectionParameters_get_Balanced(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters::Balanced());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEPreferredConnectionParameters_get_PowerOptimized(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters::PowerOptimized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BluetoothLEPreferredConnectionParameters_get_ThroughputOptimized(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters::ThroughputOptimized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BluetoothLEPreferredConnectionParameters(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEPreferredConnectionParameters[] = {
        { "get_balanced", reinterpret_cast<PyCFunction>(BluetoothLEPreferredConnectionParameters_get_Balanced), METH_NOARGS | METH_STATIC, nullptr },
        { "get_power_optimized", reinterpret_cast<PyCFunction>(BluetoothLEPreferredConnectionParameters_get_PowerOptimized), METH_NOARGS | METH_STATIC, nullptr },
        { "get_throughput_optimized", reinterpret_cast<PyCFunction>(BluetoothLEPreferredConnectionParameters_get_ThroughputOptimized), METH_NOARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEPreferredConnectionParameters), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothLEPreferredConnectionParameters[] = {
        { "connection_latency", reinterpret_cast<getter>(BluetoothLEPreferredConnectionParameters_get_ConnectionLatency), nullptr, nullptr, nullptr },
        { "link_timeout", reinterpret_cast<getter>(BluetoothLEPreferredConnectionParameters_get_LinkTimeout), nullptr, nullptr, nullptr },
        { "max_connection_interval", reinterpret_cast<getter>(BluetoothLEPreferredConnectionParameters_get_MaxConnectionInterval), nullptr, nullptr, nullptr },
        { "min_connection_interval", reinterpret_cast<getter>(BluetoothLEPreferredConnectionParameters_get_MinConnectionInterval), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothLEPreferredConnectionParameters[] = 
    {
        { Py_tp_new, _new_BluetoothLEPreferredConnectionParameters },
        { Py_tp_dealloc, _dealloc_BluetoothLEPreferredConnectionParameters },
        { Py_tp_methods, _methods_BluetoothLEPreferredConnectionParameters },
        { Py_tp_getset, _getset_BluetoothLEPreferredConnectionParameters },
        { },
    };

    static PyType_Spec type_spec_BluetoothLEPreferredConnectionParameters =
    {
        "_winsdk_Windows_Devices_Bluetooth.BluetoothLEPreferredConnectionParameters",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEPreferredConnectionParameters
    };

    // ----- BluetoothLEPreferredConnectionParametersRequest class --------------------
    constexpr const char* const type_name_BluetoothLEPreferredConnectionParametersRequest = "BluetoothLEPreferredConnectionParametersRequest";

    static PyObject* _new_BluetoothLEPreferredConnectionParametersRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BluetoothLEPreferredConnectionParametersRequest);
        return nullptr;
    }

    static void _dealloc_BluetoothLEPreferredConnectionParametersRequest(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothLEPreferredConnectionParametersRequest_Close(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothLEPreferredConnectionParametersRequest_get_Status(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BluetoothLEPreferredConnectionParametersRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_BluetoothLEPreferredConnectionParametersRequest(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_BluetoothLEPreferredConnectionParametersRequest(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothLEPreferredConnectionParametersRequest[] = {
        { "close", reinterpret_cast<PyCFunction>(BluetoothLEPreferredConnectionParametersRequest_Close), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothLEPreferredConnectionParametersRequest), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_BluetoothLEPreferredConnectionParametersRequest), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_BluetoothLEPreferredConnectionParametersRequest), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothLEPreferredConnectionParametersRequest[] = {
        { "status", reinterpret_cast<getter>(BluetoothLEPreferredConnectionParametersRequest_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothLEPreferredConnectionParametersRequest[] = 
    {
        { Py_tp_new, _new_BluetoothLEPreferredConnectionParametersRequest },
        { Py_tp_dealloc, _dealloc_BluetoothLEPreferredConnectionParametersRequest },
        { Py_tp_methods, _methods_BluetoothLEPreferredConnectionParametersRequest },
        { Py_tp_getset, _getset_BluetoothLEPreferredConnectionParametersRequest },
        { },
    };

    static PyType_Spec type_spec_BluetoothLEPreferredConnectionParametersRequest =
    {
        "_winsdk_Windows_Devices_Bluetooth.BluetoothLEPreferredConnectionParametersRequest",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothLEPreferredConnectionParametersRequest
    };

    // ----- BluetoothSignalStrengthFilter class --------------------
    constexpr const char* const type_name_BluetoothSignalStrengthFilter = "BluetoothSignalStrengthFilter";

    static PyObject* _new_BluetoothSignalStrengthFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BluetoothSignalStrengthFilter(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BluetoothSignalStrengthFilter_get_SamplingInterval(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SamplingInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothSignalStrengthFilter_put_SamplingInterval(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.SamplingInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothSignalStrengthFilter_get_OutOfRangeTimeout(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutOfRangeTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothSignalStrengthFilter_put_OutOfRangeTimeout(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.OutOfRangeTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothSignalStrengthFilter_get_OutOfRangeThresholdInDBm(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutOfRangeThresholdInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothSignalStrengthFilter_put_OutOfRangeThresholdInDBm(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int16_t>>(arg);

            self->obj.OutOfRangeThresholdInDBm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BluetoothSignalStrengthFilter_get_InRangeThresholdInDBm(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InRangeThresholdInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BluetoothSignalStrengthFilter_put_InRangeThresholdInDBm(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int16_t>>(arg);

            self->obj.InRangeThresholdInDBm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_BluetoothSignalStrengthFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothSignalStrengthFilter[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_BluetoothSignalStrengthFilter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothSignalStrengthFilter[] = {
        { "sampling_interval", reinterpret_cast<getter>(BluetoothSignalStrengthFilter_get_SamplingInterval), reinterpret_cast<setter>(BluetoothSignalStrengthFilter_put_SamplingInterval), nullptr, nullptr },
        { "out_of_range_timeout", reinterpret_cast<getter>(BluetoothSignalStrengthFilter_get_OutOfRangeTimeout), reinterpret_cast<setter>(BluetoothSignalStrengthFilter_put_OutOfRangeTimeout), nullptr, nullptr },
        { "out_of_range_threshold_in_d_bm", reinterpret_cast<getter>(BluetoothSignalStrengthFilter_get_OutOfRangeThresholdInDBm), reinterpret_cast<setter>(BluetoothSignalStrengthFilter_put_OutOfRangeThresholdInDBm), nullptr, nullptr },
        { "in_range_threshold_in_d_bm", reinterpret_cast<getter>(BluetoothSignalStrengthFilter_get_InRangeThresholdInDBm), reinterpret_cast<setter>(BluetoothSignalStrengthFilter_put_InRangeThresholdInDBm), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BluetoothSignalStrengthFilter[] = 
    {
        { Py_tp_new, _new_BluetoothSignalStrengthFilter },
        { Py_tp_dealloc, _dealloc_BluetoothSignalStrengthFilter },
        { Py_tp_methods, _methods_BluetoothSignalStrengthFilter },
        { Py_tp_getset, _getset_BluetoothSignalStrengthFilter },
        { },
    };

    static PyType_Spec type_spec_BluetoothSignalStrengthFilter =
    {
        "_winsdk_Windows_Devices_Bluetooth.BluetoothSignalStrengthFilter",
        sizeof(py::wrapper::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothSignalStrengthFilter
    };

    // ----- BluetoothUuidHelper class --------------------
    constexpr const char* const type_name_BluetoothUuidHelper = "BluetoothUuidHelper";

    static PyObject* _new_BluetoothUuidHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BluetoothUuidHelper);
        return nullptr;
    }

    static PyObject* BluetoothUuidHelper_FromShortId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothUuidHelper::FromShortId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BluetoothUuidHelper_TryGetShortId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::Devices::Bluetooth::BluetoothUuidHelper::TryGetShortId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_BluetoothUuidHelper[] = {
        { "from_short_id", reinterpret_cast<PyCFunction>(BluetoothUuidHelper_FromShortId), METH_VARARGS | METH_STATIC, nullptr },
        { "try_get_short_id", reinterpret_cast<PyCFunction>(BluetoothUuidHelper_TryGetShortId), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BluetoothUuidHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_BluetoothUuidHelper[] = 
    {
        { Py_tp_new, _new_BluetoothUuidHelper },
        { Py_tp_methods, _methods_BluetoothUuidHelper },
        { Py_tp_getset, _getset_BluetoothUuidHelper },
        { },
    };

    static PyType_Spec type_spec_BluetoothUuidHelper =
    {
        "_winsdk_Windows_Devices_Bluetooth.BluetoothUuidHelper",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BluetoothUuidHelper
    };

    // ----- Windows.Devices.Bluetooth Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::Bluetooth");

    static PyMethodDef module_methods[] = {
        {"_register_BluetoothAddressType", register_BluetoothAddressType, METH_O, "registers type"},
        {"_register_BluetoothCacheMode", register_BluetoothCacheMode, METH_O, "registers type"},
        {"_register_BluetoothConnectionStatus", register_BluetoothConnectionStatus, METH_O, "registers type"},
        {"_register_BluetoothError", register_BluetoothError, METH_O, "registers type"},
        {"_register_BluetoothLEPreferredConnectionParametersRequestStatus", register_BluetoothLEPreferredConnectionParametersRequestStatus, METH_O, "registers type"},
        {"_register_BluetoothMajorClass", register_BluetoothMajorClass, METH_O, "registers type"},
        {"_register_BluetoothMinorClass", register_BluetoothMinorClass, METH_O, "registers type"},
        {"_register_BluetoothServiceCapabilities", register_BluetoothServiceCapabilities, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_BluetoothAddressType);
        Py_VISIT(state->type_BluetoothCacheMode);
        Py_VISIT(state->type_BluetoothConnectionStatus);
        Py_VISIT(state->type_BluetoothError);
        Py_VISIT(state->type_BluetoothLEPreferredConnectionParametersRequestStatus);
        Py_VISIT(state->type_BluetoothMajorClass);
        Py_VISIT(state->type_BluetoothMinorClass);
        Py_VISIT(state->type_BluetoothServiceCapabilities);
        Py_VISIT(state->type_BluetoothAdapter);
        Py_VISIT(state->type_BluetoothClassOfDevice);
        Py_VISIT(state->type_BluetoothDevice);
        Py_VISIT(state->type_BluetoothDeviceId);
        Py_VISIT(state->type_BluetoothLEAppearance);
        Py_VISIT(state->type_BluetoothLEAppearanceCategories);
        Py_VISIT(state->type_BluetoothLEAppearanceSubcategories);
        Py_VISIT(state->type_BluetoothLEConnectionParameters);
        Py_VISIT(state->type_BluetoothLEConnectionPhy);
        Py_VISIT(state->type_BluetoothLEConnectionPhyInfo);
        Py_VISIT(state->type_BluetoothLEDevice);
        Py_VISIT(state->type_BluetoothLEPreferredConnectionParameters);
        Py_VISIT(state->type_BluetoothLEPreferredConnectionParametersRequest);
        Py_VISIT(state->type_BluetoothSignalStrengthFilter);
        Py_VISIT(state->type_BluetoothUuidHelper);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_BluetoothAddressType);
        Py_CLEAR(state->type_BluetoothCacheMode);
        Py_CLEAR(state->type_BluetoothConnectionStatus);
        Py_CLEAR(state->type_BluetoothError);
        Py_CLEAR(state->type_BluetoothLEPreferredConnectionParametersRequestStatus);
        Py_CLEAR(state->type_BluetoothMajorClass);
        Py_CLEAR(state->type_BluetoothMinorClass);
        Py_CLEAR(state->type_BluetoothServiceCapabilities);
        Py_CLEAR(state->type_BluetoothAdapter);
        Py_CLEAR(state->type_BluetoothClassOfDevice);
        Py_CLEAR(state->type_BluetoothDevice);
        Py_CLEAR(state->type_BluetoothDeviceId);
        Py_CLEAR(state->type_BluetoothLEAppearance);
        Py_CLEAR(state->type_BluetoothLEAppearanceCategories);
        Py_CLEAR(state->type_BluetoothLEAppearanceSubcategories);
        Py_CLEAR(state->type_BluetoothLEConnectionParameters);
        Py_CLEAR(state->type_BluetoothLEConnectionPhy);
        Py_CLEAR(state->type_BluetoothLEConnectionPhyInfo);
        Py_CLEAR(state->type_BluetoothLEDevice);
        Py_CLEAR(state->type_BluetoothLEPreferredConnectionParameters);
        Py_CLEAR(state->type_BluetoothLEPreferredConnectionParametersRequest);
        Py_CLEAR(state->type_BluetoothSignalStrengthFilter);
        Py_CLEAR(state->type_BluetoothUuidHelper);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Devices_Bluetooth",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Devices::Bluetooth

PyMODINIT_FUNC PyInit__winsdk_Windows_Devices_Bluetooth(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Bluetooth;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_BluetoothAdapter = py::register_python_type(module.get(), type_name_BluetoothAdapter, &type_spec_BluetoothAdapter, bases.get());
    if (!state->type_BluetoothAdapter)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BluetoothAdapter);

    state->type_BluetoothClassOfDevice = py::register_python_type(module.get(), type_name_BluetoothClassOfDevice, &type_spec_BluetoothClassOfDevice, bases.get());
    if (!state->type_BluetoothClassOfDevice)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BluetoothClassOfDevice);

    state->type_BluetoothDevice = py::register_python_type(module.get(), type_name_BluetoothDevice, &type_spec_BluetoothDevice, bases.get());
    if (!state->type_BluetoothDevice)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BluetoothDevice);

    state->type_BluetoothDeviceId = py::register_python_type(module.get(), type_name_BluetoothDeviceId, &type_spec_BluetoothDeviceId, bases.get());
    if (!state->type_BluetoothDeviceId)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BluetoothDeviceId);

    state->type_BluetoothLEAppearance = py::register_python_type(module.get(), type_name_BluetoothLEAppearance, &type_spec_BluetoothLEAppearance, bases.get());
    if (!state->type_BluetoothLEAppearance)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BluetoothLEAppearance);

    state->type_BluetoothLEAppearanceCategories = py::register_python_type(module.get(), type_name_BluetoothLEAppearanceCategories, &type_spec_BluetoothLEAppearanceCategories, nullptr);
    if (!state->type_BluetoothLEAppearanceCategories)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BluetoothLEAppearanceCategories);

    state->type_BluetoothLEAppearanceSubcategories = py::register_python_type(module.get(), type_name_BluetoothLEAppearanceSubcategories, &type_spec_BluetoothLEAppearanceSubcategories, nullptr);
    if (!state->type_BluetoothLEAppearanceSubcategories)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BluetoothLEAppearanceSubcategories);

    state->type_BluetoothLEConnectionParameters = py::register_python_type(module.get(), type_name_BluetoothLEConnectionParameters, &type_spec_BluetoothLEConnectionParameters, bases.get());
    if (!state->type_BluetoothLEConnectionParameters)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BluetoothLEConnectionParameters);

    state->type_BluetoothLEConnectionPhy = py::register_python_type(module.get(), type_name_BluetoothLEConnectionPhy, &type_spec_BluetoothLEConnectionPhy, bases.get());
    if (!state->type_BluetoothLEConnectionPhy)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BluetoothLEConnectionPhy);

    state->type_BluetoothLEConnectionPhyInfo = py::register_python_type(module.get(), type_name_BluetoothLEConnectionPhyInfo, &type_spec_BluetoothLEConnectionPhyInfo, bases.get());
    if (!state->type_BluetoothLEConnectionPhyInfo)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BluetoothLEConnectionPhyInfo);

    state->type_BluetoothLEDevice = py::register_python_type(module.get(), type_name_BluetoothLEDevice, &type_spec_BluetoothLEDevice, bases.get());
    if (!state->type_BluetoothLEDevice)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BluetoothLEDevice);

    state->type_BluetoothLEPreferredConnectionParameters = py::register_python_type(module.get(), type_name_BluetoothLEPreferredConnectionParameters, &type_spec_BluetoothLEPreferredConnectionParameters, bases.get());
    if (!state->type_BluetoothLEPreferredConnectionParameters)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BluetoothLEPreferredConnectionParameters);

    state->type_BluetoothLEPreferredConnectionParametersRequest = py::register_python_type(module.get(), type_name_BluetoothLEPreferredConnectionParametersRequest, &type_spec_BluetoothLEPreferredConnectionParametersRequest, bases.get());
    if (!state->type_BluetoothLEPreferredConnectionParametersRequest)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BluetoothLEPreferredConnectionParametersRequest);

    state->type_BluetoothSignalStrengthFilter = py::register_python_type(module.get(), type_name_BluetoothSignalStrengthFilter, &type_spec_BluetoothSignalStrengthFilter, bases.get());
    if (!state->type_BluetoothSignalStrengthFilter)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BluetoothSignalStrengthFilter);

    state->type_BluetoothUuidHelper = py::register_python_type(module.get(), type_name_BluetoothUuidHelper, &type_spec_BluetoothUuidHelper, nullptr);
    if (!state->type_BluetoothUuidHelper)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BluetoothUuidHelper);


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothAddressType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothAddressType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothAddressType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothCacheMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothCacheMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothCacheMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothConnectionStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothConnectionStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothConnectionStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothError>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothError;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothError is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequestStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothLEPreferredConnectionParametersRequestStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequestStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothMajorClass>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothMajorClass;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothMajorClass is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothMinorClass>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothMinorClass;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothMinorClass is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Bluetooth::BluetoothServiceCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothServiceCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothServiceCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothAdapter>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothAdapter;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothAdapter is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothClassOfDevice>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothClassOfDevice;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothClassOfDevice is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothDevice>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothDevice;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothDevice is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothDeviceId>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothDeviceId;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothDeviceId is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEAppearance>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothLEAppearance;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothLEAppearance is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothLEAppearanceCategories;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceCategories is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothLEAppearanceSubcategories;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothLEAppearanceSubcategories is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothLEConnectionParameters;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionParameters is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionPhy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothLEConnectionPhy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionPhy is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothLEConnectionPhyInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothLEConnectionPhyInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEDevice>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothLEDevice;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothLEDevice is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothLEPreferredConnectionParameters;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParameters is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothLEPreferredConnectionParametersRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothLEPreferredConnectionParametersRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothSignalStrengthFilter;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothSignalStrengthFilter is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Bluetooth::BluetoothUuidHelper>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Bluetooth;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Bluetooth");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BluetoothUuidHelper;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Bluetooth::BluetoothUuidHelper is not registered");
        return nullptr;
    }

    return python_type;
}
