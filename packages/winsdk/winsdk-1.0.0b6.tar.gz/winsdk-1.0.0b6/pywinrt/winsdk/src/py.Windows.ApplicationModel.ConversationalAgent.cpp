// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.6

#include "pybase.h"
#include "py.Windows.ApplicationModel.ConversationalAgent.h"


namespace py::cpp::Windows::ApplicationModel::ConversationalAgent
{
    struct module_state
    {
        PyObject* type_ActivationSignalDetectionConfigurationCreationStatus;
        PyObject* type_ActivationSignalDetectionConfigurationRemovalResult;
        PyObject* type_ActivationSignalDetectionConfigurationSetModelDataResult;
        PyObject* type_ActivationSignalDetectionConfigurationStateChangeResult;
        PyObject* type_ActivationSignalDetectionTrainingDataFormat;
        PyObject* type_ActivationSignalDetectorKind;
        PyObject* type_ActivationSignalDetectorPowerState;
        PyObject* type_ConversationalAgentActivationKind;
        PyObject* type_ConversationalAgentActivationResult;
        PyObject* type_ConversationalAgentSessionUpdateResponse;
        PyObject* type_ConversationalAgentState;
        PyObject* type_ConversationalAgentSystemStateChangeType;
        PyObject* type_ConversationalAgentVoiceActivationPrerequisiteKind;
        PyObject* type_DetectionConfigurationAvailabilityChangeKind;
        PyObject* type_DetectionConfigurationTrainingStatus;
        PyObject* type_SignalDetectorResourceKind;
        PyTypeObject* type_ActivationSignalDetectionConfiguration;
        PyTypeObject* type_ActivationSignalDetectionConfigurationCreationResult;
        PyTypeObject* type_ActivationSignalDetector;
        PyTypeObject* type_ConversationalAgentDetectorManager;
        PyTypeObject* type_ConversationalAgentSession;
        PyTypeObject* type_ConversationalAgentSessionInterruptedEventArgs;
        PyTypeObject* type_ConversationalAgentSignal;
        PyTypeObject* type_ConversationalAgentSignalDetectedEventArgs;
        PyTypeObject* type_ConversationalAgentSystemStateChangedEventArgs;
        PyTypeObject* type_DetectionConfigurationAvailabilityChangedEventArgs;
        PyTypeObject* type_DetectionConfigurationAvailabilityInfo;
    };

    static PyObject* register_ActivationSignalDetectionConfigurationCreationStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ActivationSignalDetectionConfigurationCreationStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ActivationSignalDetectionConfigurationCreationStatus = type;
        Py_INCREF(state->type_ActivationSignalDetectionConfigurationCreationStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_ActivationSignalDetectionConfigurationRemovalResult(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ActivationSignalDetectionConfigurationRemovalResult)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ActivationSignalDetectionConfigurationRemovalResult = type;
        Py_INCREF(state->type_ActivationSignalDetectionConfigurationRemovalResult);


        Py_RETURN_NONE;
    }

    static PyObject* register_ActivationSignalDetectionConfigurationSetModelDataResult(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ActivationSignalDetectionConfigurationSetModelDataResult)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ActivationSignalDetectionConfigurationSetModelDataResult = type;
        Py_INCREF(state->type_ActivationSignalDetectionConfigurationSetModelDataResult);


        Py_RETURN_NONE;
    }

    static PyObject* register_ActivationSignalDetectionConfigurationStateChangeResult(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ActivationSignalDetectionConfigurationStateChangeResult)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ActivationSignalDetectionConfigurationStateChangeResult = type;
        Py_INCREF(state->type_ActivationSignalDetectionConfigurationStateChangeResult);


        Py_RETURN_NONE;
    }

    static PyObject* register_ActivationSignalDetectionTrainingDataFormat(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ActivationSignalDetectionTrainingDataFormat)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ActivationSignalDetectionTrainingDataFormat = type;
        Py_INCREF(state->type_ActivationSignalDetectionTrainingDataFormat);


        Py_RETURN_NONE;
    }

    static PyObject* register_ActivationSignalDetectorKind(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ActivationSignalDetectorKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ActivationSignalDetectorKind = type;
        Py_INCREF(state->type_ActivationSignalDetectorKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_ActivationSignalDetectorPowerState(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ActivationSignalDetectorPowerState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ActivationSignalDetectorPowerState = type;
        Py_INCREF(state->type_ActivationSignalDetectorPowerState);


        Py_RETURN_NONE;
    }

    static PyObject* register_ConversationalAgentActivationKind(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ConversationalAgentActivationKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ConversationalAgentActivationKind = type;
        Py_INCREF(state->type_ConversationalAgentActivationKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_ConversationalAgentActivationResult(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ConversationalAgentActivationResult)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ConversationalAgentActivationResult = type;
        Py_INCREF(state->type_ConversationalAgentActivationResult);


        Py_RETURN_NONE;
    }

    static PyObject* register_ConversationalAgentSessionUpdateResponse(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ConversationalAgentSessionUpdateResponse)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ConversationalAgentSessionUpdateResponse = type;
        Py_INCREF(state->type_ConversationalAgentSessionUpdateResponse);


        Py_RETURN_NONE;
    }

    static PyObject* register_ConversationalAgentState(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ConversationalAgentState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ConversationalAgentState = type;
        Py_INCREF(state->type_ConversationalAgentState);


        Py_RETURN_NONE;
    }

    static PyObject* register_ConversationalAgentSystemStateChangeType(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ConversationalAgentSystemStateChangeType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ConversationalAgentSystemStateChangeType = type;
        Py_INCREF(state->type_ConversationalAgentSystemStateChangeType);


        Py_RETURN_NONE;
    }

    static PyObject* register_ConversationalAgentVoiceActivationPrerequisiteKind(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ConversationalAgentVoiceActivationPrerequisiteKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ConversationalAgentVoiceActivationPrerequisiteKind = type;
        Py_INCREF(state->type_ConversationalAgentVoiceActivationPrerequisiteKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_DetectionConfigurationAvailabilityChangeKind(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DetectionConfigurationAvailabilityChangeKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DetectionConfigurationAvailabilityChangeKind = type;
        Py_INCREF(state->type_DetectionConfigurationAvailabilityChangeKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_DetectionConfigurationTrainingStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DetectionConfigurationTrainingStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DetectionConfigurationTrainingStatus = type;
        Py_INCREF(state->type_DetectionConfigurationTrainingStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_SignalDetectorResourceKind(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SignalDetectorResourceKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SignalDetectorResourceKind = type;
        Py_INCREF(state->type_SignalDetectorResourceKind);


        Py_RETURN_NONE;
    }

    // ----- ActivationSignalDetectionConfiguration class --------------------
    constexpr const char* const type_name_ActivationSignalDetectionConfiguration = "ActivationSignalDetectionConfiguration";

    static PyObject* _new_ActivationSignalDetectionConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ActivationSignalDetectionConfiguration);
        return nullptr;
    }

    static void _dealloc_ActivationSignalDetectionConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivationSignalDetectionConfiguration_ApplyTrainingData(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionTrainingDataFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.ApplyTrainingData(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_ApplyTrainingDataAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionTrainingDataFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.ApplyTrainingDataAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_ClearModelData(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ClearModelData();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_ClearModelDataAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClearModelDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_ClearTrainingData(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ClearTrainingData();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_ClearTrainingDataAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClearTrainingDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_Close(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_GetModelData(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetModelData());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_GetModelDataAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetModelDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_GetModelDataType(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetModelDataType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_GetModelDataTypeAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetModelDataTypeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetEnabled(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.SetEnabled(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetEnabledAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetEnabledAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetEnabledWithResult(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetEnabledWithResult(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetEnabledWithResultAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetEnabledWithResultAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetModelData(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                self->obj.SetModelData(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetModelDataAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.SetModelDataAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetModelDataWithResult(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.SetModelDataWithResult(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetModelDataWithResultAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.SetModelDataWithResultAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_AvailabilityInfo(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AvailabilityInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_DisplayName(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_IsActive(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_ModelId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ModelId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_SignalId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignalId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_TrainingDataFormat(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrainingDataFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_TrainingStepsCompleted(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrainingStepsCompleted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_TrainingStepsRemaining(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrainingStepsRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_TrainingStepCompletionMaxAllowedTime(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrainingStepCompletionMaxAllowedTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_add_AvailabilityChanged(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration, winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs>>(arg);

            return py::convert(self->obj.AvailabilityChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_remove_AvailabilityChanged(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AvailabilityChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ActivationSignalDetectionConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ActivationSignalDetectionConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ActivationSignalDetectionConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivationSignalDetectionConfiguration[] = {
        { "apply_training_data", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_ApplyTrainingData), METH_VARARGS, nullptr },
        { "apply_training_data_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_ApplyTrainingDataAsync), METH_VARARGS, nullptr },
        { "clear_model_data", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_ClearModelData), METH_VARARGS, nullptr },
        { "clear_model_data_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_ClearModelDataAsync), METH_VARARGS, nullptr },
        { "clear_training_data", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_ClearTrainingData), METH_VARARGS, nullptr },
        { "clear_training_data_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_ClearTrainingDataAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_Close), METH_VARARGS, nullptr },
        { "get_model_data", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_GetModelData), METH_VARARGS, nullptr },
        { "get_model_data_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_GetModelDataAsync), METH_VARARGS, nullptr },
        { "get_model_data_type", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_GetModelDataType), METH_VARARGS, nullptr },
        { "get_model_data_type_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_GetModelDataTypeAsync), METH_VARARGS, nullptr },
        { "set_enabled", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetEnabled), METH_VARARGS, nullptr },
        { "set_enabled_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetEnabledAsync), METH_VARARGS, nullptr },
        { "set_enabled_with_result", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetEnabledWithResult), METH_VARARGS, nullptr },
        { "set_enabled_with_result_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetEnabledWithResultAsync), METH_VARARGS, nullptr },
        { "set_model_data", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetModelData), METH_VARARGS, nullptr },
        { "set_model_data_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetModelDataAsync), METH_VARARGS, nullptr },
        { "set_model_data_with_result", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetModelDataWithResult), METH_VARARGS, nullptr },
        { "set_model_data_with_result_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetModelDataWithResultAsync), METH_VARARGS, nullptr },
        { "add_availability_changed", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_add_AvailabilityChanged), METH_O, nullptr },
        { "remove_availability_changed", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_remove_AvailabilityChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivationSignalDetectionConfiguration), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ActivationSignalDetectionConfiguration), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ActivationSignalDetectionConfiguration), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivationSignalDetectionConfiguration[] = {
        { "availability_info", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_AvailabilityInfo), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_DisplayName), nullptr, nullptr, nullptr },
        { "is_active", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_IsActive), nullptr, nullptr, nullptr },
        { "model_id", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_ModelId), nullptr, nullptr, nullptr },
        { "signal_id", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_SignalId), nullptr, nullptr, nullptr },
        { "training_data_format", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_TrainingDataFormat), nullptr, nullptr, nullptr },
        { "training_steps_completed", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_TrainingStepsCompleted), nullptr, nullptr, nullptr },
        { "training_steps_remaining", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_TrainingStepsRemaining), nullptr, nullptr, nullptr },
        { "training_step_completion_max_allowed_time", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_TrainingStepCompletionMaxAllowedTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ActivationSignalDetectionConfiguration[] = 
    {
        { Py_tp_new, _new_ActivationSignalDetectionConfiguration },
        { Py_tp_dealloc, _dealloc_ActivationSignalDetectionConfiguration },
        { Py_tp_methods, _methods_ActivationSignalDetectionConfiguration },
        { Py_tp_getset, _getset_ActivationSignalDetectionConfiguration },
        { },
    };

    static PyType_Spec type_spec_ActivationSignalDetectionConfiguration =
    {
        "_winsdk_Windows_ApplicationModel_ConversationalAgent.ActivationSignalDetectionConfiguration",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivationSignalDetectionConfiguration
    };

    // ----- ActivationSignalDetectionConfigurationCreationResult class --------------------
    constexpr const char* const type_name_ActivationSignalDetectionConfigurationCreationResult = "ActivationSignalDetectionConfigurationCreationResult";

    static PyObject* _new_ActivationSignalDetectionConfigurationCreationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ActivationSignalDetectionConfigurationCreationResult);
        return nullptr;
    }

    static void _dealloc_ActivationSignalDetectionConfigurationCreationResult(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivationSignalDetectionConfigurationCreationResult_get_Configuration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfigurationCreationResult_get_Status(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ActivationSignalDetectionConfigurationCreationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivationSignalDetectionConfigurationCreationResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivationSignalDetectionConfigurationCreationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivationSignalDetectionConfigurationCreationResult[] = {
        { "configuration", reinterpret_cast<getter>(ActivationSignalDetectionConfigurationCreationResult_get_Configuration), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(ActivationSignalDetectionConfigurationCreationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ActivationSignalDetectionConfigurationCreationResult[] = 
    {
        { Py_tp_new, _new_ActivationSignalDetectionConfigurationCreationResult },
        { Py_tp_dealloc, _dealloc_ActivationSignalDetectionConfigurationCreationResult },
        { Py_tp_methods, _methods_ActivationSignalDetectionConfigurationCreationResult },
        { Py_tp_getset, _getset_ActivationSignalDetectionConfigurationCreationResult },
        { },
    };

    static PyType_Spec type_spec_ActivationSignalDetectionConfigurationCreationResult =
    {
        "_winsdk_Windows_ApplicationModel_ConversationalAgent.ActivationSignalDetectionConfigurationCreationResult",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivationSignalDetectionConfigurationCreationResult
    };

    // ----- ActivationSignalDetector class --------------------
    constexpr const char* const type_name_ActivationSignalDetector = "ActivationSignalDetector";

    static PyObject* _new_ActivationSignalDetector(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ActivationSignalDetector);
        return nullptr;
    }

    static void _dealloc_ActivationSignalDetector(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ActivationSignalDetector_CreateConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                self->obj.CreateConfiguration(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_CreateConfigurationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.CreateConfigurationAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_CreateConfigurationWithResult(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.CreateConfigurationWithResult(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_CreateConfigurationWithResultAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.CreateConfigurationWithResultAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetAvailableModelIdsForSignalId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAvailableModelIdsForSignalId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetAvailableModelIdsForSignalIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAvailableModelIdsForSignalIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetConfiguration(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetConfigurationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetConfigurationAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetConfigurations(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConfigurations());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetConfigurationsAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConfigurationsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetSupportedModelIdsForSignalId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetSupportedModelIdsForSignalId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetSupportedModelIdsForSignalIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetSupportedModelIdsForSignalIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_RemoveConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.RemoveConfiguration(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_RemoveConfigurationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.RemoveConfigurationAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_RemoveConfigurationWithResult(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.RemoveConfigurationWithResult(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_RemoveConfigurationWithResultAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.RemoveConfigurationWithResultAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_CanCreateConfigurations(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanCreateConfigurations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_Kind(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_ProviderId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_SupportedModelDataTypes(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedModelDataTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_SupportedPowerStates(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedPowerStates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_SupportedTrainingDataFormats(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedTrainingDataFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_DetectorId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DetectorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ActivationSignalDetector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivationSignalDetector[] = {
        { "create_configuration", reinterpret_cast<PyCFunction>(ActivationSignalDetector_CreateConfiguration), METH_VARARGS, nullptr },
        { "create_configuration_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_CreateConfigurationAsync), METH_VARARGS, nullptr },
        { "create_configuration_with_result", reinterpret_cast<PyCFunction>(ActivationSignalDetector_CreateConfigurationWithResult), METH_VARARGS, nullptr },
        { "create_configuration_with_result_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_CreateConfigurationWithResultAsync), METH_VARARGS, nullptr },
        { "get_available_model_ids_for_signal_id", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetAvailableModelIdsForSignalId), METH_VARARGS, nullptr },
        { "get_available_model_ids_for_signal_id_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetAvailableModelIdsForSignalIdAsync), METH_VARARGS, nullptr },
        { "get_configuration", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetConfiguration), METH_VARARGS, nullptr },
        { "get_configuration_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetConfigurationAsync), METH_VARARGS, nullptr },
        { "get_configurations", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetConfigurations), METH_VARARGS, nullptr },
        { "get_configurations_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetConfigurationsAsync), METH_VARARGS, nullptr },
        { "get_supported_model_ids_for_signal_id", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetSupportedModelIdsForSignalId), METH_VARARGS, nullptr },
        { "get_supported_model_ids_for_signal_id_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetSupportedModelIdsForSignalIdAsync), METH_VARARGS, nullptr },
        { "remove_configuration", reinterpret_cast<PyCFunction>(ActivationSignalDetector_RemoveConfiguration), METH_VARARGS, nullptr },
        { "remove_configuration_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_RemoveConfigurationAsync), METH_VARARGS, nullptr },
        { "remove_configuration_with_result", reinterpret_cast<PyCFunction>(ActivationSignalDetector_RemoveConfigurationWithResult), METH_VARARGS, nullptr },
        { "remove_configuration_with_result_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_RemoveConfigurationWithResultAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivationSignalDetector), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivationSignalDetector[] = {
        { "can_create_configurations", reinterpret_cast<getter>(ActivationSignalDetector_get_CanCreateConfigurations), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ActivationSignalDetector_get_Kind), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(ActivationSignalDetector_get_ProviderId), nullptr, nullptr, nullptr },
        { "supported_model_data_types", reinterpret_cast<getter>(ActivationSignalDetector_get_SupportedModelDataTypes), nullptr, nullptr, nullptr },
        { "supported_power_states", reinterpret_cast<getter>(ActivationSignalDetector_get_SupportedPowerStates), nullptr, nullptr, nullptr },
        { "supported_training_data_formats", reinterpret_cast<getter>(ActivationSignalDetector_get_SupportedTrainingDataFormats), nullptr, nullptr, nullptr },
        { "detector_id", reinterpret_cast<getter>(ActivationSignalDetector_get_DetectorId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ActivationSignalDetector[] = 
    {
        { Py_tp_new, _new_ActivationSignalDetector },
        { Py_tp_dealloc, _dealloc_ActivationSignalDetector },
        { Py_tp_methods, _methods_ActivationSignalDetector },
        { Py_tp_getset, _getset_ActivationSignalDetector },
        { },
    };

    static PyType_Spec type_spec_ActivationSignalDetector =
    {
        "_winsdk_Windows_ApplicationModel_ConversationalAgent.ActivationSignalDetector",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivationSignalDetector
    };

    // ----- ConversationalAgentDetectorManager class --------------------
    constexpr const char* const type_name_ConversationalAgentDetectorManager = "ConversationalAgentDetectorManager";

    static PyObject* _new_ConversationalAgentDetectorManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ConversationalAgentDetectorManager);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentDetectorManager(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ConversationalAgentDetectorManager_GetActivationSignalDetectorFromId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetActivationSignalDetectorFromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_GetActivationSignalDetectorFromIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetActivationSignalDetectorFromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_GetActivationSignalDetectors(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectorKind>(args, 0);

                return py::convert(self->obj.GetActivationSignalDetectors(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_GetActivationSignalDetectorsAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectorKind>(args, 0);

                return py::convert(self->obj.GetActivationSignalDetectorsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_GetAllActivationSignalDetectors(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAllActivationSignalDetectors());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_GetAllActivationSignalDetectorsAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAllActivationSignalDetectorsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_get_Default(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager::Default());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConversationalAgentDetectorManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentDetectorManager[] = {
        { "get_activation_signal_detector_from_id", reinterpret_cast<PyCFunction>(ConversationalAgentDetectorManager_GetActivationSignalDetectorFromId), METH_VARARGS, nullptr },
        { "get_activation_signal_detector_from_id_async", reinterpret_cast<PyCFunction>(ConversationalAgentDetectorManager_GetActivationSignalDetectorFromIdAsync), METH_VARARGS, nullptr },
        { "get_activation_signal_detectors", reinterpret_cast<PyCFunction>(ConversationalAgentDetectorManager_GetActivationSignalDetectors), METH_VARARGS, nullptr },
        { "get_activation_signal_detectors_async", reinterpret_cast<PyCFunction>(ConversationalAgentDetectorManager_GetActivationSignalDetectorsAsync), METH_VARARGS, nullptr },
        { "get_all_activation_signal_detectors", reinterpret_cast<PyCFunction>(ConversationalAgentDetectorManager_GetAllActivationSignalDetectors), METH_VARARGS, nullptr },
        { "get_all_activation_signal_detectors_async", reinterpret_cast<PyCFunction>(ConversationalAgentDetectorManager_GetAllActivationSignalDetectorsAsync), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(ConversationalAgentDetectorManager_get_Default), METH_NOARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConversationalAgentDetectorManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConversationalAgentDetectorManager[] = {
        { }
    };

    static PyType_Slot _type_slots_ConversationalAgentDetectorManager[] = 
    {
        { Py_tp_new, _new_ConversationalAgentDetectorManager },
        { Py_tp_dealloc, _dealloc_ConversationalAgentDetectorManager },
        { Py_tp_methods, _methods_ConversationalAgentDetectorManager },
        { Py_tp_getset, _getset_ConversationalAgentDetectorManager },
        { },
    };

    static PyType_Spec type_spec_ConversationalAgentDetectorManager =
    {
        "_winsdk_Windows_ApplicationModel_ConversationalAgent.ConversationalAgentDetectorManager",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentDetectorManager
    };

    // ----- ConversationalAgentSession class --------------------
    constexpr const char* const type_name_ConversationalAgentSession = "ConversationalAgentSession";

    static PyObject* _new_ConversationalAgentSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ConversationalAgentSession);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentSession(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ConversationalAgentSession_Close(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_CreateAudioDeviceInputNode(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                return py::convert(self->obj.CreateAudioDeviceInputNode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_CreateAudioDeviceInputNodeAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                return py::convert(self->obj.CreateAudioDeviceInputNodeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioCaptureDeviceId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAudioCaptureDeviceId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioCaptureDeviceIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAudioCaptureDeviceIdAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioClient(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAudioClient());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioClientAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAudioClientAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioRenderDeviceId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAudioRenderDeviceId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioRenderDeviceIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAudioRenderDeviceIdAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetCurrentSessionAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession::GetCurrentSessionAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetCurrentSessionSync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession::GetCurrentSessionSync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetMissingPrerequisites(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetMissingPrerequisites());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetMissingPrerequisitesAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetMissingPrerequisitesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetSignalModelId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSignalModelId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetSignalModelIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSignalModelIdAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetSupportedSignalModelIds(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSupportedSignalModelIds());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetSupportedSignalModelIdsAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSupportedSignalModelIdsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestActivation(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentActivationKind>(args, 0);

                return py::convert(self->obj.RequestActivation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestActivationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentActivationKind>(args, 0);

                return py::convert(self->obj.RequestActivationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestAgentStateChange(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentState>(args, 0);

                return py::convert(self->obj.RequestAgentStateChange(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestAgentStateChangeAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentState>(args, 0);

                return py::convert(self->obj.RequestAgentStateChangeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestForegroundActivation(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestForegroundActivation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestForegroundActivationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestForegroundActivationAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestInterruptible(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.RequestInterruptible(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestInterruptibleAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.RequestInterruptibleAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_SetSignalModelId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.SetSignalModelId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_SetSignalModelIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.SetSignalModelIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_SetSupportLockScreenActivation(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.SetSupportLockScreenActivation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_SetSupportLockScreenActivationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetSupportLockScreenActivationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_AgentState(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AgentState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsIndicatorLightAvailable(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsIndicatorLightAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsInterrupted(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInterrupted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsInterruptible(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInterruptible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsScreenAvailable(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsScreenAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsUserAuthenticated(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUserAuthenticated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsVoiceActivationAvailable(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVoiceActivationAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_Signal(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Signal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_add_SessionInterrupted(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession, winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs>>(arg);

            return py::convert(self->obj.SessionInterrupted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_remove_SessionInterrupted(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SessionInterrupted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_add_SignalDetected(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession, winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs>>(arg);

            return py::convert(self->obj.SignalDetected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_remove_SignalDetected(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SignalDetected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_add_SystemStateChanged(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession, winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs>>(arg);

            return py::convert(self->obj.SystemStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_remove_SystemStateChanged(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SystemStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConversationalAgentSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ConversationalAgentSession(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ConversationalAgentSession(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentSession[] = {
        { "close", reinterpret_cast<PyCFunction>(ConversationalAgentSession_Close), METH_VARARGS, nullptr },
        { "create_audio_device_input_node", reinterpret_cast<PyCFunction>(ConversationalAgentSession_CreateAudioDeviceInputNode), METH_VARARGS, nullptr },
        { "create_audio_device_input_node_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_CreateAudioDeviceInputNodeAsync), METH_VARARGS, nullptr },
        { "get_audio_capture_device_id", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetAudioCaptureDeviceId), METH_VARARGS, nullptr },
        { "get_audio_capture_device_id_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetAudioCaptureDeviceIdAsync), METH_VARARGS, nullptr },
        { "get_audio_client", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetAudioClient), METH_VARARGS, nullptr },
        { "get_audio_client_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetAudioClientAsync), METH_VARARGS, nullptr },
        { "get_audio_render_device_id", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetAudioRenderDeviceId), METH_VARARGS, nullptr },
        { "get_audio_render_device_id_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetAudioRenderDeviceIdAsync), METH_VARARGS, nullptr },
        { "get_current_session_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetCurrentSessionAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_session_sync", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetCurrentSessionSync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_missing_prerequisites", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetMissingPrerequisites), METH_VARARGS, nullptr },
        { "get_missing_prerequisites_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetMissingPrerequisitesAsync), METH_VARARGS, nullptr },
        { "get_signal_model_id", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetSignalModelId), METH_VARARGS, nullptr },
        { "get_signal_model_id_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetSignalModelIdAsync), METH_VARARGS, nullptr },
        { "get_supported_signal_model_ids", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetSupportedSignalModelIds), METH_VARARGS, nullptr },
        { "get_supported_signal_model_ids_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetSupportedSignalModelIdsAsync), METH_VARARGS, nullptr },
        { "request_activation", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestActivation), METH_VARARGS, nullptr },
        { "request_activation_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestActivationAsync), METH_VARARGS, nullptr },
        { "request_agent_state_change", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestAgentStateChange), METH_VARARGS, nullptr },
        { "request_agent_state_change_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestAgentStateChangeAsync), METH_VARARGS, nullptr },
        { "request_foreground_activation", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestForegroundActivation), METH_VARARGS, nullptr },
        { "request_foreground_activation_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestForegroundActivationAsync), METH_VARARGS, nullptr },
        { "request_interruptible", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestInterruptible), METH_VARARGS, nullptr },
        { "request_interruptible_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestInterruptibleAsync), METH_VARARGS, nullptr },
        { "set_signal_model_id", reinterpret_cast<PyCFunction>(ConversationalAgentSession_SetSignalModelId), METH_VARARGS, nullptr },
        { "set_signal_model_id_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_SetSignalModelIdAsync), METH_VARARGS, nullptr },
        { "set_support_lock_screen_activation", reinterpret_cast<PyCFunction>(ConversationalAgentSession_SetSupportLockScreenActivation), METH_VARARGS, nullptr },
        { "set_support_lock_screen_activation_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_SetSupportLockScreenActivationAsync), METH_VARARGS, nullptr },
        { "add_session_interrupted", reinterpret_cast<PyCFunction>(ConversationalAgentSession_add_SessionInterrupted), METH_O, nullptr },
        { "remove_session_interrupted", reinterpret_cast<PyCFunction>(ConversationalAgentSession_remove_SessionInterrupted), METH_O, nullptr },
        { "add_signal_detected", reinterpret_cast<PyCFunction>(ConversationalAgentSession_add_SignalDetected), METH_O, nullptr },
        { "remove_signal_detected", reinterpret_cast<PyCFunction>(ConversationalAgentSession_remove_SignalDetected), METH_O, nullptr },
        { "add_system_state_changed", reinterpret_cast<PyCFunction>(ConversationalAgentSession_add_SystemStateChanged), METH_O, nullptr },
        { "remove_system_state_changed", reinterpret_cast<PyCFunction>(ConversationalAgentSession_remove_SystemStateChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConversationalAgentSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ConversationalAgentSession), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ConversationalAgentSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConversationalAgentSession[] = {
        { "agent_state", reinterpret_cast<getter>(ConversationalAgentSession_get_AgentState), nullptr, nullptr, nullptr },
        { "is_indicator_light_available", reinterpret_cast<getter>(ConversationalAgentSession_get_IsIndicatorLightAvailable), nullptr, nullptr, nullptr },
        { "is_interrupted", reinterpret_cast<getter>(ConversationalAgentSession_get_IsInterrupted), nullptr, nullptr, nullptr },
        { "is_interruptible", reinterpret_cast<getter>(ConversationalAgentSession_get_IsInterruptible), nullptr, nullptr, nullptr },
        { "is_screen_available", reinterpret_cast<getter>(ConversationalAgentSession_get_IsScreenAvailable), nullptr, nullptr, nullptr },
        { "is_user_authenticated", reinterpret_cast<getter>(ConversationalAgentSession_get_IsUserAuthenticated), nullptr, nullptr, nullptr },
        { "is_voice_activation_available", reinterpret_cast<getter>(ConversationalAgentSession_get_IsVoiceActivationAvailable), nullptr, nullptr, nullptr },
        { "signal", reinterpret_cast<getter>(ConversationalAgentSession_get_Signal), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConversationalAgentSession[] = 
    {
        { Py_tp_new, _new_ConversationalAgentSession },
        { Py_tp_dealloc, _dealloc_ConversationalAgentSession },
        { Py_tp_methods, _methods_ConversationalAgentSession },
        { Py_tp_getset, _getset_ConversationalAgentSession },
        { },
    };

    static PyType_Spec type_spec_ConversationalAgentSession =
    {
        "_winsdk_Windows_ApplicationModel_ConversationalAgent.ConversationalAgentSession",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentSession
    };

    // ----- ConversationalAgentSessionInterruptedEventArgs class --------------------
    constexpr const char* const type_name_ConversationalAgentSessionInterruptedEventArgs = "ConversationalAgentSessionInterruptedEventArgs";

    static PyObject* _new_ConversationalAgentSessionInterruptedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ConversationalAgentSessionInterruptedEventArgs);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentSessionInterruptedEventArgs(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _from_ConversationalAgentSessionInterruptedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentSessionInterruptedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ConversationalAgentSessionInterruptedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConversationalAgentSessionInterruptedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ConversationalAgentSessionInterruptedEventArgs[] = 
    {
        { Py_tp_new, _new_ConversationalAgentSessionInterruptedEventArgs },
        { Py_tp_dealloc, _dealloc_ConversationalAgentSessionInterruptedEventArgs },
        { Py_tp_methods, _methods_ConversationalAgentSessionInterruptedEventArgs },
        { Py_tp_getset, _getset_ConversationalAgentSessionInterruptedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ConversationalAgentSessionInterruptedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_ConversationalAgent.ConversationalAgentSessionInterruptedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentSessionInterruptedEventArgs
    };

    // ----- ConversationalAgentSignal class --------------------
    constexpr const char* const type_name_ConversationalAgentSignal = "ConversationalAgentSignal";

    static PyObject* _new_ConversationalAgentSignal(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ConversationalAgentSignal);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentSignal(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ConversationalAgentSignal_get_SignalStart(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignalStart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_SignalStart(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.SignalStart(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_SignalName(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignalName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_SignalName(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SignalName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_SignalId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignalId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_SignalId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SignalId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_SignalEnd(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignalEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_SignalEnd(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.SignalEnd(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_SignalContext(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignalContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_SignalContext(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.SignalContext(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_IsSignalVerificationRequired(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSignalVerificationRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_IsSignalVerificationRequired(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSignalVerificationRequired(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_DetectorId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DetectorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSignal_get_DetectorKind(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DetectorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConversationalAgentSignal(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentSignal[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ConversationalAgentSignal), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConversationalAgentSignal[] = {
        { "signal_start", reinterpret_cast<getter>(ConversationalAgentSignal_get_SignalStart), reinterpret_cast<setter>(ConversationalAgentSignal_put_SignalStart), nullptr, nullptr },
        { "signal_name", reinterpret_cast<getter>(ConversationalAgentSignal_get_SignalName), reinterpret_cast<setter>(ConversationalAgentSignal_put_SignalName), nullptr, nullptr },
        { "signal_id", reinterpret_cast<getter>(ConversationalAgentSignal_get_SignalId), reinterpret_cast<setter>(ConversationalAgentSignal_put_SignalId), nullptr, nullptr },
        { "signal_end", reinterpret_cast<getter>(ConversationalAgentSignal_get_SignalEnd), reinterpret_cast<setter>(ConversationalAgentSignal_put_SignalEnd), nullptr, nullptr },
        { "signal_context", reinterpret_cast<getter>(ConversationalAgentSignal_get_SignalContext), reinterpret_cast<setter>(ConversationalAgentSignal_put_SignalContext), nullptr, nullptr },
        { "is_signal_verification_required", reinterpret_cast<getter>(ConversationalAgentSignal_get_IsSignalVerificationRequired), reinterpret_cast<setter>(ConversationalAgentSignal_put_IsSignalVerificationRequired), nullptr, nullptr },
        { "detector_id", reinterpret_cast<getter>(ConversationalAgentSignal_get_DetectorId), nullptr, nullptr, nullptr },
        { "detector_kind", reinterpret_cast<getter>(ConversationalAgentSignal_get_DetectorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConversationalAgentSignal[] = 
    {
        { Py_tp_new, _new_ConversationalAgentSignal },
        { Py_tp_dealloc, _dealloc_ConversationalAgentSignal },
        { Py_tp_methods, _methods_ConversationalAgentSignal },
        { Py_tp_getset, _getset_ConversationalAgentSignal },
        { },
    };

    static PyType_Spec type_spec_ConversationalAgentSignal =
    {
        "_winsdk_Windows_ApplicationModel_ConversationalAgent.ConversationalAgentSignal",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentSignal
    };

    // ----- ConversationalAgentSignalDetectedEventArgs class --------------------
    constexpr const char* const type_name_ConversationalAgentSignalDetectedEventArgs = "ConversationalAgentSignalDetectedEventArgs";

    static PyObject* _new_ConversationalAgentSignalDetectedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ConversationalAgentSignalDetectedEventArgs);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentSignalDetectedEventArgs(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _from_ConversationalAgentSignalDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentSignalDetectedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ConversationalAgentSignalDetectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConversationalAgentSignalDetectedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ConversationalAgentSignalDetectedEventArgs[] = 
    {
        { Py_tp_new, _new_ConversationalAgentSignalDetectedEventArgs },
        { Py_tp_dealloc, _dealloc_ConversationalAgentSignalDetectedEventArgs },
        { Py_tp_methods, _methods_ConversationalAgentSignalDetectedEventArgs },
        { Py_tp_getset, _getset_ConversationalAgentSignalDetectedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ConversationalAgentSignalDetectedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_ConversationalAgent.ConversationalAgentSignalDetectedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentSignalDetectedEventArgs
    };

    // ----- ConversationalAgentSystemStateChangedEventArgs class --------------------
    constexpr const char* const type_name_ConversationalAgentSystemStateChangedEventArgs = "ConversationalAgentSystemStateChangedEventArgs";

    static PyObject* _new_ConversationalAgentSystemStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ConversationalAgentSystemStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentSystemStateChangedEventArgs(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ConversationalAgentSystemStateChangedEventArgs_get_SystemStateChangeType(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemStateChangeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConversationalAgentSystemStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentSystemStateChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ConversationalAgentSystemStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConversationalAgentSystemStateChangedEventArgs[] = {
        { "system_state_change_type", reinterpret_cast<getter>(ConversationalAgentSystemStateChangedEventArgs_get_SystemStateChangeType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConversationalAgentSystemStateChangedEventArgs[] = 
    {
        { Py_tp_new, _new_ConversationalAgentSystemStateChangedEventArgs },
        { Py_tp_dealloc, _dealloc_ConversationalAgentSystemStateChangedEventArgs },
        { Py_tp_methods, _methods_ConversationalAgentSystemStateChangedEventArgs },
        { Py_tp_getset, _getset_ConversationalAgentSystemStateChangedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ConversationalAgentSystemStateChangedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_ConversationalAgent.ConversationalAgentSystemStateChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentSystemStateChangedEventArgs
    };

    // ----- DetectionConfigurationAvailabilityChangedEventArgs class --------------------
    constexpr const char* const type_name_DetectionConfigurationAvailabilityChangedEventArgs = "DetectionConfigurationAvailabilityChangedEventArgs";

    static PyObject* _new_DetectionConfigurationAvailabilityChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DetectionConfigurationAvailabilityChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_DetectionConfigurationAvailabilityChangedEventArgs(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DetectionConfigurationAvailabilityChangedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DetectionConfigurationAvailabilityChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DetectionConfigurationAvailabilityChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DetectionConfigurationAvailabilityChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DetectionConfigurationAvailabilityChangedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(DetectionConfigurationAvailabilityChangedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DetectionConfigurationAvailabilityChangedEventArgs[] = 
    {
        { Py_tp_new, _new_DetectionConfigurationAvailabilityChangedEventArgs },
        { Py_tp_dealloc, _dealloc_DetectionConfigurationAvailabilityChangedEventArgs },
        { Py_tp_methods, _methods_DetectionConfigurationAvailabilityChangedEventArgs },
        { Py_tp_getset, _getset_DetectionConfigurationAvailabilityChangedEventArgs },
        { },
    };

    static PyType_Spec type_spec_DetectionConfigurationAvailabilityChangedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_ConversationalAgent.DetectionConfigurationAvailabilityChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DetectionConfigurationAvailabilityChangedEventArgs
    };

    // ----- DetectionConfigurationAvailabilityInfo class --------------------
    constexpr const char* const type_name_DetectionConfigurationAvailabilityInfo = "DetectionConfigurationAvailabilityInfo";

    static PyObject* _new_DetectionConfigurationAvailabilityInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DetectionConfigurationAvailabilityInfo);
        return nullptr;
    }

    static void _dealloc_DetectionConfigurationAvailabilityInfo(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DetectionConfigurationAvailabilityInfo_get_HasLockScreenPermission(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasLockScreenPermission());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DetectionConfigurationAvailabilityInfo_get_HasPermission(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasPermission());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DetectionConfigurationAvailabilityInfo_get_HasSystemResourceAccess(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasSystemResourceAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DetectionConfigurationAvailabilityInfo_get_IsEnabled(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DetectionConfigurationAvailabilityInfo_get_UnavailableSystemResources(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UnavailableSystemResources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DetectionConfigurationAvailabilityInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DetectionConfigurationAvailabilityInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DetectionConfigurationAvailabilityInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DetectionConfigurationAvailabilityInfo[] = {
        { "has_lock_screen_permission", reinterpret_cast<getter>(DetectionConfigurationAvailabilityInfo_get_HasLockScreenPermission), nullptr, nullptr, nullptr },
        { "has_permission", reinterpret_cast<getter>(DetectionConfigurationAvailabilityInfo_get_HasPermission), nullptr, nullptr, nullptr },
        { "has_system_resource_access", reinterpret_cast<getter>(DetectionConfigurationAvailabilityInfo_get_HasSystemResourceAccess), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(DetectionConfigurationAvailabilityInfo_get_IsEnabled), nullptr, nullptr, nullptr },
        { "unavailable_system_resources", reinterpret_cast<getter>(DetectionConfigurationAvailabilityInfo_get_UnavailableSystemResources), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DetectionConfigurationAvailabilityInfo[] = 
    {
        { Py_tp_new, _new_DetectionConfigurationAvailabilityInfo },
        { Py_tp_dealloc, _dealloc_DetectionConfigurationAvailabilityInfo },
        { Py_tp_methods, _methods_DetectionConfigurationAvailabilityInfo },
        { Py_tp_getset, _getset_DetectionConfigurationAvailabilityInfo },
        { },
    };

    static PyType_Spec type_spec_DetectionConfigurationAvailabilityInfo =
    {
        "_winsdk_Windows_ApplicationModel_ConversationalAgent.DetectionConfigurationAvailabilityInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DetectionConfigurationAvailabilityInfo
    };

    // ----- Windows.ApplicationModel.ConversationalAgent Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::ApplicationModel::ConversationalAgent");

    static PyMethodDef module_methods[] = {
        {"_register_ActivationSignalDetectionConfigurationCreationStatus", register_ActivationSignalDetectionConfigurationCreationStatus, METH_O, "registers type"},
        {"_register_ActivationSignalDetectionConfigurationRemovalResult", register_ActivationSignalDetectionConfigurationRemovalResult, METH_O, "registers type"},
        {"_register_ActivationSignalDetectionConfigurationSetModelDataResult", register_ActivationSignalDetectionConfigurationSetModelDataResult, METH_O, "registers type"},
        {"_register_ActivationSignalDetectionConfigurationStateChangeResult", register_ActivationSignalDetectionConfigurationStateChangeResult, METH_O, "registers type"},
        {"_register_ActivationSignalDetectionTrainingDataFormat", register_ActivationSignalDetectionTrainingDataFormat, METH_O, "registers type"},
        {"_register_ActivationSignalDetectorKind", register_ActivationSignalDetectorKind, METH_O, "registers type"},
        {"_register_ActivationSignalDetectorPowerState", register_ActivationSignalDetectorPowerState, METH_O, "registers type"},
        {"_register_ConversationalAgentActivationKind", register_ConversationalAgentActivationKind, METH_O, "registers type"},
        {"_register_ConversationalAgentActivationResult", register_ConversationalAgentActivationResult, METH_O, "registers type"},
        {"_register_ConversationalAgentSessionUpdateResponse", register_ConversationalAgentSessionUpdateResponse, METH_O, "registers type"},
        {"_register_ConversationalAgentState", register_ConversationalAgentState, METH_O, "registers type"},
        {"_register_ConversationalAgentSystemStateChangeType", register_ConversationalAgentSystemStateChangeType, METH_O, "registers type"},
        {"_register_ConversationalAgentVoiceActivationPrerequisiteKind", register_ConversationalAgentVoiceActivationPrerequisiteKind, METH_O, "registers type"},
        {"_register_DetectionConfigurationAvailabilityChangeKind", register_DetectionConfigurationAvailabilityChangeKind, METH_O, "registers type"},
        {"_register_DetectionConfigurationTrainingStatus", register_DetectionConfigurationTrainingStatus, METH_O, "registers type"},
        {"_register_SignalDetectorResourceKind", register_SignalDetectorResourceKind, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_ActivationSignalDetectionConfigurationCreationStatus);
        Py_VISIT(state->type_ActivationSignalDetectionConfigurationRemovalResult);
        Py_VISIT(state->type_ActivationSignalDetectionConfigurationSetModelDataResult);
        Py_VISIT(state->type_ActivationSignalDetectionConfigurationStateChangeResult);
        Py_VISIT(state->type_ActivationSignalDetectionTrainingDataFormat);
        Py_VISIT(state->type_ActivationSignalDetectorKind);
        Py_VISIT(state->type_ActivationSignalDetectorPowerState);
        Py_VISIT(state->type_ConversationalAgentActivationKind);
        Py_VISIT(state->type_ConversationalAgentActivationResult);
        Py_VISIT(state->type_ConversationalAgentSessionUpdateResponse);
        Py_VISIT(state->type_ConversationalAgentState);
        Py_VISIT(state->type_ConversationalAgentSystemStateChangeType);
        Py_VISIT(state->type_ConversationalAgentVoiceActivationPrerequisiteKind);
        Py_VISIT(state->type_DetectionConfigurationAvailabilityChangeKind);
        Py_VISIT(state->type_DetectionConfigurationTrainingStatus);
        Py_VISIT(state->type_SignalDetectorResourceKind);
        Py_VISIT(state->type_ActivationSignalDetectionConfiguration);
        Py_VISIT(state->type_ActivationSignalDetectionConfigurationCreationResult);
        Py_VISIT(state->type_ActivationSignalDetector);
        Py_VISIT(state->type_ConversationalAgentDetectorManager);
        Py_VISIT(state->type_ConversationalAgentSession);
        Py_VISIT(state->type_ConversationalAgentSessionInterruptedEventArgs);
        Py_VISIT(state->type_ConversationalAgentSignal);
        Py_VISIT(state->type_ConversationalAgentSignalDetectedEventArgs);
        Py_VISIT(state->type_ConversationalAgentSystemStateChangedEventArgs);
        Py_VISIT(state->type_DetectionConfigurationAvailabilityChangedEventArgs);
        Py_VISIT(state->type_DetectionConfigurationAvailabilityInfo);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_ActivationSignalDetectionConfigurationCreationStatus);
        Py_CLEAR(state->type_ActivationSignalDetectionConfigurationRemovalResult);
        Py_CLEAR(state->type_ActivationSignalDetectionConfigurationSetModelDataResult);
        Py_CLEAR(state->type_ActivationSignalDetectionConfigurationStateChangeResult);
        Py_CLEAR(state->type_ActivationSignalDetectionTrainingDataFormat);
        Py_CLEAR(state->type_ActivationSignalDetectorKind);
        Py_CLEAR(state->type_ActivationSignalDetectorPowerState);
        Py_CLEAR(state->type_ConversationalAgentActivationKind);
        Py_CLEAR(state->type_ConversationalAgentActivationResult);
        Py_CLEAR(state->type_ConversationalAgentSessionUpdateResponse);
        Py_CLEAR(state->type_ConversationalAgentState);
        Py_CLEAR(state->type_ConversationalAgentSystemStateChangeType);
        Py_CLEAR(state->type_ConversationalAgentVoiceActivationPrerequisiteKind);
        Py_CLEAR(state->type_DetectionConfigurationAvailabilityChangeKind);
        Py_CLEAR(state->type_DetectionConfigurationTrainingStatus);
        Py_CLEAR(state->type_SignalDetectorResourceKind);
        Py_CLEAR(state->type_ActivationSignalDetectionConfiguration);
        Py_CLEAR(state->type_ActivationSignalDetectionConfigurationCreationResult);
        Py_CLEAR(state->type_ActivationSignalDetector);
        Py_CLEAR(state->type_ConversationalAgentDetectorManager);
        Py_CLEAR(state->type_ConversationalAgentSession);
        Py_CLEAR(state->type_ConversationalAgentSessionInterruptedEventArgs);
        Py_CLEAR(state->type_ConversationalAgentSignal);
        Py_CLEAR(state->type_ConversationalAgentSignalDetectedEventArgs);
        Py_CLEAR(state->type_ConversationalAgentSystemStateChangedEventArgs);
        Py_CLEAR(state->type_DetectionConfigurationAvailabilityChangedEventArgs);
        Py_CLEAR(state->type_DetectionConfigurationAvailabilityInfo);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_ApplicationModel_ConversationalAgent",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::ApplicationModel::ConversationalAgent

PyMODINIT_FUNC PyInit__winsdk_Windows_ApplicationModel_ConversationalAgent(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_ActivationSignalDetectionConfiguration = py::register_python_type(module.get(), type_name_ActivationSignalDetectionConfiguration, &type_spec_ActivationSignalDetectionConfiguration, bases.get());
    if (!state->type_ActivationSignalDetectionConfiguration)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ActivationSignalDetectionConfiguration);

    state->type_ActivationSignalDetectionConfigurationCreationResult = py::register_python_type(module.get(), type_name_ActivationSignalDetectionConfigurationCreationResult, &type_spec_ActivationSignalDetectionConfigurationCreationResult, bases.get());
    if (!state->type_ActivationSignalDetectionConfigurationCreationResult)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ActivationSignalDetectionConfigurationCreationResult);

    state->type_ActivationSignalDetector = py::register_python_type(module.get(), type_name_ActivationSignalDetector, &type_spec_ActivationSignalDetector, bases.get());
    if (!state->type_ActivationSignalDetector)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ActivationSignalDetector);

    state->type_ConversationalAgentDetectorManager = py::register_python_type(module.get(), type_name_ConversationalAgentDetectorManager, &type_spec_ConversationalAgentDetectorManager, bases.get());
    if (!state->type_ConversationalAgentDetectorManager)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ConversationalAgentDetectorManager);

    state->type_ConversationalAgentSession = py::register_python_type(module.get(), type_name_ConversationalAgentSession, &type_spec_ConversationalAgentSession, bases.get());
    if (!state->type_ConversationalAgentSession)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ConversationalAgentSession);

    state->type_ConversationalAgentSessionInterruptedEventArgs = py::register_python_type(module.get(), type_name_ConversationalAgentSessionInterruptedEventArgs, &type_spec_ConversationalAgentSessionInterruptedEventArgs, bases.get());
    if (!state->type_ConversationalAgentSessionInterruptedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ConversationalAgentSessionInterruptedEventArgs);

    state->type_ConversationalAgentSignal = py::register_python_type(module.get(), type_name_ConversationalAgentSignal, &type_spec_ConversationalAgentSignal, bases.get());
    if (!state->type_ConversationalAgentSignal)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ConversationalAgentSignal);

    state->type_ConversationalAgentSignalDetectedEventArgs = py::register_python_type(module.get(), type_name_ConversationalAgentSignalDetectedEventArgs, &type_spec_ConversationalAgentSignalDetectedEventArgs, bases.get());
    if (!state->type_ConversationalAgentSignalDetectedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ConversationalAgentSignalDetectedEventArgs);

    state->type_ConversationalAgentSystemStateChangedEventArgs = py::register_python_type(module.get(), type_name_ConversationalAgentSystemStateChangedEventArgs, &type_spec_ConversationalAgentSystemStateChangedEventArgs, bases.get());
    if (!state->type_ConversationalAgentSystemStateChangedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ConversationalAgentSystemStateChangedEventArgs);

    state->type_DetectionConfigurationAvailabilityChangedEventArgs = py::register_python_type(module.get(), type_name_DetectionConfigurationAvailabilityChangedEventArgs, &type_spec_DetectionConfigurationAvailabilityChangedEventArgs, bases.get());
    if (!state->type_DetectionConfigurationAvailabilityChangedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_DetectionConfigurationAvailabilityChangedEventArgs);

    state->type_DetectionConfigurationAvailabilityInfo = py::register_python_type(module.get(), type_name_DetectionConfigurationAvailabilityInfo, &type_spec_DetectionConfigurationAvailabilityInfo, bases.get());
    if (!state->type_DetectionConfigurationAvailabilityInfo)
    {
        return nullptr;
    }

    Py_INCREF(state->type_DetectionConfigurationAvailabilityInfo);


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ActivationSignalDetectionConfigurationCreationStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationRemovalResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ActivationSignalDetectionConfigurationRemovalResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationRemovalResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationSetModelDataResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ActivationSignalDetectionConfigurationSetModelDataResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationSetModelDataResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationStateChangeResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ActivationSignalDetectionConfigurationStateChangeResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationStateChangeResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionTrainingDataFormat>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ActivationSignalDetectionTrainingDataFormat;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionTrainingDataFormat is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectorKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ActivationSignalDetectorKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectorKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectorPowerState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ActivationSignalDetectorPowerState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectorPowerState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentActivationKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ConversationalAgentActivationKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentActivationKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentActivationResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ConversationalAgentActivationResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentActivationResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionUpdateResponse>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ConversationalAgentSessionUpdateResponse;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionUpdateResponse is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ConversationalAgentState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangeType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ConversationalAgentSystemStateChangeType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangeType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentVoiceActivationPrerequisiteKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ConversationalAgentVoiceActivationPrerequisiteKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentVoiceActivationPrerequisiteKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangeKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DetectionConfigurationAvailabilityChangeKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangeKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationTrainingStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DetectionConfigurationTrainingStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationTrainingStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::ConversationalAgent::SignalDetectorResourceKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SignalDetectorResourceKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::SignalDetectorResourceKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ActivationSignalDetectionConfiguration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ActivationSignalDetectionConfigurationCreationResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ActivationSignalDetector;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ConversationalAgentDetectorManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ConversationalAgentSession;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ConversationalAgentSessionInterruptedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ConversationalAgentSignal;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ConversationalAgentSignalDetectedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ConversationalAgentSystemStateChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DetectionConfigurationAvailabilityChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::ConversationalAgent;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::ConversationalAgent");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DetectionConfigurationAvailabilityInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo is not registered");
        return nullptr;
    }

    return python_type;
}
