// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.6

#include "pybase.h"
#include "py.Windows.Networking.BackgroundTransfer.h"


PyObject* py::converter<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress py::converter<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange py::converter<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress py::converter<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress");
    throw python_exception();
}

namespace py::cpp::Windows::Networking::BackgroundTransfer
{
    struct module_state
    {
        PyObject* type_BackgroundTransferBehavior;
        PyObject* type_BackgroundTransferCostPolicy;
        PyObject* type_BackgroundTransferPriority;
        PyObject* type_BackgroundTransferStatus;
        PyTypeObject* type_BackgroundDownloader;
        PyTypeObject* type_BackgroundTransferCompletionGroup;
        PyTypeObject* type_BackgroundTransferCompletionGroupTriggerDetails;
        PyTypeObject* type_BackgroundTransferContentPart;
        PyTypeObject* type_BackgroundTransferError;
        PyTypeObject* type_BackgroundTransferGroup;
        PyTypeObject* type_BackgroundTransferRangesDownloadedEventArgs;
        PyTypeObject* type_BackgroundUploader;
        PyTypeObject* type_ContentPrefetcher;
        PyTypeObject* type_DownloadOperation;
        PyTypeObject* type_ResponseInformation;
        PyTypeObject* type_UnconstrainedTransferRequestResult;
        PyTypeObject* type_UploadOperation;
        PyTypeObject* type_IBackgroundTransferBase;
        PyTypeObject* type_IBackgroundTransferContentPartFactory;
        PyTypeObject* type_IBackgroundTransferOperation;
        PyTypeObject* type_IBackgroundTransferOperationPriority;
        PyTypeObject* type_BackgroundDownloadProgress;
        PyTypeObject* type_BackgroundTransferFileRange;
        PyTypeObject* type_BackgroundUploadProgress;
    };

    static PyObject* register_BackgroundTransferBehavior(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BackgroundTransferBehavior)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BackgroundTransferBehavior = type;
        Py_INCREF(state->type_BackgroundTransferBehavior);


        Py_RETURN_NONE;
    }

    static PyObject* register_BackgroundTransferCostPolicy(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BackgroundTransferCostPolicy)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BackgroundTransferCostPolicy = type;
        Py_INCREF(state->type_BackgroundTransferCostPolicy);


        Py_RETURN_NONE;
    }

    static PyObject* register_BackgroundTransferPriority(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BackgroundTransferPriority)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BackgroundTransferPriority = type;
        Py_INCREF(state->type_BackgroundTransferPriority);


        Py_RETURN_NONE;
    }

    static PyObject* register_BackgroundTransferStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_BackgroundTransferStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_BackgroundTransferStatus = type;
        Py_INCREF(state->type_BackgroundTransferStatus);


        Py_RETURN_NONE;
    }

    // ----- BackgroundDownloader class --------------------
    constexpr const char* const type_name_BackgroundDownloader = "BackgroundDownloader";

    static PyObject* _new_BackgroundDownloader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup>(args, 0);

                winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackgroundDownloader(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundDownloader_CreateDownload(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);

                return py::convert(self->obj.CreateDownload(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 2);

                return py::convert(self->obj.CreateDownload(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_CreateDownloadAsync(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 2);

                return py::convert(self->obj.CreateDownloadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_GetCurrentDownloadsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader::GetCurrentDownloadsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader::GetCurrentDownloadsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_GetCurrentDownloadsForTransferGroupAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader::GetCurrentDownloadsForTransferGroupAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_RequestUnconstrainedDownloadsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader::RequestUnconstrainedDownloadsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_SetRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_get_FailureToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FailureToastNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_FailureToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotification>(arg);

            self->obj.FailureToastNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_SuccessTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuccessTileNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_SuccessTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileNotification>(arg);

            self->obj.SuccessTileNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_SuccessToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuccessToastNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_SuccessToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotification>(arg);

            self->obj.SuccessToastNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransferGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>(arg);

            self->obj.TransferGroup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_FailureTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FailureTileNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_FailureTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileNotification>(arg);

            self->obj.FailureTileNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_CompletionGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CompletionGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundDownloader_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_Group(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Group(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_Method(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Method(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloader_get_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloader_put_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_BackgroundDownloader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundDownloader[] = {
        { "create_download", reinterpret_cast<PyCFunction>(BackgroundDownloader_CreateDownload), METH_VARARGS, nullptr },
        { "create_download_async", reinterpret_cast<PyCFunction>(BackgroundDownloader_CreateDownloadAsync), METH_VARARGS, nullptr },
        { "get_current_downloads_async", reinterpret_cast<PyCFunction>(BackgroundDownloader_GetCurrentDownloadsAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_downloads_for_transfer_group_async", reinterpret_cast<PyCFunction>(BackgroundDownloader_GetCurrentDownloadsForTransferGroupAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_unconstrained_downloads_async", reinterpret_cast<PyCFunction>(BackgroundDownloader_RequestUnconstrainedDownloadsAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "set_request_header", reinterpret_cast<PyCFunction>(BackgroundDownloader_SetRequestHeader), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundDownloader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundDownloader[] = {
        { "failure_toast_notification", reinterpret_cast<getter>(BackgroundDownloader_get_FailureToastNotification), reinterpret_cast<setter>(BackgroundDownloader_put_FailureToastNotification), nullptr, nullptr },
        { "success_tile_notification", reinterpret_cast<getter>(BackgroundDownloader_get_SuccessTileNotification), reinterpret_cast<setter>(BackgroundDownloader_put_SuccessTileNotification), nullptr, nullptr },
        { "success_toast_notification", reinterpret_cast<getter>(BackgroundDownloader_get_SuccessToastNotification), reinterpret_cast<setter>(BackgroundDownloader_put_SuccessToastNotification), nullptr, nullptr },
        { "transfer_group", reinterpret_cast<getter>(BackgroundDownloader_get_TransferGroup), reinterpret_cast<setter>(BackgroundDownloader_put_TransferGroup), nullptr, nullptr },
        { "failure_tile_notification", reinterpret_cast<getter>(BackgroundDownloader_get_FailureTileNotification), reinterpret_cast<setter>(BackgroundDownloader_put_FailureTileNotification), nullptr, nullptr },
        { "completion_group", reinterpret_cast<getter>(BackgroundDownloader_get_CompletionGroup), nullptr, nullptr, nullptr },
        { "cost_policy", reinterpret_cast<getter>(BackgroundDownloader_get_CostPolicy), reinterpret_cast<setter>(BackgroundDownloader_put_CostPolicy), nullptr, nullptr },
        { "group", reinterpret_cast<getter>(BackgroundDownloader_get_Group), reinterpret_cast<setter>(BackgroundDownloader_put_Group), nullptr, nullptr },
        { "method", reinterpret_cast<getter>(BackgroundDownloader_get_Method), reinterpret_cast<setter>(BackgroundDownloader_put_Method), nullptr, nullptr },
        { "proxy_credential", reinterpret_cast<getter>(BackgroundDownloader_get_ProxyCredential), reinterpret_cast<setter>(BackgroundDownloader_put_ProxyCredential), nullptr, nullptr },
        { "server_credential", reinterpret_cast<getter>(BackgroundDownloader_get_ServerCredential), reinterpret_cast<setter>(BackgroundDownloader_put_ServerCredential), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundDownloader[] = 
    {
        { Py_tp_new, _new_BackgroundDownloader },
        { Py_tp_dealloc, _dealloc_BackgroundDownloader },
        { Py_tp_methods, _methods_BackgroundDownloader },
        { Py_tp_getset, _getset_BackgroundDownloader },
        { },
    };

    static PyType_Spec type_spec_BackgroundDownloader =
    {
        "_winsdk_Windows_Networking_BackgroundTransfer.BackgroundDownloader",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundDownloader
    };

    // ----- BackgroundTransferCompletionGroup class --------------------
    constexpr const char* const type_name_BackgroundTransferCompletionGroup = "BackgroundTransferCompletionGroup";

    static PyObject* _new_BackgroundTransferCompletionGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackgroundTransferCompletionGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTransferCompletionGroup_Enable(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Enable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferCompletionGroup_get_IsEnabled(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferCompletionGroup_get_Trigger(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Trigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BackgroundTransferCompletionGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferCompletionGroup[] = {
        { "enable", reinterpret_cast<PyCFunction>(BackgroundTransferCompletionGroup_Enable), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTransferCompletionGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTransferCompletionGroup[] = {
        { "is_enabled", reinterpret_cast<getter>(BackgroundTransferCompletionGroup_get_IsEnabled), nullptr, nullptr, nullptr },
        { "trigger", reinterpret_cast<getter>(BackgroundTransferCompletionGroup_get_Trigger), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTransferCompletionGroup[] = 
    {
        { Py_tp_new, _new_BackgroundTransferCompletionGroup },
        { Py_tp_dealloc, _dealloc_BackgroundTransferCompletionGroup },
        { Py_tp_methods, _methods_BackgroundTransferCompletionGroup },
        { Py_tp_getset, _getset_BackgroundTransferCompletionGroup },
        { },
    };

    static PyType_Spec type_spec_BackgroundTransferCompletionGroup =
    {
        "_winsdk_Windows_Networking_BackgroundTransfer.BackgroundTransferCompletionGroup",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferCompletionGroup
    };

    // ----- BackgroundTransferCompletionGroupTriggerDetails class --------------------
    constexpr const char* const type_name_BackgroundTransferCompletionGroupTriggerDetails = "BackgroundTransferCompletionGroupTriggerDetails";

    static PyObject* _new_BackgroundTransferCompletionGroupTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BackgroundTransferCompletionGroupTriggerDetails);
        return nullptr;
    }

    static void _dealloc_BackgroundTransferCompletionGroupTriggerDetails(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTransferCompletionGroupTriggerDetails_get_Downloads(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Downloads());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferCompletionGroupTriggerDetails_get_Uploads(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uploads());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BackgroundTransferCompletionGroupTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferCompletionGroupTriggerDetails[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTransferCompletionGroupTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTransferCompletionGroupTriggerDetails[] = {
        { "downloads", reinterpret_cast<getter>(BackgroundTransferCompletionGroupTriggerDetails_get_Downloads), nullptr, nullptr, nullptr },
        { "uploads", reinterpret_cast<getter>(BackgroundTransferCompletionGroupTriggerDetails_get_Uploads), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTransferCompletionGroupTriggerDetails[] = 
    {
        { Py_tp_new, _new_BackgroundTransferCompletionGroupTriggerDetails },
        { Py_tp_dealloc, _dealloc_BackgroundTransferCompletionGroupTriggerDetails },
        { Py_tp_methods, _methods_BackgroundTransferCompletionGroupTriggerDetails },
        { Py_tp_getset, _getset_BackgroundTransferCompletionGroupTriggerDetails },
        { },
    };

    static PyType_Spec type_spec_BackgroundTransferCompletionGroupTriggerDetails =
    {
        "_winsdk_Windows_Networking_BackgroundTransfer.BackgroundTransferCompletionGroupTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferCompletionGroupTriggerDetails
    };

    // ----- BackgroundTransferContentPart class --------------------
    constexpr const char* const type_name_BackgroundTransferContentPart = "BackgroundTransferContentPart";

    static PyObject* _new_BackgroundTransferContentPart(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackgroundTransferContentPart(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTransferContentPart_SetFile(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                self->obj.SetFile(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferContentPart_SetHeader(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferContentPart_SetText(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetText(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_BackgroundTransferContentPart(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferContentPart[] = {
        { "set_file", reinterpret_cast<PyCFunction>(BackgroundTransferContentPart_SetFile), METH_VARARGS, nullptr },
        { "set_header", reinterpret_cast<PyCFunction>(BackgroundTransferContentPart_SetHeader), METH_VARARGS, nullptr },
        { "set_text", reinterpret_cast<PyCFunction>(BackgroundTransferContentPart_SetText), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTransferContentPart), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTransferContentPart[] = {
        { }
    };

    static PyType_Slot _type_slots_BackgroundTransferContentPart[] = 
    {
        { Py_tp_new, _new_BackgroundTransferContentPart },
        { Py_tp_dealloc, _dealloc_BackgroundTransferContentPart },
        { Py_tp_methods, _methods_BackgroundTransferContentPart },
        { Py_tp_getset, _getset_BackgroundTransferContentPart },
        { },
    };

    static PyType_Spec type_spec_BackgroundTransferContentPart =
    {
        "_winsdk_Windows_Networking_BackgroundTransfer.BackgroundTransferContentPart",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferContentPart
    };

    // ----- BackgroundTransferError class --------------------
    constexpr const char* const type_name_BackgroundTransferError = "BackgroundTransferError";

    static PyObject* _new_BackgroundTransferError(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BackgroundTransferError);
        return nullptr;
    }

    static PyObject* BackgroundTransferError_GetStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferError::GetStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferError[] = {
        { "get_status", reinterpret_cast<PyCFunction>(BackgroundTransferError_GetStatus), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTransferError[] = {
        { }
    };

    static PyType_Slot _type_slots_BackgroundTransferError[] = 
    {
        { Py_tp_new, _new_BackgroundTransferError },
        { Py_tp_methods, _methods_BackgroundTransferError },
        { Py_tp_getset, _getset_BackgroundTransferError },
        { },
    };

    static PyType_Spec type_spec_BackgroundTransferError =
    {
        "_winsdk_Windows_Networking_BackgroundTransfer.BackgroundTransferError",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferError
    };

    // ----- BackgroundTransferGroup class --------------------
    constexpr const char* const type_name_BackgroundTransferGroup = "BackgroundTransferGroup";

    static PyObject* _new_BackgroundTransferGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BackgroundTransferGroup);
        return nullptr;
    }

    static void _dealloc_BackgroundTransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTransferGroup_CreateGroup(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup::CreateGroup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferGroup_get_TransferBehavior(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransferBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTransferGroup_put_TransferBehavior(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferBehavior>(arg);

            self->obj.TransferBehavior(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundTransferGroup_get_Name(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BackgroundTransferGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferGroup[] = {
        { "create_group", reinterpret_cast<PyCFunction>(BackgroundTransferGroup_CreateGroup), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTransferGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTransferGroup[] = {
        { "transfer_behavior", reinterpret_cast<getter>(BackgroundTransferGroup_get_TransferBehavior), reinterpret_cast<setter>(BackgroundTransferGroup_put_TransferBehavior), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(BackgroundTransferGroup_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTransferGroup[] = 
    {
        { Py_tp_new, _new_BackgroundTransferGroup },
        { Py_tp_dealloc, _dealloc_BackgroundTransferGroup },
        { Py_tp_methods, _methods_BackgroundTransferGroup },
        { Py_tp_getset, _getset_BackgroundTransferGroup },
        { },
    };

    static PyType_Spec type_spec_BackgroundTransferGroup =
    {
        "_winsdk_Windows_Networking_BackgroundTransfer.BackgroundTransferGroup",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferGroup
    };

    // ----- BackgroundTransferRangesDownloadedEventArgs class --------------------
    constexpr const char* const type_name_BackgroundTransferRangesDownloadedEventArgs = "BackgroundTransferRangesDownloadedEventArgs";

    static PyObject* _new_BackgroundTransferRangesDownloadedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BackgroundTransferRangesDownloadedEventArgs);
        return nullptr;
    }

    static void _dealloc_BackgroundTransferRangesDownloadedEventArgs(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundTransferRangesDownloadedEventArgs_GetDeferral(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferRangesDownloadedEventArgs_get_AddedRanges(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AddedRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BackgroundTransferRangesDownloadedEventArgs_get_WasDownloadRestarted(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WasDownloadRestarted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BackgroundTransferRangesDownloadedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundTransferRangesDownloadedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(BackgroundTransferRangesDownloadedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundTransferRangesDownloadedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundTransferRangesDownloadedEventArgs[] = {
        { "added_ranges", reinterpret_cast<getter>(BackgroundTransferRangesDownloadedEventArgs_get_AddedRanges), nullptr, nullptr, nullptr },
        { "was_download_restarted", reinterpret_cast<getter>(BackgroundTransferRangesDownloadedEventArgs_get_WasDownloadRestarted), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTransferRangesDownloadedEventArgs[] = 
    {
        { Py_tp_new, _new_BackgroundTransferRangesDownloadedEventArgs },
        { Py_tp_dealloc, _dealloc_BackgroundTransferRangesDownloadedEventArgs },
        { Py_tp_methods, _methods_BackgroundTransferRangesDownloadedEventArgs },
        { Py_tp_getset, _getset_BackgroundTransferRangesDownloadedEventArgs },
        { },
    };

    static PyType_Spec type_spec_BackgroundTransferRangesDownloadedEventArgs =
    {
        "_winsdk_Windows_Networking_BackgroundTransfer.BackgroundTransferRangesDownloadedEventArgs",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferRangesDownloadedEventArgs
    };

    // ----- BackgroundUploader class --------------------
    constexpr const char* const type_name_BackgroundUploader = "BackgroundUploader";

    static PyObject* _new_BackgroundUploader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup>(args, 0);

                winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_BackgroundUploader(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundUploader_CreateUpload(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);

                return py::convert(self->obj.CreateUpload(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_CreateUploadAsync(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>>(args, 1);

                return py::convert(self->obj.CreateUploadAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.CreateUploadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.CreateUploadAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_CreateUploadFromStreamAsync(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.CreateUploadFromStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_GetCurrentUploadsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader::GetCurrentUploadsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader::GetCurrentUploadsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_GetCurrentUploadsForTransferGroupAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader::GetCurrentUploadsForTransferGroupAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_RequestUnconstrainedUploadsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::BackgroundTransfer::UploadOperation>>(args, 0);

                return py::convert(winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader::RequestUnconstrainedUploadsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_SetRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* BackgroundUploader_get_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_Method(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Method(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_Group(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Group(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_FailureTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FailureTileNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_FailureTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileNotification>(arg);

            self->obj.FailureTileNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransferGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>(arg);

            self->obj.TransferGroup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_SuccessToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuccessToastNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_SuccessToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotification>(arg);

            self->obj.SuccessToastNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_SuccessTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuccessTileNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_SuccessTileNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::TileNotification>(arg);

            self->obj.SuccessTileNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_FailureToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FailureToastNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploader_put_FailureToastNotification(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Notifications::ToastNotification>(arg);

            self->obj.FailureToastNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploader_get_CompletionGroup(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CompletionGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BackgroundUploader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundUploader[] = {
        { "create_upload", reinterpret_cast<PyCFunction>(BackgroundUploader_CreateUpload), METH_VARARGS, nullptr },
        { "create_upload_async", reinterpret_cast<PyCFunction>(BackgroundUploader_CreateUploadAsync), METH_VARARGS, nullptr },
        { "create_upload_from_stream_async", reinterpret_cast<PyCFunction>(BackgroundUploader_CreateUploadFromStreamAsync), METH_VARARGS, nullptr },
        { "get_current_uploads_async", reinterpret_cast<PyCFunction>(BackgroundUploader_GetCurrentUploadsAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_uploads_for_transfer_group_async", reinterpret_cast<PyCFunction>(BackgroundUploader_GetCurrentUploadsForTransferGroupAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_unconstrained_uploads_async", reinterpret_cast<PyCFunction>(BackgroundUploader_RequestUnconstrainedUploadsAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "set_request_header", reinterpret_cast<PyCFunction>(BackgroundUploader_SetRequestHeader), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundUploader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundUploader[] = {
        { "server_credential", reinterpret_cast<getter>(BackgroundUploader_get_ServerCredential), reinterpret_cast<setter>(BackgroundUploader_put_ServerCredential), nullptr, nullptr },
        { "proxy_credential", reinterpret_cast<getter>(BackgroundUploader_get_ProxyCredential), reinterpret_cast<setter>(BackgroundUploader_put_ProxyCredential), nullptr, nullptr },
        { "method", reinterpret_cast<getter>(BackgroundUploader_get_Method), reinterpret_cast<setter>(BackgroundUploader_put_Method), nullptr, nullptr },
        { "group", reinterpret_cast<getter>(BackgroundUploader_get_Group), reinterpret_cast<setter>(BackgroundUploader_put_Group), nullptr, nullptr },
        { "cost_policy", reinterpret_cast<getter>(BackgroundUploader_get_CostPolicy), reinterpret_cast<setter>(BackgroundUploader_put_CostPolicy), nullptr, nullptr },
        { "failure_tile_notification", reinterpret_cast<getter>(BackgroundUploader_get_FailureTileNotification), reinterpret_cast<setter>(BackgroundUploader_put_FailureTileNotification), nullptr, nullptr },
        { "transfer_group", reinterpret_cast<getter>(BackgroundUploader_get_TransferGroup), reinterpret_cast<setter>(BackgroundUploader_put_TransferGroup), nullptr, nullptr },
        { "success_toast_notification", reinterpret_cast<getter>(BackgroundUploader_get_SuccessToastNotification), reinterpret_cast<setter>(BackgroundUploader_put_SuccessToastNotification), nullptr, nullptr },
        { "success_tile_notification", reinterpret_cast<getter>(BackgroundUploader_get_SuccessTileNotification), reinterpret_cast<setter>(BackgroundUploader_put_SuccessTileNotification), nullptr, nullptr },
        { "failure_toast_notification", reinterpret_cast<getter>(BackgroundUploader_get_FailureToastNotification), reinterpret_cast<setter>(BackgroundUploader_put_FailureToastNotification), nullptr, nullptr },
        { "completion_group", reinterpret_cast<getter>(BackgroundUploader_get_CompletionGroup), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundUploader[] = 
    {
        { Py_tp_new, _new_BackgroundUploader },
        { Py_tp_dealloc, _dealloc_BackgroundUploader },
        { Py_tp_methods, _methods_BackgroundUploader },
        { Py_tp_getset, _getset_BackgroundUploader },
        { },
    };

    static PyType_Spec type_spec_BackgroundUploader =
    {
        "_winsdk_Windows_Networking_BackgroundTransfer.BackgroundUploader",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundUploader
    };

    // ----- ContentPrefetcher class --------------------
    constexpr const char* const type_name_ContentPrefetcher = "ContentPrefetcher";

    static PyObject* _new_ContentPrefetcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ContentPrefetcher);
        return nullptr;
    }

    static PyObject* ContentPrefetcher_get_IndirectContentUri(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher::IndirectContentUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentPrefetcher_put_IndirectContentUri(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher::IndirectContentUri(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentPrefetcher_get_ContentUris(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher::ContentUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContentPrefetcher_get_LastSuccessfulPrefetchTime(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher::LastSuccessfulPrefetchTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContentPrefetcher[] = {
        { "get_indirect_content_uri", reinterpret_cast<PyCFunction>(ContentPrefetcher_get_IndirectContentUri), METH_NOARGS | METH_STATIC, nullptr },
        { "put_indirect_content_uri", reinterpret_cast<PyCFunction>(ContentPrefetcher_put_IndirectContentUri), METH_O | METH_STATIC, nullptr },
        { "get_content_uris", reinterpret_cast<PyCFunction>(ContentPrefetcher_get_ContentUris), METH_NOARGS | METH_STATIC, nullptr },
        { "get_last_successful_prefetch_time", reinterpret_cast<PyCFunction>(ContentPrefetcher_get_LastSuccessfulPrefetchTime), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContentPrefetcher[] = {
        { }
    };

    static PyType_Slot _type_slots_ContentPrefetcher[] = 
    {
        { Py_tp_new, _new_ContentPrefetcher },
        { Py_tp_methods, _methods_ContentPrefetcher },
        { Py_tp_getset, _getset_ContentPrefetcher },
        { },
    };

    static PyType_Spec type_spec_ContentPrefetcher =
    {
        "_winsdk_Windows_Networking_BackgroundTransfer.ContentPrefetcher",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContentPrefetcher
    };

    // ----- DownloadOperation class --------------------
    constexpr const char* const type_name_DownloadOperation = "DownloadOperation";

    static PyObject* _new_DownloadOperation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DownloadOperation);
        return nullptr;
    }

    static void _dealloc_DownloadOperation(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DownloadOperation_AttachAsync(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.AttachAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_GetDownloadedRanges(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDownloadedRanges());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_GetResponseInformation(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetResponseInformation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_GetResultRandomAccessStreamReference(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetResultRandomAccessStreamReference());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_GetResultStreamAt(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetResultStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_MakeCurrentInTransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.MakeCurrentInTransferGroup();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_Pause(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Pause();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_RemoveRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.RemoveRequestHeader(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_Resume(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Resume();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_SetRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_StartAsync(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DownloadOperation_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DownloadOperation_get_RequestedUri(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestedUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DownloadOperation_put_RequestedUri(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.RequestedUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DownloadOperation_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_Guid(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Guid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Priority());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DownloadOperation_put_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferPriority>(arg);

            self->obj.Priority(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DownloadOperation_get_Progress(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_ResultFile(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResultFile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransferGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_IsRandomAccessRequired(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRandomAccessRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DownloadOperation_put_IsRandomAccessRequired(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRandomAccessRequired(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DownloadOperation_get_CurrentWebErrorStatus(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentWebErrorStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_get_RecoverableWebErrorStatuses(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RecoverableWebErrorStatuses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_add_RangesDownloaded(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation, winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs>>(arg);

            return py::convert(self->obj.RangesDownloaded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DownloadOperation_remove_RangesDownloaded(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RangesDownloaded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DownloadOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DownloadOperation[] = {
        { "attach_async", reinterpret_cast<PyCFunction>(DownloadOperation_AttachAsync), METH_VARARGS, nullptr },
        { "get_downloaded_ranges", reinterpret_cast<PyCFunction>(DownloadOperation_GetDownloadedRanges), METH_VARARGS, nullptr },
        { "get_response_information", reinterpret_cast<PyCFunction>(DownloadOperation_GetResponseInformation), METH_VARARGS, nullptr },
        { "get_result_random_access_stream_reference", reinterpret_cast<PyCFunction>(DownloadOperation_GetResultRandomAccessStreamReference), METH_VARARGS, nullptr },
        { "get_result_stream_at", reinterpret_cast<PyCFunction>(DownloadOperation_GetResultStreamAt), METH_VARARGS, nullptr },
        { "make_current_in_transfer_group", reinterpret_cast<PyCFunction>(DownloadOperation_MakeCurrentInTransferGroup), METH_VARARGS, nullptr },
        { "pause", reinterpret_cast<PyCFunction>(DownloadOperation_Pause), METH_VARARGS, nullptr },
        { "remove_request_header", reinterpret_cast<PyCFunction>(DownloadOperation_RemoveRequestHeader), METH_VARARGS, nullptr },
        { "resume", reinterpret_cast<PyCFunction>(DownloadOperation_Resume), METH_VARARGS, nullptr },
        { "set_request_header", reinterpret_cast<PyCFunction>(DownloadOperation_SetRequestHeader), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(DownloadOperation_StartAsync), METH_VARARGS, nullptr },
        { "add_ranges_downloaded", reinterpret_cast<PyCFunction>(DownloadOperation_add_RangesDownloaded), METH_O, nullptr },
        { "remove_ranges_downloaded", reinterpret_cast<PyCFunction>(DownloadOperation_remove_RangesDownloaded), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DownloadOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DownloadOperation[] = {
        { "cost_policy", reinterpret_cast<getter>(DownloadOperation_get_CostPolicy), reinterpret_cast<setter>(DownloadOperation_put_CostPolicy), nullptr, nullptr },
        { "requested_uri", reinterpret_cast<getter>(DownloadOperation_get_RequestedUri), reinterpret_cast<setter>(DownloadOperation_put_RequestedUri), nullptr, nullptr },
        { "method", reinterpret_cast<getter>(DownloadOperation_get_Method), nullptr, nullptr, nullptr },
        { "group", reinterpret_cast<getter>(DownloadOperation_get_Group), nullptr, nullptr, nullptr },
        { "guid", reinterpret_cast<getter>(DownloadOperation_get_Guid), nullptr, nullptr, nullptr },
        { "priority", reinterpret_cast<getter>(DownloadOperation_get_Priority), reinterpret_cast<setter>(DownloadOperation_put_Priority), nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(DownloadOperation_get_Progress), nullptr, nullptr, nullptr },
        { "result_file", reinterpret_cast<getter>(DownloadOperation_get_ResultFile), nullptr, nullptr, nullptr },
        { "transfer_group", reinterpret_cast<getter>(DownloadOperation_get_TransferGroup), nullptr, nullptr, nullptr },
        { "is_random_access_required", reinterpret_cast<getter>(DownloadOperation_get_IsRandomAccessRequired), reinterpret_cast<setter>(DownloadOperation_put_IsRandomAccessRequired), nullptr, nullptr },
        { "current_web_error_status", reinterpret_cast<getter>(DownloadOperation_get_CurrentWebErrorStatus), nullptr, nullptr, nullptr },
        { "recoverable_web_error_statuses", reinterpret_cast<getter>(DownloadOperation_get_RecoverableWebErrorStatuses), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DownloadOperation[] = 
    {
        { Py_tp_new, _new_DownloadOperation },
        { Py_tp_dealloc, _dealloc_DownloadOperation },
        { Py_tp_methods, _methods_DownloadOperation },
        { Py_tp_getset, _getset_DownloadOperation },
        { },
    };

    static PyType_Spec type_spec_DownloadOperation =
    {
        "_winsdk_Windows_Networking_BackgroundTransfer.DownloadOperation",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::DownloadOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DownloadOperation
    };

    // ----- ResponseInformation class --------------------
    constexpr const char* const type_name_ResponseInformation = "ResponseInformation";

    static PyObject* _new_ResponseInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ResponseInformation);
        return nullptr;
    }

    static void _dealloc_ResponseInformation(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ResponseInformation_get_ActualUri(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActualUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ResponseInformation_get_Headers(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ResponseInformation_get_IsResumable(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsResumable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ResponseInformation_get_StatusCode(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StatusCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ResponseInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::ResponseInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ResponseInformation[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ResponseInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ResponseInformation[] = {
        { "actual_uri", reinterpret_cast<getter>(ResponseInformation_get_ActualUri), nullptr, nullptr, nullptr },
        { "headers", reinterpret_cast<getter>(ResponseInformation_get_Headers), nullptr, nullptr, nullptr },
        { "is_resumable", reinterpret_cast<getter>(ResponseInformation_get_IsResumable), nullptr, nullptr, nullptr },
        { "status_code", reinterpret_cast<getter>(ResponseInformation_get_StatusCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ResponseInformation[] = 
    {
        { Py_tp_new, _new_ResponseInformation },
        { Py_tp_dealloc, _dealloc_ResponseInformation },
        { Py_tp_methods, _methods_ResponseInformation },
        { Py_tp_getset, _getset_ResponseInformation },
        { },
    };

    static PyType_Spec type_spec_ResponseInformation =
    {
        "_winsdk_Windows_Networking_BackgroundTransfer.ResponseInformation",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::ResponseInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ResponseInformation
    };

    // ----- UnconstrainedTransferRequestResult class --------------------
    constexpr const char* const type_name_UnconstrainedTransferRequestResult = "UnconstrainedTransferRequestResult";

    static PyObject* _new_UnconstrainedTransferRequestResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UnconstrainedTransferRequestResult);
        return nullptr;
    }

    static void _dealloc_UnconstrainedTransferRequestResult(py::wrapper::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UnconstrainedTransferRequestResult_get_IsUnconstrained(py::wrapper::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUnconstrained());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UnconstrainedTransferRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UnconstrainedTransferRequestResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UnconstrainedTransferRequestResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UnconstrainedTransferRequestResult[] = {
        { "is_unconstrained", reinterpret_cast<getter>(UnconstrainedTransferRequestResult_get_IsUnconstrained), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UnconstrainedTransferRequestResult[] = 
    {
        { Py_tp_new, _new_UnconstrainedTransferRequestResult },
        { Py_tp_dealloc, _dealloc_UnconstrainedTransferRequestResult },
        { Py_tp_methods, _methods_UnconstrainedTransferRequestResult },
        { Py_tp_getset, _getset_UnconstrainedTransferRequestResult },
        { },
    };

    static PyType_Spec type_spec_UnconstrainedTransferRequestResult =
    {
        "_winsdk_Windows_Networking_BackgroundTransfer.UnconstrainedTransferRequestResult",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UnconstrainedTransferRequestResult
    };

    // ----- UploadOperation class --------------------
    constexpr const char* const type_name_UploadOperation = "UploadOperation";

    static PyObject* _new_UploadOperation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UploadOperation);
        return nullptr;
    }

    static void _dealloc_UploadOperation(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UploadOperation_AttachAsync(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.AttachAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_GetResponseInformation(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetResponseInformation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_GetResultStreamAt(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetResultStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_MakeCurrentInTransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.MakeCurrentInTransferGroup();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_RemoveRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.RemoveRequestHeader(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_SetRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_StartAsync(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UploadOperation_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UploadOperation_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_Guid(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Guid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_RequestedUri(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestedUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Priority());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UploadOperation_put_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferPriority>(arg);

            self->obj.Priority(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UploadOperation_get_Progress(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_SourceFile(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceFile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UploadOperation_get_TransferGroup(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransferGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UploadOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::UploadOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UploadOperation[] = {
        { "attach_async", reinterpret_cast<PyCFunction>(UploadOperation_AttachAsync), METH_VARARGS, nullptr },
        { "get_response_information", reinterpret_cast<PyCFunction>(UploadOperation_GetResponseInformation), METH_VARARGS, nullptr },
        { "get_result_stream_at", reinterpret_cast<PyCFunction>(UploadOperation_GetResultStreamAt), METH_VARARGS, nullptr },
        { "make_current_in_transfer_group", reinterpret_cast<PyCFunction>(UploadOperation_MakeCurrentInTransferGroup), METH_VARARGS, nullptr },
        { "remove_request_header", reinterpret_cast<PyCFunction>(UploadOperation_RemoveRequestHeader), METH_VARARGS, nullptr },
        { "set_request_header", reinterpret_cast<PyCFunction>(UploadOperation_SetRequestHeader), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(UploadOperation_StartAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UploadOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UploadOperation[] = {
        { "cost_policy", reinterpret_cast<getter>(UploadOperation_get_CostPolicy), reinterpret_cast<setter>(UploadOperation_put_CostPolicy), nullptr, nullptr },
        { "group", reinterpret_cast<getter>(UploadOperation_get_Group), nullptr, nullptr, nullptr },
        { "guid", reinterpret_cast<getter>(UploadOperation_get_Guid), nullptr, nullptr, nullptr },
        { "method", reinterpret_cast<getter>(UploadOperation_get_Method), nullptr, nullptr, nullptr },
        { "requested_uri", reinterpret_cast<getter>(UploadOperation_get_RequestedUri), nullptr, nullptr, nullptr },
        { "priority", reinterpret_cast<getter>(UploadOperation_get_Priority), reinterpret_cast<setter>(UploadOperation_put_Priority), nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(UploadOperation_get_Progress), nullptr, nullptr, nullptr },
        { "source_file", reinterpret_cast<getter>(UploadOperation_get_SourceFile), nullptr, nullptr, nullptr },
        { "transfer_group", reinterpret_cast<getter>(UploadOperation_get_TransferGroup), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UploadOperation[] = 
    {
        { Py_tp_new, _new_UploadOperation },
        { Py_tp_dealloc, _dealloc_UploadOperation },
        { Py_tp_methods, _methods_UploadOperation },
        { Py_tp_getset, _getset_UploadOperation },
        { },
    };

    static PyType_Spec type_spec_UploadOperation =
    {
        "_winsdk_Windows_Networking_BackgroundTransfer.UploadOperation",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::UploadOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UploadOperation
    };

    // ----- IBackgroundTransferBase interface --------------------
    constexpr const char* const type_name_IBackgroundTransferBase = "IBackgroundTransferBase";

    static PyObject* _new_IBackgroundTransferBase(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IBackgroundTransferBase);
        return nullptr;
    }

    static void _dealloc_IBackgroundTransferBase(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTransferBase_SetRequestHeader(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferBase_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferBase_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTransferBase_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferBase_put_Group(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Group(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTransferBase_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferBase_put_Method(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Method(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTransferBase_get_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferBase_put_ProxyCredential(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTransferBase_get_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferBase_put_ServerCredential(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IBackgroundTransferBase(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTransferBase[] = {
        { "set_request_header", reinterpret_cast<PyCFunction>(IBackgroundTransferBase_SetRequestHeader), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTransferBase), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTransferBase[] = {
        { "cost_policy", reinterpret_cast<getter>(IBackgroundTransferBase_get_CostPolicy), reinterpret_cast<setter>(IBackgroundTransferBase_put_CostPolicy), nullptr, nullptr },
        { "group", reinterpret_cast<getter>(IBackgroundTransferBase_get_Group), reinterpret_cast<setter>(IBackgroundTransferBase_put_Group), nullptr, nullptr },
        { "method", reinterpret_cast<getter>(IBackgroundTransferBase_get_Method), reinterpret_cast<setter>(IBackgroundTransferBase_put_Method), nullptr, nullptr },
        { "proxy_credential", reinterpret_cast<getter>(IBackgroundTransferBase_get_ProxyCredential), reinterpret_cast<setter>(IBackgroundTransferBase_put_ProxyCredential), nullptr, nullptr },
        { "server_credential", reinterpret_cast<getter>(IBackgroundTransferBase_get_ServerCredential), reinterpret_cast<setter>(IBackgroundTransferBase_put_ServerCredential), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTransferBase[] = 
    {
        { Py_tp_new, _new_IBackgroundTransferBase },
        { Py_tp_dealloc, _dealloc_IBackgroundTransferBase },
        { Py_tp_methods, _methods_IBackgroundTransferBase },
        { Py_tp_getset, _getset_IBackgroundTransferBase },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTransferBase =
    {
        "_winsdk_Windows_Networking_BackgroundTransfer.IBackgroundTransferBase",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTransferBase
    };

    // ----- IBackgroundTransferContentPartFactory interface --------------------
    constexpr const char* const type_name_IBackgroundTransferContentPartFactory = "IBackgroundTransferContentPartFactory";

    static PyObject* _new_IBackgroundTransferContentPartFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IBackgroundTransferContentPartFactory);
        return nullptr;
    }

    static void _dealloc_IBackgroundTransferContentPartFactory(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTransferContentPartFactory_CreateWithName(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateWithName(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferContentPartFactory_CreateWithNameAndFileName(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CreateWithNameAndFileName(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IBackgroundTransferContentPartFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTransferContentPartFactory[] = {
        { "create_with_name", reinterpret_cast<PyCFunction>(IBackgroundTransferContentPartFactory_CreateWithName), METH_VARARGS, nullptr },
        { "create_with_name_and_file_name", reinterpret_cast<PyCFunction>(IBackgroundTransferContentPartFactory_CreateWithNameAndFileName), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTransferContentPartFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTransferContentPartFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTransferContentPartFactory[] = 
    {
        { Py_tp_new, _new_IBackgroundTransferContentPartFactory },
        { Py_tp_dealloc, _dealloc_IBackgroundTransferContentPartFactory },
        { Py_tp_methods, _methods_IBackgroundTransferContentPartFactory },
        { Py_tp_getset, _getset_IBackgroundTransferContentPartFactory },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTransferContentPartFactory =
    {
        "_winsdk_Windows_Networking_BackgroundTransfer.IBackgroundTransferContentPartFactory",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTransferContentPartFactory
    };

    // ----- IBackgroundTransferOperation interface --------------------
    constexpr const char* const type_name_IBackgroundTransferOperation = "IBackgroundTransferOperation";

    static PyObject* _new_IBackgroundTransferOperation(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IBackgroundTransferOperation);
        return nullptr;
    }

    static void _dealloc_IBackgroundTransferOperation(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTransferOperation_GetResponseInformation(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetResponseInformation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferOperation_GetResultStreamAt(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetResultStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferOperation_get_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CostPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferOperation_put_CostPolicy(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>(arg);

            self->obj.CostPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IBackgroundTransferOperation_get_Group(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferOperation_get_Guid(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Guid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferOperation_get_Method(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Method());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBackgroundTransferOperation_get_RequestedUri(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestedUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IBackgroundTransferOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTransferOperation[] = {
        { "get_response_information", reinterpret_cast<PyCFunction>(IBackgroundTransferOperation_GetResponseInformation), METH_VARARGS, nullptr },
        { "get_result_stream_at", reinterpret_cast<PyCFunction>(IBackgroundTransferOperation_GetResultStreamAt), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTransferOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTransferOperation[] = {
        { "cost_policy", reinterpret_cast<getter>(IBackgroundTransferOperation_get_CostPolicy), reinterpret_cast<setter>(IBackgroundTransferOperation_put_CostPolicy), nullptr, nullptr },
        { "group", reinterpret_cast<getter>(IBackgroundTransferOperation_get_Group), nullptr, nullptr, nullptr },
        { "guid", reinterpret_cast<getter>(IBackgroundTransferOperation_get_Guid), nullptr, nullptr, nullptr },
        { "method", reinterpret_cast<getter>(IBackgroundTransferOperation_get_Method), nullptr, nullptr, nullptr },
        { "requested_uri", reinterpret_cast<getter>(IBackgroundTransferOperation_get_RequestedUri), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTransferOperation[] = 
    {
        { Py_tp_new, _new_IBackgroundTransferOperation },
        { Py_tp_dealloc, _dealloc_IBackgroundTransferOperation },
        { Py_tp_methods, _methods_IBackgroundTransferOperation },
        { Py_tp_getset, _getset_IBackgroundTransferOperation },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTransferOperation =
    {
        "_winsdk_Windows_Networking_BackgroundTransfer.IBackgroundTransferOperation",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTransferOperation
    };

    // ----- IBackgroundTransferOperationPriority interface --------------------
    constexpr const char* const type_name_IBackgroundTransferOperationPriority = "IBackgroundTransferOperationPriority";

    static PyObject* _new_IBackgroundTransferOperationPriority(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IBackgroundTransferOperationPriority);
        return nullptr;
    }

    static void _dealloc_IBackgroundTransferOperationPriority(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundTransferOperationPriority_get_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Priority());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IBackgroundTransferOperationPriority_put_Priority(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferPriority>(arg);

            self->obj.Priority(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IBackgroundTransferOperationPriority(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundTransferOperationPriority[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundTransferOperationPriority), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundTransferOperationPriority[] = {
        { "priority", reinterpret_cast<getter>(IBackgroundTransferOperationPriority_get_Priority), reinterpret_cast<setter>(IBackgroundTransferOperationPriority_put_Priority), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundTransferOperationPriority[] = 
    {
        { Py_tp_new, _new_IBackgroundTransferOperationPriority },
        { Py_tp_dealloc, _dealloc_IBackgroundTransferOperationPriority },
        { Py_tp_methods, _methods_IBackgroundTransferOperationPriority },
        { Py_tp_getset, _getset_IBackgroundTransferOperationPriority },
        { },
    };

    static PyType_Spec type_spec_IBackgroundTransferOperationPriority =
    {
        "_winsdk_Windows_Networking_BackgroundTransfer.IBackgroundTransferOperationPriority",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundTransferOperationPriority
    };

    // ----- BackgroundDownloadProgress struct --------------------
    constexpr const char* const type_name_BackgroundDownloadProgress = "BackgroundDownloadProgress";

    PyObject* _new_BackgroundDownloadProgress(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        uint64_t _BytesReceived{};
        uint64_t _TotalBytesToReceive{};
        int32_t _Status{};
        bool _HasResponseChanged{};
        bool _HasRestarted{};

        static const char* kwlist[] = {"bytes_received", "total_bytes_to_receive", "status", "has_response_changed", "has_restarted", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KKipp", const_cast<char**>(kwlist), &_BytesReceived, &_TotalBytesToReceive, &_Status, &_HasResponseChanged, &_HasRestarted))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress return_value{ _BytesReceived, _TotalBytesToReceive, static_cast<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferStatus>(_Status), _HasResponseChanged, _HasRestarted };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_BackgroundDownloadProgress(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self)
    {
    }

    static PyObject* BackgroundDownloadProgress_get_BytesReceived(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReceived);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloadProgress_set_BytesReceived(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.BytesReceived = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloadProgress_get_TotalBytesToReceive(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalBytesToReceive);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloadProgress_set_TotalBytesToReceive(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.TotalBytesToReceive = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloadProgress_get_Status(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloadProgress_set_Status(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Status = py::converter<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferStatus>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloadProgress_get_HasResponseChanged(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasResponseChanged);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloadProgress_set_HasResponseChanged(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.HasResponseChanged = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundDownloadProgress_get_HasRestarted(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasRestarted);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundDownloadProgress_set_HasRestarted(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.HasRestarted = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BackgroundDownloadProgress[] = {
        { "bytes_received", reinterpret_cast<getter>(BackgroundDownloadProgress_get_BytesReceived), reinterpret_cast<setter>(BackgroundDownloadProgress_set_BytesReceived), nullptr, nullptr },
        { "total_bytes_to_receive", reinterpret_cast<getter>(BackgroundDownloadProgress_get_TotalBytesToReceive), reinterpret_cast<setter>(BackgroundDownloadProgress_set_TotalBytesToReceive), nullptr, nullptr },
        { "status", reinterpret_cast<getter>(BackgroundDownloadProgress_get_Status), reinterpret_cast<setter>(BackgroundDownloadProgress_set_Status), nullptr, nullptr },
        { "has_response_changed", reinterpret_cast<getter>(BackgroundDownloadProgress_get_HasResponseChanged), reinterpret_cast<setter>(BackgroundDownloadProgress_set_HasResponseChanged), nullptr, nullptr },
        { "has_restarted", reinterpret_cast<getter>(BackgroundDownloadProgress_get_HasRestarted), reinterpret_cast<setter>(BackgroundDownloadProgress_set_HasRestarted), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundDownloadProgress[] = 
    {
        { Py_tp_new, _new_BackgroundDownloadProgress },
        { Py_tp_dealloc, _dealloc_BackgroundDownloadProgress },
        { Py_tp_getset, _getset_BackgroundDownloadProgress },
        { },
    };

    static PyType_Spec type_spec_BackgroundDownloadProgress =
    {
        "_winsdk_Windows_Networking_BackgroundTransfer.BackgroundDownloadProgress",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundDownloadProgress
    };

    // ----- BackgroundTransferFileRange struct --------------------
    constexpr const char* const type_name_BackgroundTransferFileRange = "BackgroundTransferFileRange";

    PyObject* _new_BackgroundTransferFileRange(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        uint64_t _Offset{};
        uint64_t _Length{};

        static const char* kwlist[] = {"offset", "length", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KK", const_cast<char**>(kwlist), &_Offset, &_Length))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange return_value{ _Offset, _Length };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_BackgroundTransferFileRange(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange* self)
    {
    }

    static PyObject* BackgroundTransferFileRange_get_Offset(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Offset);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTransferFileRange_set_Offset(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Offset = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundTransferFileRange_get_Length(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundTransferFileRange_set_Length(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Length = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BackgroundTransferFileRange[] = {
        { "offset", reinterpret_cast<getter>(BackgroundTransferFileRange_get_Offset), reinterpret_cast<setter>(BackgroundTransferFileRange_set_Offset), nullptr, nullptr },
        { "length", reinterpret_cast<getter>(BackgroundTransferFileRange_get_Length), reinterpret_cast<setter>(BackgroundTransferFileRange_set_Length), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundTransferFileRange[] = 
    {
        { Py_tp_new, _new_BackgroundTransferFileRange },
        { Py_tp_dealloc, _dealloc_BackgroundTransferFileRange },
        { Py_tp_getset, _getset_BackgroundTransferFileRange },
        { },
    };

    static PyType_Spec type_spec_BackgroundTransferFileRange =
    {
        "_winsdk_Windows_Networking_BackgroundTransfer.BackgroundTransferFileRange",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundTransferFileRange
    };

    // ----- BackgroundUploadProgress struct --------------------
    constexpr const char* const type_name_BackgroundUploadProgress = "BackgroundUploadProgress";

    PyObject* _new_BackgroundUploadProgress(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        uint64_t _BytesReceived{};
        uint64_t _BytesSent{};
        uint64_t _TotalBytesToReceive{};
        uint64_t _TotalBytesToSend{};
        int32_t _Status{};
        bool _HasResponseChanged{};
        bool _HasRestarted{};

        static const char* kwlist[] = {"bytes_received", "bytes_sent", "total_bytes_to_receive", "total_bytes_to_send", "status", "has_response_changed", "has_restarted", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KKKKipp", const_cast<char**>(kwlist), &_BytesReceived, &_BytesSent, &_TotalBytesToReceive, &_TotalBytesToSend, &_Status, &_HasResponseChanged, &_HasRestarted))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress return_value{ _BytesReceived, _BytesSent, _TotalBytesToReceive, _TotalBytesToSend, static_cast<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferStatus>(_Status), _HasResponseChanged, _HasRestarted };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_BackgroundUploadProgress(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self)
    {
    }

    static PyObject* BackgroundUploadProgress_get_BytesReceived(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReceived);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_BytesReceived(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.BytesReceived = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_BytesSent(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesSent);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_BytesSent(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.BytesSent = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_TotalBytesToReceive(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalBytesToReceive);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_TotalBytesToReceive(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.TotalBytesToReceive = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_TotalBytesToSend(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalBytesToSend);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_TotalBytesToSend(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.TotalBytesToSend = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_Status(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_Status(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Status = py::converter<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferStatus>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_HasResponseChanged(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasResponseChanged);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_HasResponseChanged(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.HasResponseChanged = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BackgroundUploadProgress_get_HasRestarted(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasRestarted);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BackgroundUploadProgress_set_HasRestarted(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.HasRestarted = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BackgroundUploadProgress[] = {
        { "bytes_received", reinterpret_cast<getter>(BackgroundUploadProgress_get_BytesReceived), reinterpret_cast<setter>(BackgroundUploadProgress_set_BytesReceived), nullptr, nullptr },
        { "bytes_sent", reinterpret_cast<getter>(BackgroundUploadProgress_get_BytesSent), reinterpret_cast<setter>(BackgroundUploadProgress_set_BytesSent), nullptr, nullptr },
        { "total_bytes_to_receive", reinterpret_cast<getter>(BackgroundUploadProgress_get_TotalBytesToReceive), reinterpret_cast<setter>(BackgroundUploadProgress_set_TotalBytesToReceive), nullptr, nullptr },
        { "total_bytes_to_send", reinterpret_cast<getter>(BackgroundUploadProgress_get_TotalBytesToSend), reinterpret_cast<setter>(BackgroundUploadProgress_set_TotalBytesToSend), nullptr, nullptr },
        { "status", reinterpret_cast<getter>(BackgroundUploadProgress_get_Status), reinterpret_cast<setter>(BackgroundUploadProgress_set_Status), nullptr, nullptr },
        { "has_response_changed", reinterpret_cast<getter>(BackgroundUploadProgress_get_HasResponseChanged), reinterpret_cast<setter>(BackgroundUploadProgress_set_HasResponseChanged), nullptr, nullptr },
        { "has_restarted", reinterpret_cast<getter>(BackgroundUploadProgress_get_HasRestarted), reinterpret_cast<setter>(BackgroundUploadProgress_set_HasRestarted), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundUploadProgress[] = 
    {
        { Py_tp_new, _new_BackgroundUploadProgress },
        { Py_tp_dealloc, _dealloc_BackgroundUploadProgress },
        { Py_tp_getset, _getset_BackgroundUploadProgress },
        { },
    };

    static PyType_Spec type_spec_BackgroundUploadProgress =
    {
        "_winsdk_Windows_Networking_BackgroundTransfer.BackgroundUploadProgress",
        sizeof(py::wrapper::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundUploadProgress
    };

    // ----- Windows.Networking.BackgroundTransfer Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Networking::BackgroundTransfer");

    static PyMethodDef module_methods[] = {
        {"_register_BackgroundTransferBehavior", register_BackgroundTransferBehavior, METH_O, "registers type"},
        {"_register_BackgroundTransferCostPolicy", register_BackgroundTransferCostPolicy, METH_O, "registers type"},
        {"_register_BackgroundTransferPriority", register_BackgroundTransferPriority, METH_O, "registers type"},
        {"_register_BackgroundTransferStatus", register_BackgroundTransferStatus, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_BackgroundTransferBehavior);
        Py_VISIT(state->type_BackgroundTransferCostPolicy);
        Py_VISIT(state->type_BackgroundTransferPriority);
        Py_VISIT(state->type_BackgroundTransferStatus);
        Py_VISIT(state->type_BackgroundDownloader);
        Py_VISIT(state->type_BackgroundTransferCompletionGroup);
        Py_VISIT(state->type_BackgroundTransferCompletionGroupTriggerDetails);
        Py_VISIT(state->type_BackgroundTransferContentPart);
        Py_VISIT(state->type_BackgroundTransferError);
        Py_VISIT(state->type_BackgroundTransferGroup);
        Py_VISIT(state->type_BackgroundTransferRangesDownloadedEventArgs);
        Py_VISIT(state->type_BackgroundUploader);
        Py_VISIT(state->type_ContentPrefetcher);
        Py_VISIT(state->type_DownloadOperation);
        Py_VISIT(state->type_ResponseInformation);
        Py_VISIT(state->type_UnconstrainedTransferRequestResult);
        Py_VISIT(state->type_UploadOperation);
        Py_VISIT(state->type_IBackgroundTransferBase);
        Py_VISIT(state->type_IBackgroundTransferContentPartFactory);
        Py_VISIT(state->type_IBackgroundTransferOperation);
        Py_VISIT(state->type_IBackgroundTransferOperationPriority);
        Py_VISIT(state->type_BackgroundDownloadProgress);
        Py_VISIT(state->type_BackgroundTransferFileRange);
        Py_VISIT(state->type_BackgroundUploadProgress);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_BackgroundTransferBehavior);
        Py_CLEAR(state->type_BackgroundTransferCostPolicy);
        Py_CLEAR(state->type_BackgroundTransferPriority);
        Py_CLEAR(state->type_BackgroundTransferStatus);
        Py_CLEAR(state->type_BackgroundDownloader);
        Py_CLEAR(state->type_BackgroundTransferCompletionGroup);
        Py_CLEAR(state->type_BackgroundTransferCompletionGroupTriggerDetails);
        Py_CLEAR(state->type_BackgroundTransferContentPart);
        Py_CLEAR(state->type_BackgroundTransferError);
        Py_CLEAR(state->type_BackgroundTransferGroup);
        Py_CLEAR(state->type_BackgroundTransferRangesDownloadedEventArgs);
        Py_CLEAR(state->type_BackgroundUploader);
        Py_CLEAR(state->type_ContentPrefetcher);
        Py_CLEAR(state->type_DownloadOperation);
        Py_CLEAR(state->type_ResponseInformation);
        Py_CLEAR(state->type_UnconstrainedTransferRequestResult);
        Py_CLEAR(state->type_UploadOperation);
        Py_CLEAR(state->type_IBackgroundTransferBase);
        Py_CLEAR(state->type_IBackgroundTransferContentPartFactory);
        Py_CLEAR(state->type_IBackgroundTransferOperation);
        Py_CLEAR(state->type_IBackgroundTransferOperationPriority);
        Py_CLEAR(state->type_BackgroundDownloadProgress);
        Py_CLEAR(state->type_BackgroundTransferFileRange);
        Py_CLEAR(state->type_BackgroundUploadProgress);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Networking_BackgroundTransfer",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Networking::BackgroundTransfer

PyMODINIT_FUNC PyInit__winsdk_Windows_Networking_BackgroundTransfer(void) noexcept
{
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_BackgroundDownloader = py::register_python_type(module.get(), type_name_BackgroundDownloader, &type_spec_BackgroundDownloader, bases.get());
    if (!state->type_BackgroundDownloader)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BackgroundDownloader);

    state->type_BackgroundTransferCompletionGroup = py::register_python_type(module.get(), type_name_BackgroundTransferCompletionGroup, &type_spec_BackgroundTransferCompletionGroup, bases.get());
    if (!state->type_BackgroundTransferCompletionGroup)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BackgroundTransferCompletionGroup);

    state->type_BackgroundTransferCompletionGroupTriggerDetails = py::register_python_type(module.get(), type_name_BackgroundTransferCompletionGroupTriggerDetails, &type_spec_BackgroundTransferCompletionGroupTriggerDetails, bases.get());
    if (!state->type_BackgroundTransferCompletionGroupTriggerDetails)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BackgroundTransferCompletionGroupTriggerDetails);

    state->type_BackgroundTransferContentPart = py::register_python_type(module.get(), type_name_BackgroundTransferContentPart, &type_spec_BackgroundTransferContentPart, bases.get());
    if (!state->type_BackgroundTransferContentPart)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BackgroundTransferContentPart);

    state->type_BackgroundTransferError = py::register_python_type(module.get(), type_name_BackgroundTransferError, &type_spec_BackgroundTransferError, nullptr);
    if (!state->type_BackgroundTransferError)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BackgroundTransferError);

    state->type_BackgroundTransferGroup = py::register_python_type(module.get(), type_name_BackgroundTransferGroup, &type_spec_BackgroundTransferGroup, bases.get());
    if (!state->type_BackgroundTransferGroup)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BackgroundTransferGroup);

    state->type_BackgroundTransferRangesDownloadedEventArgs = py::register_python_type(module.get(), type_name_BackgroundTransferRangesDownloadedEventArgs, &type_spec_BackgroundTransferRangesDownloadedEventArgs, bases.get());
    if (!state->type_BackgroundTransferRangesDownloadedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BackgroundTransferRangesDownloadedEventArgs);

    state->type_BackgroundUploader = py::register_python_type(module.get(), type_name_BackgroundUploader, &type_spec_BackgroundUploader, bases.get());
    if (!state->type_BackgroundUploader)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BackgroundUploader);

    state->type_ContentPrefetcher = py::register_python_type(module.get(), type_name_ContentPrefetcher, &type_spec_ContentPrefetcher, nullptr);
    if (!state->type_ContentPrefetcher)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ContentPrefetcher);

    state->type_DownloadOperation = py::register_python_type(module.get(), type_name_DownloadOperation, &type_spec_DownloadOperation, bases.get());
    if (!state->type_DownloadOperation)
    {
        return nullptr;
    }

    Py_INCREF(state->type_DownloadOperation);

    state->type_ResponseInformation = py::register_python_type(module.get(), type_name_ResponseInformation, &type_spec_ResponseInformation, bases.get());
    if (!state->type_ResponseInformation)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ResponseInformation);

    state->type_UnconstrainedTransferRequestResult = py::register_python_type(module.get(), type_name_UnconstrainedTransferRequestResult, &type_spec_UnconstrainedTransferRequestResult, bases.get());
    if (!state->type_UnconstrainedTransferRequestResult)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UnconstrainedTransferRequestResult);

    state->type_UploadOperation = py::register_python_type(module.get(), type_name_UploadOperation, &type_spec_UploadOperation, bases.get());
    if (!state->type_UploadOperation)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UploadOperation);

    state->type_IBackgroundTransferBase = py::register_python_type(module.get(), type_name_IBackgroundTransferBase, &type_spec_IBackgroundTransferBase, bases.get());
    if (!state->type_IBackgroundTransferBase)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IBackgroundTransferBase);

    state->type_IBackgroundTransferContentPartFactory = py::register_python_type(module.get(), type_name_IBackgroundTransferContentPartFactory, &type_spec_IBackgroundTransferContentPartFactory, bases.get());
    if (!state->type_IBackgroundTransferContentPartFactory)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IBackgroundTransferContentPartFactory);

    state->type_IBackgroundTransferOperation = py::register_python_type(module.get(), type_name_IBackgroundTransferOperation, &type_spec_IBackgroundTransferOperation, bases.get());
    if (!state->type_IBackgroundTransferOperation)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IBackgroundTransferOperation);

    state->type_IBackgroundTransferOperationPriority = py::register_python_type(module.get(), type_name_IBackgroundTransferOperationPriority, &type_spec_IBackgroundTransferOperationPriority, bases.get());
    if (!state->type_IBackgroundTransferOperationPriority)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IBackgroundTransferOperationPriority);

    state->type_BackgroundDownloadProgress = py::register_python_type(module.get(), type_name_BackgroundDownloadProgress, &type_spec_BackgroundDownloadProgress, bases.get());
    if (!state->type_BackgroundDownloadProgress)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BackgroundDownloadProgress);

    state->type_BackgroundTransferFileRange = py::register_python_type(module.get(), type_name_BackgroundTransferFileRange, &type_spec_BackgroundTransferFileRange, bases.get());
    if (!state->type_BackgroundTransferFileRange)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BackgroundTransferFileRange);

    state->type_BackgroundUploadProgress = py::register_python_type(module.get(), type_name_BackgroundUploadProgress, &type_spec_BackgroundUploadProgress, bases.get());
    if (!state->type_BackgroundUploadProgress)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BackgroundUploadProgress);


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferBehavior>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundTransferBehavior;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferBehavior is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundTransferCostPolicy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCostPolicy is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferPriority>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundTransferPriority;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferPriority is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundTransferStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundDownloader;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloader is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundTransferCompletionGroup;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroup is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundTransferCompletionGroupTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferCompletionGroupTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundTransferContentPart;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferContentPart is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferError>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundTransferError;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferError is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundTransferGroup;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferGroup is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundTransferRangesDownloadedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferRangesDownloadedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundUploader;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::BackgroundUploader is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContentPrefetcher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::ContentPrefetcher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DownloadOperation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::DownloadOperation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::ResponseInformation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ResponseInformation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::ResponseInformation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UnconstrainedTransferRequestResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::UnconstrainedTransferRequestResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::UploadOperation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UploadOperation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::UploadOperation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IBackgroundTransferBase;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferBase is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IBackgroundTransferContentPartFactory;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferContentPartFactory is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IBackgroundTransferOperation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IBackgroundTransferOperationPriority;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::IBackgroundTransferOperationPriority is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundDownloadProgress;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::BackgroundDownloadProgress is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundTransferFileRange;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::BackgroundTransferFileRange is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::BackgroundTransfer;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::BackgroundTransfer");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundUploadProgress;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::BackgroundTransfer::BackgroundUploadProgress is not registered");
        return nullptr;
    }

    return python_type;
}
