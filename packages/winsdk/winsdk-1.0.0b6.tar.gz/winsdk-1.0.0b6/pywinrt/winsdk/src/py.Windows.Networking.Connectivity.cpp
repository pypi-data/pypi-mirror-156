// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.6

#include "pybase.h"
#include "py.Windows.Networking.Connectivity.h"


PyObject* py::converter<winrt::Windows::Networking::Connectivity::NetworkUsageStates>::convert(winrt::Windows::Networking::Connectivity::NetworkUsageStates instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Networking::Connectivity::NetworkUsageStates>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Networking::Connectivity::NetworkUsageStates py::converter<winrt::Windows::Networking::Connectivity::NetworkUsageStates>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Networking::Connectivity::NetworkUsageStates>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Networking::Connectivity::NetworkUsageStates>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Networking::Connectivity::NetworkUsageStates");
    throw python_exception();
}

namespace py::cpp::Windows::Networking::Connectivity
{
    struct module_state
    {
        PyObject* type_CellularApnAuthenticationType;
        PyObject* type_ConnectionProfileDeleteStatus;
        PyObject* type_DataUsageGranularity;
        PyObject* type_DomainAuthenticationKind;
        PyObject* type_DomainConnectivityLevel;
        PyObject* type_NetworkAuthenticationType;
        PyObject* type_NetworkConnectivityLevel;
        PyObject* type_NetworkCostType;
        PyObject* type_NetworkEncryptionType;
        PyObject* type_NetworkTypes;
        PyObject* type_RoamingStates;
        PyObject* type_TriStates;
        PyObject* type_WwanDataClass;
        PyObject* type_WwanNetworkIPKind;
        PyObject* type_WwanNetworkRegistrationState;
        PyTypeObject* type_AttributedNetworkUsage;
        PyTypeObject* type_CellularApnContext;
        PyTypeObject* type_ConnectionCost;
        PyTypeObject* type_ConnectionProfile;
        PyTypeObject* type_ConnectionProfileFilter;
        PyTypeObject* type_ConnectionSession;
        PyTypeObject* type_ConnectivityInterval;
        PyTypeObject* type_ConnectivityManager;
        PyTypeObject* type_DataPlanStatus;
        PyTypeObject* type_DataPlanUsage;
        PyTypeObject* type_DataUsage;
        PyTypeObject* type_IPInformation;
        PyTypeObject* type_LanIdentifier;
        PyTypeObject* type_LanIdentifierData;
        PyTypeObject* type_NetworkAdapter;
        PyTypeObject* type_NetworkInformation;
        PyTypeObject* type_NetworkItem;
        PyTypeObject* type_NetworkSecuritySettings;
        PyTypeObject* type_NetworkStateChangeEventDetails;
        PyTypeObject* type_NetworkUsage;
        PyTypeObject* type_ProviderNetworkUsage;
        PyTypeObject* type_ProxyConfiguration;
        PyTypeObject* type_RoutePolicy;
        PyTypeObject* type_WlanConnectionProfileDetails;
        PyTypeObject* type_WwanConnectionProfileDetails;
        PyTypeObject* type_NetworkUsageStates;
    };

    static PyObject* register_CellularApnAuthenticationType(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CellularApnAuthenticationType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CellularApnAuthenticationType = type;
        Py_INCREF(state->type_CellularApnAuthenticationType);


        Py_RETURN_NONE;
    }

    static PyObject* register_ConnectionProfileDeleteStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ConnectionProfileDeleteStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ConnectionProfileDeleteStatus = type;
        Py_INCREF(state->type_ConnectionProfileDeleteStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_DataUsageGranularity(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DataUsageGranularity)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DataUsageGranularity = type;
        Py_INCREF(state->type_DataUsageGranularity);


        Py_RETURN_NONE;
    }

    static PyObject* register_DomainAuthenticationKind(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DomainAuthenticationKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DomainAuthenticationKind = type;
        Py_INCREF(state->type_DomainAuthenticationKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_DomainConnectivityLevel(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DomainConnectivityLevel)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DomainConnectivityLevel = type;
        Py_INCREF(state->type_DomainConnectivityLevel);


        Py_RETURN_NONE;
    }

    static PyObject* register_NetworkAuthenticationType(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_NetworkAuthenticationType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_NetworkAuthenticationType = type;
        Py_INCREF(state->type_NetworkAuthenticationType);


        Py_RETURN_NONE;
    }

    static PyObject* register_NetworkConnectivityLevel(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_NetworkConnectivityLevel)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_NetworkConnectivityLevel = type;
        Py_INCREF(state->type_NetworkConnectivityLevel);


        Py_RETURN_NONE;
    }

    static PyObject* register_NetworkCostType(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_NetworkCostType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_NetworkCostType = type;
        Py_INCREF(state->type_NetworkCostType);


        Py_RETURN_NONE;
    }

    static PyObject* register_NetworkEncryptionType(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_NetworkEncryptionType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_NetworkEncryptionType = type;
        Py_INCREF(state->type_NetworkEncryptionType);


        Py_RETURN_NONE;
    }

    static PyObject* register_NetworkTypes(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_NetworkTypes)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_NetworkTypes = type;
        Py_INCREF(state->type_NetworkTypes);


        Py_RETURN_NONE;
    }

    static PyObject* register_RoamingStates(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_RoamingStates)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_RoamingStates = type;
        Py_INCREF(state->type_RoamingStates);


        Py_RETURN_NONE;
    }

    static PyObject* register_TriStates(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TriStates)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TriStates = type;
        Py_INCREF(state->type_TriStates);


        Py_RETURN_NONE;
    }

    static PyObject* register_WwanDataClass(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_WwanDataClass)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_WwanDataClass = type;
        Py_INCREF(state->type_WwanDataClass);


        Py_RETURN_NONE;
    }

    static PyObject* register_WwanNetworkIPKind(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_WwanNetworkIPKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_WwanNetworkIPKind = type;
        Py_INCREF(state->type_WwanNetworkIPKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_WwanNetworkRegistrationState(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_WwanNetworkRegistrationState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_WwanNetworkRegistrationState = type;
        Py_INCREF(state->type_WwanNetworkRegistrationState);


        Py_RETURN_NONE;
    }

    // ----- AttributedNetworkUsage class --------------------
    constexpr const char* const type_name_AttributedNetworkUsage = "AttributedNetworkUsage";

    static PyObject* _new_AttributedNetworkUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AttributedNetworkUsage);
        return nullptr;
    }

    static void _dealloc_AttributedNetworkUsage(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AttributedNetworkUsage_get_AttributionId(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AttributionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AttributedNetworkUsage_get_AttributionName(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AttributionName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AttributedNetworkUsage_get_AttributionThumbnail(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AttributionThumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AttributedNetworkUsage_get_BytesReceived(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AttributedNetworkUsage_get_BytesSent(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesSent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AttributedNetworkUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::AttributedNetworkUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AttributedNetworkUsage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AttributedNetworkUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AttributedNetworkUsage[] = {
        { "attribution_id", reinterpret_cast<getter>(AttributedNetworkUsage_get_AttributionId), nullptr, nullptr, nullptr },
        { "attribution_name", reinterpret_cast<getter>(AttributedNetworkUsage_get_AttributionName), nullptr, nullptr, nullptr },
        { "attribution_thumbnail", reinterpret_cast<getter>(AttributedNetworkUsage_get_AttributionThumbnail), nullptr, nullptr, nullptr },
        { "bytes_received", reinterpret_cast<getter>(AttributedNetworkUsage_get_BytesReceived), nullptr, nullptr, nullptr },
        { "bytes_sent", reinterpret_cast<getter>(AttributedNetworkUsage_get_BytesSent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AttributedNetworkUsage[] = 
    {
        { Py_tp_new, _new_AttributedNetworkUsage },
        { Py_tp_dealloc, _dealloc_AttributedNetworkUsage },
        { Py_tp_methods, _methods_AttributedNetworkUsage },
        { Py_tp_getset, _getset_AttributedNetworkUsage },
        { },
    };

    static PyType_Spec type_spec_AttributedNetworkUsage =
    {
        "_winsdk_Windows_Networking_Connectivity.AttributedNetworkUsage",
        sizeof(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AttributedNetworkUsage
    };

    // ----- CellularApnContext class --------------------
    constexpr const char* const type_name_CellularApnContext = "CellularApnContext";

    static PyObject* _new_CellularApnContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Connectivity::CellularApnContext instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CellularApnContext(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CellularApnContext_get_UserName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_UserName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.UserName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_ProviderId(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_ProviderId(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ProviderId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_Password(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Password());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_Password(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Password(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_IsCompressionEnabled(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCompressionEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_IsCompressionEnabled(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCompressionEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_AuthenticationType(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AuthenticationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_AuthenticationType(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::CellularApnAuthenticationType>(arg);

            self->obj.AuthenticationType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_AccessPointName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AccessPointName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_AccessPointName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AccessPointName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_ProfileName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProfileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_ProfileName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ProfileName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_CellularApnContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::CellularApnContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CellularApnContext[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CellularApnContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CellularApnContext[] = {
        { "user_name", reinterpret_cast<getter>(CellularApnContext_get_UserName), reinterpret_cast<setter>(CellularApnContext_put_UserName), nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(CellularApnContext_get_ProviderId), reinterpret_cast<setter>(CellularApnContext_put_ProviderId), nullptr, nullptr },
        { "password", reinterpret_cast<getter>(CellularApnContext_get_Password), reinterpret_cast<setter>(CellularApnContext_put_Password), nullptr, nullptr },
        { "is_compression_enabled", reinterpret_cast<getter>(CellularApnContext_get_IsCompressionEnabled), reinterpret_cast<setter>(CellularApnContext_put_IsCompressionEnabled), nullptr, nullptr },
        { "authentication_type", reinterpret_cast<getter>(CellularApnContext_get_AuthenticationType), reinterpret_cast<setter>(CellularApnContext_put_AuthenticationType), nullptr, nullptr },
        { "access_point_name", reinterpret_cast<getter>(CellularApnContext_get_AccessPointName), reinterpret_cast<setter>(CellularApnContext_put_AccessPointName), nullptr, nullptr },
        { "profile_name", reinterpret_cast<getter>(CellularApnContext_get_ProfileName), reinterpret_cast<setter>(CellularApnContext_put_ProfileName), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CellularApnContext[] = 
    {
        { Py_tp_new, _new_CellularApnContext },
        { Py_tp_dealloc, _dealloc_CellularApnContext },
        { Py_tp_methods, _methods_CellularApnContext },
        { Py_tp_getset, _getset_CellularApnContext },
        { },
    };

    static PyType_Spec type_spec_CellularApnContext =
    {
        "_winsdk_Windows_Networking_Connectivity.CellularApnContext",
        sizeof(py::wrapper::Windows::Networking::Connectivity::CellularApnContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CellularApnContext
    };

    // ----- ConnectionCost class --------------------
    constexpr const char* const type_name_ConnectionCost = "ConnectionCost";

    static PyObject* _new_ConnectionCost(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ConnectionCost);
        return nullptr;
    }

    static void _dealloc_ConnectionCost(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ConnectionCost_get_ApproachingDataLimit(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ApproachingDataLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionCost_get_NetworkCostType(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkCostType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionCost_get_OverDataLimit(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OverDataLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionCost_get_Roaming(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Roaming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionCost_get_BackgroundDataUsageRestricted(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BackgroundDataUsageRestricted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConnectionCost(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ConnectionCost>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectionCost[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ConnectionCost), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConnectionCost[] = {
        { "approaching_data_limit", reinterpret_cast<getter>(ConnectionCost_get_ApproachingDataLimit), nullptr, nullptr, nullptr },
        { "network_cost_type", reinterpret_cast<getter>(ConnectionCost_get_NetworkCostType), nullptr, nullptr, nullptr },
        { "over_data_limit", reinterpret_cast<getter>(ConnectionCost_get_OverDataLimit), nullptr, nullptr, nullptr },
        { "roaming", reinterpret_cast<getter>(ConnectionCost_get_Roaming), nullptr, nullptr, nullptr },
        { "background_data_usage_restricted", reinterpret_cast<getter>(ConnectionCost_get_BackgroundDataUsageRestricted), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConnectionCost[] = 
    {
        { Py_tp_new, _new_ConnectionCost },
        { Py_tp_dealloc, _dealloc_ConnectionCost },
        { Py_tp_methods, _methods_ConnectionCost },
        { Py_tp_getset, _getset_ConnectionCost },
        { },
    };

    static PyType_Spec type_spec_ConnectionCost =
    {
        "_winsdk_Windows_Networking_Connectivity.ConnectionCost",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ConnectionCost),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectionCost
    };

    // ----- ConnectionProfile class --------------------
    constexpr const char* const type_name_ConnectionProfile = "ConnectionProfile";

    static PyObject* _new_ConnectionProfile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ConnectionProfile);
        return nullptr;
    }

    static void _dealloc_ConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ConnectionProfile_GetAttributedNetworkUsageAsync(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkUsageStates>(args, 2);

                return py::convert(self->obj.GetAttributedNetworkUsageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetConnectionCost(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConnectionCost());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetConnectivityIntervalsAsync(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkUsageStates>(args, 2);

                return py::convert(self->obj.GetConnectivityIntervalsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetDataPlanStatus(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDataPlanStatus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetDomainConnectivityLevel(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDomainConnectivityLevel());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetLocalUsage(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                return py::convert(self->obj.GetLocalUsage(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::RoamingStates>(args, 2);

                return py::convert(self->obj.GetLocalUsage(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetNetworkConnectivityLevel(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetNetworkConnectivityLevel());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetNetworkNames(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetNetworkNames());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetNetworkUsageAsync(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::DataUsageGranularity>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkUsageStates>(args, 3);

                return py::convert(self->obj.GetNetworkUsageAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetProviderNetworkUsageAsync(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkUsageStates>(args, 2);

                return py::convert(self->obj.GetProviderNetworkUsageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetSignalBars(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSignalBars());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_IsDomainAuthenticatedBy(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::DomainAuthenticationKind>(args, 0);

                return py::convert(self->obj.IsDomainAuthenticatedBy(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_TryDeleteAsync(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryDeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_NetworkAdapter(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAdapter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_NetworkSecuritySettings(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkSecuritySettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_ProfileName(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProfileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_IsWlanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWlanConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_IsWwanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWwanConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_ServiceProviderGuid(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceProviderGuid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_WlanConnectionProfileDetails(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WlanConnectionProfileDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_WwanConnectionProfileDetails(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WwanConnectionProfileDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_CanDelete(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanDelete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConnectionProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ConnectionProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectionProfile[] = {
        { "get_attributed_network_usage_async", reinterpret_cast<PyCFunction>(ConnectionProfile_GetAttributedNetworkUsageAsync), METH_VARARGS, nullptr },
        { "get_connection_cost", reinterpret_cast<PyCFunction>(ConnectionProfile_GetConnectionCost), METH_VARARGS, nullptr },
        { "get_connectivity_intervals_async", reinterpret_cast<PyCFunction>(ConnectionProfile_GetConnectivityIntervalsAsync), METH_VARARGS, nullptr },
        { "get_data_plan_status", reinterpret_cast<PyCFunction>(ConnectionProfile_GetDataPlanStatus), METH_VARARGS, nullptr },
        { "get_domain_connectivity_level", reinterpret_cast<PyCFunction>(ConnectionProfile_GetDomainConnectivityLevel), METH_VARARGS, nullptr },
        { "get_local_usage", reinterpret_cast<PyCFunction>(ConnectionProfile_GetLocalUsage), METH_VARARGS, nullptr },
        { "get_network_connectivity_level", reinterpret_cast<PyCFunction>(ConnectionProfile_GetNetworkConnectivityLevel), METH_VARARGS, nullptr },
        { "get_network_names", reinterpret_cast<PyCFunction>(ConnectionProfile_GetNetworkNames), METH_VARARGS, nullptr },
        { "get_network_usage_async", reinterpret_cast<PyCFunction>(ConnectionProfile_GetNetworkUsageAsync), METH_VARARGS, nullptr },
        { "get_provider_network_usage_async", reinterpret_cast<PyCFunction>(ConnectionProfile_GetProviderNetworkUsageAsync), METH_VARARGS, nullptr },
        { "get_signal_bars", reinterpret_cast<PyCFunction>(ConnectionProfile_GetSignalBars), METH_VARARGS, nullptr },
        { "is_domain_authenticated_by", reinterpret_cast<PyCFunction>(ConnectionProfile_IsDomainAuthenticatedBy), METH_VARARGS, nullptr },
        { "try_delete_async", reinterpret_cast<PyCFunction>(ConnectionProfile_TryDeleteAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConnectionProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConnectionProfile[] = {
        { "network_adapter", reinterpret_cast<getter>(ConnectionProfile_get_NetworkAdapter), nullptr, nullptr, nullptr },
        { "network_security_settings", reinterpret_cast<getter>(ConnectionProfile_get_NetworkSecuritySettings), nullptr, nullptr, nullptr },
        { "profile_name", reinterpret_cast<getter>(ConnectionProfile_get_ProfileName), nullptr, nullptr, nullptr },
        { "is_wlan_connection_profile", reinterpret_cast<getter>(ConnectionProfile_get_IsWlanConnectionProfile), nullptr, nullptr, nullptr },
        { "is_wwan_connection_profile", reinterpret_cast<getter>(ConnectionProfile_get_IsWwanConnectionProfile), nullptr, nullptr, nullptr },
        { "service_provider_guid", reinterpret_cast<getter>(ConnectionProfile_get_ServiceProviderGuid), nullptr, nullptr, nullptr },
        { "wlan_connection_profile_details", reinterpret_cast<getter>(ConnectionProfile_get_WlanConnectionProfileDetails), nullptr, nullptr, nullptr },
        { "wwan_connection_profile_details", reinterpret_cast<getter>(ConnectionProfile_get_WwanConnectionProfileDetails), nullptr, nullptr, nullptr },
        { "can_delete", reinterpret_cast<getter>(ConnectionProfile_get_CanDelete), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConnectionProfile[] = 
    {
        { Py_tp_new, _new_ConnectionProfile },
        { Py_tp_dealloc, _dealloc_ConnectionProfile },
        { Py_tp_methods, _methods_ConnectionProfile },
        { Py_tp_getset, _getset_ConnectionProfile },
        { },
    };

    static PyType_Spec type_spec_ConnectionProfile =
    {
        "_winsdk_Windows_Networking_Connectivity.ConnectionProfile",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectionProfile
    };

    // ----- ConnectionProfileFilter class --------------------
    constexpr const char* const type_name_ConnectionProfileFilter = "ConnectionProfileFilter";

    static PyObject* _new_ConnectionProfileFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Connectivity::ConnectionProfileFilter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ConnectionProfileFilter(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ConnectionProfileFilter_get_ServiceProviderGuid(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceProviderGuid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_ServiceProviderGuid(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::guid>>(arg);

            self->obj.ServiceProviderGuid(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_NetworkCostType(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkCostType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_NetworkCostType(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkCostType>(arg);

            self->obj.NetworkCostType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsWwanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWwanConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsWwanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsWwanConnectionProfile(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsWlanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWlanConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsWlanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsWlanConnectionProfile(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsConnected(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsConnected(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsConnected(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsRoaming(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRoaming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsRoaming(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.IsRoaming(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsOverDataLimit(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOverDataLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsOverDataLimit(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.IsOverDataLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsBackgroundDataUsageRestricted(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBackgroundDataUsageRestricted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsBackgroundDataUsageRestricted(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.IsBackgroundDataUsageRestricted(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_RawData(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfileFilter_get_PurposeGuid(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PurposeGuid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_PurposeGuid(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::guid>>(arg);

            self->obj.PurposeGuid(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ConnectionProfileFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ConnectionProfileFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectionProfileFilter[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ConnectionProfileFilter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConnectionProfileFilter[] = {
        { "service_provider_guid", reinterpret_cast<getter>(ConnectionProfileFilter_get_ServiceProviderGuid), reinterpret_cast<setter>(ConnectionProfileFilter_put_ServiceProviderGuid), nullptr, nullptr },
        { "network_cost_type", reinterpret_cast<getter>(ConnectionProfileFilter_get_NetworkCostType), reinterpret_cast<setter>(ConnectionProfileFilter_put_NetworkCostType), nullptr, nullptr },
        { "is_wwan_connection_profile", reinterpret_cast<getter>(ConnectionProfileFilter_get_IsWwanConnectionProfile), reinterpret_cast<setter>(ConnectionProfileFilter_put_IsWwanConnectionProfile), nullptr, nullptr },
        { "is_wlan_connection_profile", reinterpret_cast<getter>(ConnectionProfileFilter_get_IsWlanConnectionProfile), reinterpret_cast<setter>(ConnectionProfileFilter_put_IsWlanConnectionProfile), nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(ConnectionProfileFilter_get_IsConnected), reinterpret_cast<setter>(ConnectionProfileFilter_put_IsConnected), nullptr, nullptr },
        { "is_roaming", reinterpret_cast<getter>(ConnectionProfileFilter_get_IsRoaming), reinterpret_cast<setter>(ConnectionProfileFilter_put_IsRoaming), nullptr, nullptr },
        { "is_over_data_limit", reinterpret_cast<getter>(ConnectionProfileFilter_get_IsOverDataLimit), reinterpret_cast<setter>(ConnectionProfileFilter_put_IsOverDataLimit), nullptr, nullptr },
        { "is_background_data_usage_restricted", reinterpret_cast<getter>(ConnectionProfileFilter_get_IsBackgroundDataUsageRestricted), reinterpret_cast<setter>(ConnectionProfileFilter_put_IsBackgroundDataUsageRestricted), nullptr, nullptr },
        { "raw_data", reinterpret_cast<getter>(ConnectionProfileFilter_get_RawData), nullptr, nullptr, nullptr },
        { "purpose_guid", reinterpret_cast<getter>(ConnectionProfileFilter_get_PurposeGuid), reinterpret_cast<setter>(ConnectionProfileFilter_put_PurposeGuid), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConnectionProfileFilter[] = 
    {
        { Py_tp_new, _new_ConnectionProfileFilter },
        { Py_tp_dealloc, _dealloc_ConnectionProfileFilter },
        { Py_tp_methods, _methods_ConnectionProfileFilter },
        { Py_tp_getset, _getset_ConnectionProfileFilter },
        { },
    };

    static PyType_Spec type_spec_ConnectionProfileFilter =
    {
        "_winsdk_Windows_Networking_Connectivity.ConnectionProfileFilter",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectionProfileFilter
    };

    // ----- ConnectionSession class --------------------
    constexpr const char* const type_name_ConnectionSession = "ConnectionSession";

    static PyObject* _new_ConnectionSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ConnectionSession);
        return nullptr;
    }

    static void _dealloc_ConnectionSession(py::wrapper::Windows::Networking::Connectivity::ConnectionSession* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ConnectionSession_Close(py::wrapper::Windows::Networking::Connectivity::ConnectionSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionSession_get_ConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConnectionSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ConnectionSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ConnectionSession(py::wrapper::Windows::Networking::Connectivity::ConnectionSession* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ConnectionSession(py::wrapper::Windows::Networking::Connectivity::ConnectionSession* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectionSession[] = {
        { "close", reinterpret_cast<PyCFunction>(ConnectionSession_Close), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConnectionSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ConnectionSession), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ConnectionSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConnectionSession[] = {
        { "connection_profile", reinterpret_cast<getter>(ConnectionSession_get_ConnectionProfile), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConnectionSession[] = 
    {
        { Py_tp_new, _new_ConnectionSession },
        { Py_tp_dealloc, _dealloc_ConnectionSession },
        { Py_tp_methods, _methods_ConnectionSession },
        { Py_tp_getset, _getset_ConnectionSession },
        { },
    };

    static PyType_Spec type_spec_ConnectionSession =
    {
        "_winsdk_Windows_Networking_Connectivity.ConnectionSession",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ConnectionSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectionSession
    };

    // ----- ConnectivityInterval class --------------------
    constexpr const char* const type_name_ConnectivityInterval = "ConnectivityInterval";

    static PyObject* _new_ConnectivityInterval(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ConnectivityInterval);
        return nullptr;
    }

    static void _dealloc_ConnectivityInterval(py::wrapper::Windows::Networking::Connectivity::ConnectivityInterval* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ConnectivityInterval_get_ConnectionDuration(py::wrapper::Windows::Networking::Connectivity::ConnectivityInterval* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectivityInterval_get_StartTime(py::wrapper::Windows::Networking::Connectivity::ConnectivityInterval* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConnectivityInterval(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ConnectivityInterval>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectivityInterval[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ConnectivityInterval), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConnectivityInterval[] = {
        { "connection_duration", reinterpret_cast<getter>(ConnectivityInterval_get_ConnectionDuration), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(ConnectivityInterval_get_StartTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConnectivityInterval[] = 
    {
        { Py_tp_new, _new_ConnectivityInterval },
        { Py_tp_dealloc, _dealloc_ConnectivityInterval },
        { Py_tp_methods, _methods_ConnectivityInterval },
        { Py_tp_getset, _getset_ConnectivityInterval },
        { },
    };

    static PyType_Spec type_spec_ConnectivityInterval =
    {
        "_winsdk_Windows_Networking_Connectivity.ConnectivityInterval",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ConnectivityInterval),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectivityInterval
    };

    // ----- ConnectivityManager class --------------------
    constexpr const char* const type_name_ConnectivityManager = "ConnectivityManager";

    static PyObject* _new_ConnectivityManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ConnectivityManager);
        return nullptr;
    }

    static PyObject* ConnectivityManager_AcquireConnectionAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::CellularApnContext>(args, 0);

                return py::convert(winrt::Windows::Networking::Connectivity::ConnectivityManager::AcquireConnectionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectivityManager_AddHttpRoutePolicy(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::RoutePolicy>(args, 0);

                winrt::Windows::Networking::Connectivity::ConnectivityManager::AddHttpRoutePolicy(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectivityManager_RemoveHttpRoutePolicy(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::RoutePolicy>(args, 0);

                winrt::Windows::Networking::Connectivity::ConnectivityManager::RemoveHttpRoutePolicy(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectivityManager[] = {
        { "acquire_connection_async", reinterpret_cast<PyCFunction>(ConnectivityManager_AcquireConnectionAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "add_http_route_policy", reinterpret_cast<PyCFunction>(ConnectivityManager_AddHttpRoutePolicy), METH_VARARGS | METH_STATIC, nullptr },
        { "remove_http_route_policy", reinterpret_cast<PyCFunction>(ConnectivityManager_RemoveHttpRoutePolicy), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConnectivityManager[] = {
        { }
    };

    static PyType_Slot _type_slots_ConnectivityManager[] = 
    {
        { Py_tp_new, _new_ConnectivityManager },
        { Py_tp_methods, _methods_ConnectivityManager },
        { Py_tp_getset, _getset_ConnectivityManager },
        { },
    };

    static PyType_Spec type_spec_ConnectivityManager =
    {
        "_winsdk_Windows_Networking_Connectivity.ConnectivityManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectivityManager
    };

    // ----- DataPlanStatus class --------------------
    constexpr const char* const type_name_DataPlanStatus = "DataPlanStatus";

    static PyObject* _new_DataPlanStatus(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DataPlanStatus);
        return nullptr;
    }

    static void _dealloc_DataPlanStatus(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataPlanStatus_get_DataLimitInMegabytes(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DataLimitInMegabytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanStatus_get_DataPlanUsage(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DataPlanUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanStatus_get_InboundBitsPerSecond(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundBitsPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanStatus_get_MaxTransferSizeInMegabytes(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxTransferSizeInMegabytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanStatus_get_NextBillingCycle(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NextBillingCycle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanStatus_get_OutboundBitsPerSecond(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBitsPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DataPlanStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::DataPlanStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataPlanStatus[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DataPlanStatus), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataPlanStatus[] = {
        { "data_limit_in_megabytes", reinterpret_cast<getter>(DataPlanStatus_get_DataLimitInMegabytes), nullptr, nullptr, nullptr },
        { "data_plan_usage", reinterpret_cast<getter>(DataPlanStatus_get_DataPlanUsage), nullptr, nullptr, nullptr },
        { "inbound_bits_per_second", reinterpret_cast<getter>(DataPlanStatus_get_InboundBitsPerSecond), nullptr, nullptr, nullptr },
        { "max_transfer_size_in_megabytes", reinterpret_cast<getter>(DataPlanStatus_get_MaxTransferSizeInMegabytes), nullptr, nullptr, nullptr },
        { "next_billing_cycle", reinterpret_cast<getter>(DataPlanStatus_get_NextBillingCycle), nullptr, nullptr, nullptr },
        { "outbound_bits_per_second", reinterpret_cast<getter>(DataPlanStatus_get_OutboundBitsPerSecond), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataPlanStatus[] = 
    {
        { Py_tp_new, _new_DataPlanStatus },
        { Py_tp_dealloc, _dealloc_DataPlanStatus },
        { Py_tp_methods, _methods_DataPlanStatus },
        { Py_tp_getset, _getset_DataPlanStatus },
        { },
    };

    static PyType_Spec type_spec_DataPlanStatus =
    {
        "_winsdk_Windows_Networking_Connectivity.DataPlanStatus",
        sizeof(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataPlanStatus
    };

    // ----- DataPlanUsage class --------------------
    constexpr const char* const type_name_DataPlanUsage = "DataPlanUsage";

    static PyObject* _new_DataPlanUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DataPlanUsage);
        return nullptr;
    }

    static void _dealloc_DataPlanUsage(py::wrapper::Windows::Networking::Connectivity::DataPlanUsage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataPlanUsage_get_LastSyncTime(py::wrapper::Windows::Networking::Connectivity::DataPlanUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastSyncTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanUsage_get_MegabytesUsed(py::wrapper::Windows::Networking::Connectivity::DataPlanUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MegabytesUsed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DataPlanUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::DataPlanUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataPlanUsage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DataPlanUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataPlanUsage[] = {
        { "last_sync_time", reinterpret_cast<getter>(DataPlanUsage_get_LastSyncTime), nullptr, nullptr, nullptr },
        { "megabytes_used", reinterpret_cast<getter>(DataPlanUsage_get_MegabytesUsed), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataPlanUsage[] = 
    {
        { Py_tp_new, _new_DataPlanUsage },
        { Py_tp_dealloc, _dealloc_DataPlanUsage },
        { Py_tp_methods, _methods_DataPlanUsage },
        { Py_tp_getset, _getset_DataPlanUsage },
        { },
    };

    static PyType_Spec type_spec_DataPlanUsage =
    {
        "_winsdk_Windows_Networking_Connectivity.DataPlanUsage",
        sizeof(py::wrapper::Windows::Networking::Connectivity::DataPlanUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataPlanUsage
    };

    // ----- DataUsage class --------------------
    constexpr const char* const type_name_DataUsage = "DataUsage";

    static PyObject* _new_DataUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DataUsage);
        return nullptr;
    }

    static void _dealloc_DataUsage(py::wrapper::Windows::Networking::Connectivity::DataUsage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataUsage_get_BytesReceived(py::wrapper::Windows::Networking::Connectivity::DataUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataUsage_get_BytesSent(py::wrapper::Windows::Networking::Connectivity::DataUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesSent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DataUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::DataUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataUsage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DataUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataUsage[] = {
        { "bytes_received", reinterpret_cast<getter>(DataUsage_get_BytesReceived), nullptr, nullptr, nullptr },
        { "bytes_sent", reinterpret_cast<getter>(DataUsage_get_BytesSent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataUsage[] = 
    {
        { Py_tp_new, _new_DataUsage },
        { Py_tp_dealloc, _dealloc_DataUsage },
        { Py_tp_methods, _methods_DataUsage },
        { Py_tp_getset, _getset_DataUsage },
        { },
    };

    static PyType_Spec type_spec_DataUsage =
    {
        "_winsdk_Windows_Networking_Connectivity.DataUsage",
        sizeof(py::wrapper::Windows::Networking::Connectivity::DataUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataUsage
    };

    // ----- IPInformation class --------------------
    constexpr const char* const type_name_IPInformation = "IPInformation";

    static PyObject* _new_IPInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_IPInformation);
        return nullptr;
    }

    static void _dealloc_IPInformation(py::wrapper::Windows::Networking::Connectivity::IPInformation* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPInformation_get_NetworkAdapter(py::wrapper::Windows::Networking::Connectivity::IPInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAdapter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPInformation_get_PrefixLength(py::wrapper::Windows::Networking::Connectivity::IPInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrefixLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IPInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::IPInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPInformation[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IPInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPInformation[] = {
        { "network_adapter", reinterpret_cast<getter>(IPInformation_get_NetworkAdapter), nullptr, nullptr, nullptr },
        { "prefix_length", reinterpret_cast<getter>(IPInformation_get_PrefixLength), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPInformation[] = 
    {
        { Py_tp_new, _new_IPInformation },
        { Py_tp_dealloc, _dealloc_IPInformation },
        { Py_tp_methods, _methods_IPInformation },
        { Py_tp_getset, _getset_IPInformation },
        { },
    };

    static PyType_Spec type_spec_IPInformation =
    {
        "_winsdk_Windows_Networking_Connectivity.IPInformation",
        sizeof(py::wrapper::Windows::Networking::Connectivity::IPInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPInformation
    };

    // ----- LanIdentifier class --------------------
    constexpr const char* const type_name_LanIdentifier = "LanIdentifier";

    static PyObject* _new_LanIdentifier(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LanIdentifier);
        return nullptr;
    }

    static void _dealloc_LanIdentifier(py::wrapper::Windows::Networking::Connectivity::LanIdentifier* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LanIdentifier_get_InfrastructureId(py::wrapper::Windows::Networking::Connectivity::LanIdentifier* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InfrastructureId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LanIdentifier_get_NetworkAdapterId(py::wrapper::Windows::Networking::Connectivity::LanIdentifier* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAdapterId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LanIdentifier_get_PortId(py::wrapper::Windows::Networking::Connectivity::LanIdentifier* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PortId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LanIdentifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::LanIdentifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LanIdentifier[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_LanIdentifier), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LanIdentifier[] = {
        { "infrastructure_id", reinterpret_cast<getter>(LanIdentifier_get_InfrastructureId), nullptr, nullptr, nullptr },
        { "network_adapter_id", reinterpret_cast<getter>(LanIdentifier_get_NetworkAdapterId), nullptr, nullptr, nullptr },
        { "port_id", reinterpret_cast<getter>(LanIdentifier_get_PortId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LanIdentifier[] = 
    {
        { Py_tp_new, _new_LanIdentifier },
        { Py_tp_dealloc, _dealloc_LanIdentifier },
        { Py_tp_methods, _methods_LanIdentifier },
        { Py_tp_getset, _getset_LanIdentifier },
        { },
    };

    static PyType_Spec type_spec_LanIdentifier =
    {
        "_winsdk_Windows_Networking_Connectivity.LanIdentifier",
        sizeof(py::wrapper::Windows::Networking::Connectivity::LanIdentifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LanIdentifier
    };

    // ----- LanIdentifierData class --------------------
    constexpr const char* const type_name_LanIdentifierData = "LanIdentifierData";

    static PyObject* _new_LanIdentifierData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LanIdentifierData);
        return nullptr;
    }

    static void _dealloc_LanIdentifierData(py::wrapper::Windows::Networking::Connectivity::LanIdentifierData* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LanIdentifierData_get_Type(py::wrapper::Windows::Networking::Connectivity::LanIdentifierData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LanIdentifierData_get_Value(py::wrapper::Windows::Networking::Connectivity::LanIdentifierData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LanIdentifierData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::LanIdentifierData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LanIdentifierData[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_LanIdentifierData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LanIdentifierData[] = {
        { "type", reinterpret_cast<getter>(LanIdentifierData_get_Type), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(LanIdentifierData_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LanIdentifierData[] = 
    {
        { Py_tp_new, _new_LanIdentifierData },
        { Py_tp_dealloc, _dealloc_LanIdentifierData },
        { Py_tp_methods, _methods_LanIdentifierData },
        { Py_tp_getset, _getset_LanIdentifierData },
        { },
    };

    static PyType_Spec type_spec_LanIdentifierData =
    {
        "_winsdk_Windows_Networking_Connectivity.LanIdentifierData",
        sizeof(py::wrapper::Windows::Networking::Connectivity::LanIdentifierData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LanIdentifierData
    };

    // ----- NetworkAdapter class --------------------
    constexpr const char* const type_name_NetworkAdapter = "NetworkAdapter";

    static PyObject* _new_NetworkAdapter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_NetworkAdapter);
        return nullptr;
    }

    static void _dealloc_NetworkAdapter(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkAdapter_GetConnectedProfileAsync(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConnectedProfileAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkAdapter_get_IanaInterfaceType(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IanaInterfaceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkAdapter_get_InboundMaxBitsPerSecond(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundMaxBitsPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkAdapter_get_NetworkAdapterId(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAdapterId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkAdapter_get_NetworkItem(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkAdapter_get_OutboundMaxBitsPerSecond(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundMaxBitsPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NetworkAdapter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::NetworkAdapter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkAdapter[] = {
        { "get_connected_profile_async", reinterpret_cast<PyCFunction>(NetworkAdapter_GetConnectedProfileAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkAdapter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkAdapter[] = {
        { "iana_interface_type", reinterpret_cast<getter>(NetworkAdapter_get_IanaInterfaceType), nullptr, nullptr, nullptr },
        { "inbound_max_bits_per_second", reinterpret_cast<getter>(NetworkAdapter_get_InboundMaxBitsPerSecond), nullptr, nullptr, nullptr },
        { "network_adapter_id", reinterpret_cast<getter>(NetworkAdapter_get_NetworkAdapterId), nullptr, nullptr, nullptr },
        { "network_item", reinterpret_cast<getter>(NetworkAdapter_get_NetworkItem), nullptr, nullptr, nullptr },
        { "outbound_max_bits_per_second", reinterpret_cast<getter>(NetworkAdapter_get_OutboundMaxBitsPerSecond), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkAdapter[] = 
    {
        { Py_tp_new, _new_NetworkAdapter },
        { Py_tp_dealloc, _dealloc_NetworkAdapter },
        { Py_tp_methods, _methods_NetworkAdapter },
        { Py_tp_getset, _getset_NetworkAdapter },
        { },
    };

    static PyType_Spec type_spec_NetworkAdapter =
    {
        "_winsdk_Windows_Networking_Connectivity.NetworkAdapter",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkAdapter
    };

    // ----- NetworkInformation class --------------------
    constexpr const char* const type_name_NetworkInformation = "NetworkInformation";

    static PyObject* _new_NetworkInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_NetworkInformation);
        return nullptr;
    }

    static PyObject* NetworkInformation_FindConnectionProfilesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::ConnectionProfileFilter>(args, 0);

                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::FindConnectionProfilesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetConnectionProfiles(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetConnectionProfiles());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetHostNames(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetHostNames());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetInternetConnectionProfile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetInternetConnectionProfile());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetLanIdentifiers(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetLanIdentifiers());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetProxyConfigurationAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetProxyConfigurationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetSortedEndpointPairs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::EndpointPair>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::HostNameSortOptions>(args, 1);

                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetSortedEndpointPairs(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_add_NetworkStatusChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkStatusChangedEventHandler>(arg);

            return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::NetworkStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_remove_NetworkStatusChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Networking::Connectivity::NetworkInformation::NetworkStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkInformation[] = {
        { "find_connection_profiles_async", reinterpret_cast<PyCFunction>(NetworkInformation_FindConnectionProfilesAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_connection_profiles", reinterpret_cast<PyCFunction>(NetworkInformation_GetConnectionProfiles), METH_VARARGS | METH_STATIC, nullptr },
        { "get_host_names", reinterpret_cast<PyCFunction>(NetworkInformation_GetHostNames), METH_VARARGS | METH_STATIC, nullptr },
        { "get_internet_connection_profile", reinterpret_cast<PyCFunction>(NetworkInformation_GetInternetConnectionProfile), METH_VARARGS | METH_STATIC, nullptr },
        { "get_lan_identifiers", reinterpret_cast<PyCFunction>(NetworkInformation_GetLanIdentifiers), METH_VARARGS | METH_STATIC, nullptr },
        { "get_proxy_configuration_async", reinterpret_cast<PyCFunction>(NetworkInformation_GetProxyConfigurationAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_sorted_endpoint_pairs", reinterpret_cast<PyCFunction>(NetworkInformation_GetSortedEndpointPairs), METH_VARARGS | METH_STATIC, nullptr },
        { "add_network_status_changed", reinterpret_cast<PyCFunction>(NetworkInformation_add_NetworkStatusChanged), METH_O | METH_STATIC, nullptr },
        { "remove_network_status_changed", reinterpret_cast<PyCFunction>(NetworkInformation_remove_NetworkStatusChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkInformation[] = {
        { }
    };

    static PyType_Slot _type_slots_NetworkInformation[] = 
    {
        { Py_tp_new, _new_NetworkInformation },
        { Py_tp_methods, _methods_NetworkInformation },
        { Py_tp_getset, _getset_NetworkInformation },
        { },
    };

    static PyType_Spec type_spec_NetworkInformation =
    {
        "_winsdk_Windows_Networking_Connectivity.NetworkInformation",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkInformation
    };

    // ----- NetworkItem class --------------------
    constexpr const char* const type_name_NetworkItem = "NetworkItem";

    static PyObject* _new_NetworkItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_NetworkItem);
        return nullptr;
    }

    static void _dealloc_NetworkItem(py::wrapper::Windows::Networking::Connectivity::NetworkItem* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkItem_GetNetworkTypes(py::wrapper::Windows::Networking::Connectivity::NetworkItem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetNetworkTypes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkItem_get_NetworkId(py::wrapper::Windows::Networking::Connectivity::NetworkItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NetworkItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::NetworkItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkItem[] = {
        { "get_network_types", reinterpret_cast<PyCFunction>(NetworkItem_GetNetworkTypes), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkItem[] = {
        { "network_id", reinterpret_cast<getter>(NetworkItem_get_NetworkId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkItem[] = 
    {
        { Py_tp_new, _new_NetworkItem },
        { Py_tp_dealloc, _dealloc_NetworkItem },
        { Py_tp_methods, _methods_NetworkItem },
        { Py_tp_getset, _getset_NetworkItem },
        { },
    };

    static PyType_Spec type_spec_NetworkItem =
    {
        "_winsdk_Windows_Networking_Connectivity.NetworkItem",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkItem
    };

    // ----- NetworkSecuritySettings class --------------------
    constexpr const char* const type_name_NetworkSecuritySettings = "NetworkSecuritySettings";

    static PyObject* _new_NetworkSecuritySettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_NetworkSecuritySettings);
        return nullptr;
    }

    static void _dealloc_NetworkSecuritySettings(py::wrapper::Windows::Networking::Connectivity::NetworkSecuritySettings* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkSecuritySettings_get_NetworkAuthenticationType(py::wrapper::Windows::Networking::Connectivity::NetworkSecuritySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAuthenticationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkSecuritySettings_get_NetworkEncryptionType(py::wrapper::Windows::Networking::Connectivity::NetworkSecuritySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkEncryptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NetworkSecuritySettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::NetworkSecuritySettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkSecuritySettings[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkSecuritySettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkSecuritySettings[] = {
        { "network_authentication_type", reinterpret_cast<getter>(NetworkSecuritySettings_get_NetworkAuthenticationType), nullptr, nullptr, nullptr },
        { "network_encryption_type", reinterpret_cast<getter>(NetworkSecuritySettings_get_NetworkEncryptionType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkSecuritySettings[] = 
    {
        { Py_tp_new, _new_NetworkSecuritySettings },
        { Py_tp_dealloc, _dealloc_NetworkSecuritySettings },
        { Py_tp_methods, _methods_NetworkSecuritySettings },
        { Py_tp_getset, _getset_NetworkSecuritySettings },
        { },
    };

    static PyType_Spec type_spec_NetworkSecuritySettings =
    {
        "_winsdk_Windows_Networking_Connectivity.NetworkSecuritySettings",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkSecuritySettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkSecuritySettings
    };

    // ----- NetworkStateChangeEventDetails class --------------------
    constexpr const char* const type_name_NetworkStateChangeEventDetails = "NetworkStateChangeEventDetails";

    static PyObject* _new_NetworkStateChangeEventDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_NetworkStateChangeEventDetails);
        return nullptr;
    }

    static void _dealloc_NetworkStateChangeEventDetails(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewConnectionCost(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewConnectionCost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewDomainConnectivityLevel(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewDomainConnectivityLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewHostNameList(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewHostNameList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewInternetConnectionProfile(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewInternetConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewNetworkConnectivityLevel(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewNetworkConnectivityLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewWwanRegistrationState(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewWwanRegistrationState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewTetheringClientCount(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewTetheringClientCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewTetheringOperationalState(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewTetheringOperationalState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NetworkStateChangeEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::NetworkStateChangeEventDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkStateChangeEventDetails[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkStateChangeEventDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkStateChangeEventDetails[] = {
        { "has_new_connection_cost", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewConnectionCost), nullptr, nullptr, nullptr },
        { "has_new_domain_connectivity_level", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewDomainConnectivityLevel), nullptr, nullptr, nullptr },
        { "has_new_host_name_list", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewHostNameList), nullptr, nullptr, nullptr },
        { "has_new_internet_connection_profile", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewInternetConnectionProfile), nullptr, nullptr, nullptr },
        { "has_new_network_connectivity_level", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewNetworkConnectivityLevel), nullptr, nullptr, nullptr },
        { "has_new_wwan_registration_state", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewWwanRegistrationState), nullptr, nullptr, nullptr },
        { "has_new_tethering_client_count", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewTetheringClientCount), nullptr, nullptr, nullptr },
        { "has_new_tethering_operational_state", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewTetheringOperationalState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkStateChangeEventDetails[] = 
    {
        { Py_tp_new, _new_NetworkStateChangeEventDetails },
        { Py_tp_dealloc, _dealloc_NetworkStateChangeEventDetails },
        { Py_tp_methods, _methods_NetworkStateChangeEventDetails },
        { Py_tp_getset, _getset_NetworkStateChangeEventDetails },
        { },
    };

    static PyType_Spec type_spec_NetworkStateChangeEventDetails =
    {
        "_winsdk_Windows_Networking_Connectivity.NetworkStateChangeEventDetails",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkStateChangeEventDetails
    };

    // ----- NetworkUsage class --------------------
    constexpr const char* const type_name_NetworkUsage = "NetworkUsage";

    static PyObject* _new_NetworkUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_NetworkUsage);
        return nullptr;
    }

    static void _dealloc_NetworkUsage(py::wrapper::Windows::Networking::Connectivity::NetworkUsage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkUsage_get_BytesReceived(py::wrapper::Windows::Networking::Connectivity::NetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkUsage_get_BytesSent(py::wrapper::Windows::Networking::Connectivity::NetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesSent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkUsage_get_ConnectionDuration(py::wrapper::Windows::Networking::Connectivity::NetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NetworkUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::NetworkUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkUsage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkUsage[] = {
        { "bytes_received", reinterpret_cast<getter>(NetworkUsage_get_BytesReceived), nullptr, nullptr, nullptr },
        { "bytes_sent", reinterpret_cast<getter>(NetworkUsage_get_BytesSent), nullptr, nullptr, nullptr },
        { "connection_duration", reinterpret_cast<getter>(NetworkUsage_get_ConnectionDuration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkUsage[] = 
    {
        { Py_tp_new, _new_NetworkUsage },
        { Py_tp_dealloc, _dealloc_NetworkUsage },
        { Py_tp_methods, _methods_NetworkUsage },
        { Py_tp_getset, _getset_NetworkUsage },
        { },
    };

    static PyType_Spec type_spec_NetworkUsage =
    {
        "_winsdk_Windows_Networking_Connectivity.NetworkUsage",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkUsage
    };

    // ----- ProviderNetworkUsage class --------------------
    constexpr const char* const type_name_ProviderNetworkUsage = "ProviderNetworkUsage";

    static PyObject* _new_ProviderNetworkUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProviderNetworkUsage);
        return nullptr;
    }

    static void _dealloc_ProviderNetworkUsage(py::wrapper::Windows::Networking::Connectivity::ProviderNetworkUsage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProviderNetworkUsage_get_BytesReceived(py::wrapper::Windows::Networking::Connectivity::ProviderNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProviderNetworkUsage_get_BytesSent(py::wrapper::Windows::Networking::Connectivity::ProviderNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesSent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProviderNetworkUsage_get_ProviderId(py::wrapper::Windows::Networking::Connectivity::ProviderNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProviderNetworkUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ProviderNetworkUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProviderNetworkUsage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ProviderNetworkUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProviderNetworkUsage[] = {
        { "bytes_received", reinterpret_cast<getter>(ProviderNetworkUsage_get_BytesReceived), nullptr, nullptr, nullptr },
        { "bytes_sent", reinterpret_cast<getter>(ProviderNetworkUsage_get_BytesSent), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(ProviderNetworkUsage_get_ProviderId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProviderNetworkUsage[] = 
    {
        { Py_tp_new, _new_ProviderNetworkUsage },
        { Py_tp_dealloc, _dealloc_ProviderNetworkUsage },
        { Py_tp_methods, _methods_ProviderNetworkUsage },
        { Py_tp_getset, _getset_ProviderNetworkUsage },
        { },
    };

    static PyType_Spec type_spec_ProviderNetworkUsage =
    {
        "_winsdk_Windows_Networking_Connectivity.ProviderNetworkUsage",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ProviderNetworkUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProviderNetworkUsage
    };

    // ----- ProxyConfiguration class --------------------
    constexpr const char* const type_name_ProxyConfiguration = "ProxyConfiguration";

    static PyObject* _new_ProxyConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProxyConfiguration);
        return nullptr;
    }

    static void _dealloc_ProxyConfiguration(py::wrapper::Windows::Networking::Connectivity::ProxyConfiguration* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProxyConfiguration_get_CanConnectDirectly(py::wrapper::Windows::Networking::Connectivity::ProxyConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanConnectDirectly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProxyConfiguration_get_ProxyUris(py::wrapper::Windows::Networking::Connectivity::ProxyConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProxyUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProxyConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ProxyConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProxyConfiguration[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ProxyConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProxyConfiguration[] = {
        { "can_connect_directly", reinterpret_cast<getter>(ProxyConfiguration_get_CanConnectDirectly), nullptr, nullptr, nullptr },
        { "proxy_uris", reinterpret_cast<getter>(ProxyConfiguration_get_ProxyUris), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProxyConfiguration[] = 
    {
        { Py_tp_new, _new_ProxyConfiguration },
        { Py_tp_dealloc, _dealloc_ProxyConfiguration },
        { Py_tp_methods, _methods_ProxyConfiguration },
        { Py_tp_getset, _getset_ProxyConfiguration },
        { },
    };

    static PyType_Spec type_spec_ProxyConfiguration =
    {
        "_winsdk_Windows_Networking_Connectivity.ProxyConfiguration",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ProxyConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProxyConfiguration
    };

    // ----- RoutePolicy class --------------------
    constexpr const char* const type_name_RoutePolicy = "RoutePolicy";

    static PyObject* _new_RoutePolicy(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::ConnectionProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::HostName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::DomainNameType>(args, 2);

                winrt::Windows::Networking::Connectivity::RoutePolicy instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RoutePolicy(py::wrapper::Windows::Networking::Connectivity::RoutePolicy* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RoutePolicy_get_ConnectionProfile(py::wrapper::Windows::Networking::Connectivity::RoutePolicy* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RoutePolicy_get_HostName(py::wrapper::Windows::Networking::Connectivity::RoutePolicy* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HostName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RoutePolicy_get_HostNameType(py::wrapper::Windows::Networking::Connectivity::RoutePolicy* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HostNameType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RoutePolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::RoutePolicy>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RoutePolicy[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_RoutePolicy), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RoutePolicy[] = {
        { "connection_profile", reinterpret_cast<getter>(RoutePolicy_get_ConnectionProfile), nullptr, nullptr, nullptr },
        { "host_name", reinterpret_cast<getter>(RoutePolicy_get_HostName), nullptr, nullptr, nullptr },
        { "host_name_type", reinterpret_cast<getter>(RoutePolicy_get_HostNameType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RoutePolicy[] = 
    {
        { Py_tp_new, _new_RoutePolicy },
        { Py_tp_dealloc, _dealloc_RoutePolicy },
        { Py_tp_methods, _methods_RoutePolicy },
        { Py_tp_getset, _getset_RoutePolicy },
        { },
    };

    static PyType_Spec type_spec_RoutePolicy =
    {
        "_winsdk_Windows_Networking_Connectivity.RoutePolicy",
        sizeof(py::wrapper::Windows::Networking::Connectivity::RoutePolicy),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RoutePolicy
    };

    // ----- WlanConnectionProfileDetails class --------------------
    constexpr const char* const type_name_WlanConnectionProfileDetails = "WlanConnectionProfileDetails";

    static PyObject* _new_WlanConnectionProfileDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WlanConnectionProfileDetails);
        return nullptr;
    }

    static void _dealloc_WlanConnectionProfileDetails(py::wrapper::Windows::Networking::Connectivity::WlanConnectionProfileDetails* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WlanConnectionProfileDetails_GetConnectedSsid(py::wrapper::Windows::Networking::Connectivity::WlanConnectionProfileDetails* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConnectedSsid());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_WlanConnectionProfileDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::WlanConnectionProfileDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WlanConnectionProfileDetails[] = {
        { "get_connected_ssid", reinterpret_cast<PyCFunction>(WlanConnectionProfileDetails_GetConnectedSsid), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WlanConnectionProfileDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WlanConnectionProfileDetails[] = {
        { }
    };

    static PyType_Slot _type_slots_WlanConnectionProfileDetails[] = 
    {
        { Py_tp_new, _new_WlanConnectionProfileDetails },
        { Py_tp_dealloc, _dealloc_WlanConnectionProfileDetails },
        { Py_tp_methods, _methods_WlanConnectionProfileDetails },
        { Py_tp_getset, _getset_WlanConnectionProfileDetails },
        { },
    };

    static PyType_Spec type_spec_WlanConnectionProfileDetails =
    {
        "_winsdk_Windows_Networking_Connectivity.WlanConnectionProfileDetails",
        sizeof(py::wrapper::Windows::Networking::Connectivity::WlanConnectionProfileDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WlanConnectionProfileDetails
    };

    // ----- WwanConnectionProfileDetails class --------------------
    constexpr const char* const type_name_WwanConnectionProfileDetails = "WwanConnectionProfileDetails";

    static PyObject* _new_WwanConnectionProfileDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WwanConnectionProfileDetails);
        return nullptr;
    }

    static void _dealloc_WwanConnectionProfileDetails(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WwanConnectionProfileDetails_GetCurrentDataClass(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentDataClass());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwanConnectionProfileDetails_GetNetworkRegistrationState(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetNetworkRegistrationState());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwanConnectionProfileDetails_get_AccessPointName(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AccessPointName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WwanConnectionProfileDetails_get_HomeProviderId(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HomeProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WwanConnectionProfileDetails_get_IPKind(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IPKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WwanConnectionProfileDetails_get_PurposeGuids(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PurposeGuids());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_WwanConnectionProfileDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::WwanConnectionProfileDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WwanConnectionProfileDetails[] = {
        { "get_current_data_class", reinterpret_cast<PyCFunction>(WwanConnectionProfileDetails_GetCurrentDataClass), METH_VARARGS, nullptr },
        { "get_network_registration_state", reinterpret_cast<PyCFunction>(WwanConnectionProfileDetails_GetNetworkRegistrationState), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WwanConnectionProfileDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WwanConnectionProfileDetails[] = {
        { "access_point_name", reinterpret_cast<getter>(WwanConnectionProfileDetails_get_AccessPointName), nullptr, nullptr, nullptr },
        { "home_provider_id", reinterpret_cast<getter>(WwanConnectionProfileDetails_get_HomeProviderId), nullptr, nullptr, nullptr },
        { "i_p_kind", reinterpret_cast<getter>(WwanConnectionProfileDetails_get_IPKind), nullptr, nullptr, nullptr },
        { "purpose_guids", reinterpret_cast<getter>(WwanConnectionProfileDetails_get_PurposeGuids), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WwanConnectionProfileDetails[] = 
    {
        { Py_tp_new, _new_WwanConnectionProfileDetails },
        { Py_tp_dealloc, _dealloc_WwanConnectionProfileDetails },
        { Py_tp_methods, _methods_WwanConnectionProfileDetails },
        { Py_tp_getset, _getset_WwanConnectionProfileDetails },
        { },
    };

    static PyType_Spec type_spec_WwanConnectionProfileDetails =
    {
        "_winsdk_Windows_Networking_Connectivity.WwanConnectionProfileDetails",
        sizeof(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WwanConnectionProfileDetails
    };

    // ----- NetworkUsageStates struct --------------------
    constexpr const char* const type_name_NetworkUsageStates = "NetworkUsageStates";

    PyObject* _new_NetworkUsageStates(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Networking::Connectivity::NetworkUsageStates return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        int32_t _Roaming{};
        int32_t _Shared{};

        static const char* kwlist[] = {"roaming", "shared", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ii", const_cast<char**>(kwlist), &_Roaming, &_Shared))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Networking::Connectivity::NetworkUsageStates return_value{ static_cast<winrt::Windows::Networking::Connectivity::TriStates>(_Roaming), static_cast<winrt::Windows::Networking::Connectivity::TriStates>(_Shared) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_NetworkUsageStates(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates* self)
    {
    }

    static PyObject* NetworkUsageStates_get_Roaming(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Roaming);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NetworkUsageStates_set_Roaming(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Roaming = py::converter<winrt::Windows::Networking::Connectivity::TriStates>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NetworkUsageStates_get_Shared(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shared);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NetworkUsageStates_set_Shared(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Shared = py::converter<winrt::Windows::Networking::Connectivity::TriStates>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_NetworkUsageStates[] = {
        { "roaming", reinterpret_cast<getter>(NetworkUsageStates_get_Roaming), reinterpret_cast<setter>(NetworkUsageStates_set_Roaming), nullptr, nullptr },
        { "shared", reinterpret_cast<getter>(NetworkUsageStates_get_Shared), reinterpret_cast<setter>(NetworkUsageStates_set_Shared), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkUsageStates[] = 
    {
        { Py_tp_new, _new_NetworkUsageStates },
        { Py_tp_dealloc, _dealloc_NetworkUsageStates },
        { Py_tp_getset, _getset_NetworkUsageStates },
        { },
    };

    static PyType_Spec type_spec_NetworkUsageStates =
    {
        "_winsdk_Windows_Networking_Connectivity.NetworkUsageStates",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkUsageStates
    };

    // ----- Windows.Networking.Connectivity Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Networking::Connectivity");

    static PyMethodDef module_methods[] = {
        {"_register_CellularApnAuthenticationType", register_CellularApnAuthenticationType, METH_O, "registers type"},
        {"_register_ConnectionProfileDeleteStatus", register_ConnectionProfileDeleteStatus, METH_O, "registers type"},
        {"_register_DataUsageGranularity", register_DataUsageGranularity, METH_O, "registers type"},
        {"_register_DomainAuthenticationKind", register_DomainAuthenticationKind, METH_O, "registers type"},
        {"_register_DomainConnectivityLevel", register_DomainConnectivityLevel, METH_O, "registers type"},
        {"_register_NetworkAuthenticationType", register_NetworkAuthenticationType, METH_O, "registers type"},
        {"_register_NetworkConnectivityLevel", register_NetworkConnectivityLevel, METH_O, "registers type"},
        {"_register_NetworkCostType", register_NetworkCostType, METH_O, "registers type"},
        {"_register_NetworkEncryptionType", register_NetworkEncryptionType, METH_O, "registers type"},
        {"_register_NetworkTypes", register_NetworkTypes, METH_O, "registers type"},
        {"_register_RoamingStates", register_RoamingStates, METH_O, "registers type"},
        {"_register_TriStates", register_TriStates, METH_O, "registers type"},
        {"_register_WwanDataClass", register_WwanDataClass, METH_O, "registers type"},
        {"_register_WwanNetworkIPKind", register_WwanNetworkIPKind, METH_O, "registers type"},
        {"_register_WwanNetworkRegistrationState", register_WwanNetworkRegistrationState, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_CellularApnAuthenticationType);
        Py_VISIT(state->type_ConnectionProfileDeleteStatus);
        Py_VISIT(state->type_DataUsageGranularity);
        Py_VISIT(state->type_DomainAuthenticationKind);
        Py_VISIT(state->type_DomainConnectivityLevel);
        Py_VISIT(state->type_NetworkAuthenticationType);
        Py_VISIT(state->type_NetworkConnectivityLevel);
        Py_VISIT(state->type_NetworkCostType);
        Py_VISIT(state->type_NetworkEncryptionType);
        Py_VISIT(state->type_NetworkTypes);
        Py_VISIT(state->type_RoamingStates);
        Py_VISIT(state->type_TriStates);
        Py_VISIT(state->type_WwanDataClass);
        Py_VISIT(state->type_WwanNetworkIPKind);
        Py_VISIT(state->type_WwanNetworkRegistrationState);
        Py_VISIT(state->type_AttributedNetworkUsage);
        Py_VISIT(state->type_CellularApnContext);
        Py_VISIT(state->type_ConnectionCost);
        Py_VISIT(state->type_ConnectionProfile);
        Py_VISIT(state->type_ConnectionProfileFilter);
        Py_VISIT(state->type_ConnectionSession);
        Py_VISIT(state->type_ConnectivityInterval);
        Py_VISIT(state->type_ConnectivityManager);
        Py_VISIT(state->type_DataPlanStatus);
        Py_VISIT(state->type_DataPlanUsage);
        Py_VISIT(state->type_DataUsage);
        Py_VISIT(state->type_IPInformation);
        Py_VISIT(state->type_LanIdentifier);
        Py_VISIT(state->type_LanIdentifierData);
        Py_VISIT(state->type_NetworkAdapter);
        Py_VISIT(state->type_NetworkInformation);
        Py_VISIT(state->type_NetworkItem);
        Py_VISIT(state->type_NetworkSecuritySettings);
        Py_VISIT(state->type_NetworkStateChangeEventDetails);
        Py_VISIT(state->type_NetworkUsage);
        Py_VISIT(state->type_ProviderNetworkUsage);
        Py_VISIT(state->type_ProxyConfiguration);
        Py_VISIT(state->type_RoutePolicy);
        Py_VISIT(state->type_WlanConnectionProfileDetails);
        Py_VISIT(state->type_WwanConnectionProfileDetails);
        Py_VISIT(state->type_NetworkUsageStates);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_CellularApnAuthenticationType);
        Py_CLEAR(state->type_ConnectionProfileDeleteStatus);
        Py_CLEAR(state->type_DataUsageGranularity);
        Py_CLEAR(state->type_DomainAuthenticationKind);
        Py_CLEAR(state->type_DomainConnectivityLevel);
        Py_CLEAR(state->type_NetworkAuthenticationType);
        Py_CLEAR(state->type_NetworkConnectivityLevel);
        Py_CLEAR(state->type_NetworkCostType);
        Py_CLEAR(state->type_NetworkEncryptionType);
        Py_CLEAR(state->type_NetworkTypes);
        Py_CLEAR(state->type_RoamingStates);
        Py_CLEAR(state->type_TriStates);
        Py_CLEAR(state->type_WwanDataClass);
        Py_CLEAR(state->type_WwanNetworkIPKind);
        Py_CLEAR(state->type_WwanNetworkRegistrationState);
        Py_CLEAR(state->type_AttributedNetworkUsage);
        Py_CLEAR(state->type_CellularApnContext);
        Py_CLEAR(state->type_ConnectionCost);
        Py_CLEAR(state->type_ConnectionProfile);
        Py_CLEAR(state->type_ConnectionProfileFilter);
        Py_CLEAR(state->type_ConnectionSession);
        Py_CLEAR(state->type_ConnectivityInterval);
        Py_CLEAR(state->type_ConnectivityManager);
        Py_CLEAR(state->type_DataPlanStatus);
        Py_CLEAR(state->type_DataPlanUsage);
        Py_CLEAR(state->type_DataUsage);
        Py_CLEAR(state->type_IPInformation);
        Py_CLEAR(state->type_LanIdentifier);
        Py_CLEAR(state->type_LanIdentifierData);
        Py_CLEAR(state->type_NetworkAdapter);
        Py_CLEAR(state->type_NetworkInformation);
        Py_CLEAR(state->type_NetworkItem);
        Py_CLEAR(state->type_NetworkSecuritySettings);
        Py_CLEAR(state->type_NetworkStateChangeEventDetails);
        Py_CLEAR(state->type_NetworkUsage);
        Py_CLEAR(state->type_ProviderNetworkUsage);
        Py_CLEAR(state->type_ProxyConfiguration);
        Py_CLEAR(state->type_RoutePolicy);
        Py_CLEAR(state->type_WlanConnectionProfileDetails);
        Py_CLEAR(state->type_WwanConnectionProfileDetails);
        Py_CLEAR(state->type_NetworkUsageStates);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Networking_Connectivity",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Networking::Connectivity

PyMODINIT_FUNC PyInit__winsdk_Windows_Networking_Connectivity(void) noexcept
{
    using namespace py::cpp::Windows::Networking::Connectivity;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_AttributedNetworkUsage = py::register_python_type(module.get(), type_name_AttributedNetworkUsage, &type_spec_AttributedNetworkUsage, bases.get());
    if (!state->type_AttributedNetworkUsage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_AttributedNetworkUsage);

    state->type_CellularApnContext = py::register_python_type(module.get(), type_name_CellularApnContext, &type_spec_CellularApnContext, bases.get());
    if (!state->type_CellularApnContext)
    {
        return nullptr;
    }

    Py_INCREF(state->type_CellularApnContext);

    state->type_ConnectionCost = py::register_python_type(module.get(), type_name_ConnectionCost, &type_spec_ConnectionCost, bases.get());
    if (!state->type_ConnectionCost)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ConnectionCost);

    state->type_ConnectionProfile = py::register_python_type(module.get(), type_name_ConnectionProfile, &type_spec_ConnectionProfile, bases.get());
    if (!state->type_ConnectionProfile)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ConnectionProfile);

    state->type_ConnectionProfileFilter = py::register_python_type(module.get(), type_name_ConnectionProfileFilter, &type_spec_ConnectionProfileFilter, bases.get());
    if (!state->type_ConnectionProfileFilter)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ConnectionProfileFilter);

    state->type_ConnectionSession = py::register_python_type(module.get(), type_name_ConnectionSession, &type_spec_ConnectionSession, bases.get());
    if (!state->type_ConnectionSession)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ConnectionSession);

    state->type_ConnectivityInterval = py::register_python_type(module.get(), type_name_ConnectivityInterval, &type_spec_ConnectivityInterval, bases.get());
    if (!state->type_ConnectivityInterval)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ConnectivityInterval);

    state->type_ConnectivityManager = py::register_python_type(module.get(), type_name_ConnectivityManager, &type_spec_ConnectivityManager, nullptr);
    if (!state->type_ConnectivityManager)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ConnectivityManager);

    state->type_DataPlanStatus = py::register_python_type(module.get(), type_name_DataPlanStatus, &type_spec_DataPlanStatus, bases.get());
    if (!state->type_DataPlanStatus)
    {
        return nullptr;
    }

    Py_INCREF(state->type_DataPlanStatus);

    state->type_DataPlanUsage = py::register_python_type(module.get(), type_name_DataPlanUsage, &type_spec_DataPlanUsage, bases.get());
    if (!state->type_DataPlanUsage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_DataPlanUsage);

    state->type_DataUsage = py::register_python_type(module.get(), type_name_DataUsage, &type_spec_DataUsage, bases.get());
    if (!state->type_DataUsage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_DataUsage);

    state->type_IPInformation = py::register_python_type(module.get(), type_name_IPInformation, &type_spec_IPInformation, bases.get());
    if (!state->type_IPInformation)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IPInformation);

    state->type_LanIdentifier = py::register_python_type(module.get(), type_name_LanIdentifier, &type_spec_LanIdentifier, bases.get());
    if (!state->type_LanIdentifier)
    {
        return nullptr;
    }

    Py_INCREF(state->type_LanIdentifier);

    state->type_LanIdentifierData = py::register_python_type(module.get(), type_name_LanIdentifierData, &type_spec_LanIdentifierData, bases.get());
    if (!state->type_LanIdentifierData)
    {
        return nullptr;
    }

    Py_INCREF(state->type_LanIdentifierData);

    state->type_NetworkAdapter = py::register_python_type(module.get(), type_name_NetworkAdapter, &type_spec_NetworkAdapter, bases.get());
    if (!state->type_NetworkAdapter)
    {
        return nullptr;
    }

    Py_INCREF(state->type_NetworkAdapter);

    state->type_NetworkInformation = py::register_python_type(module.get(), type_name_NetworkInformation, &type_spec_NetworkInformation, nullptr);
    if (!state->type_NetworkInformation)
    {
        return nullptr;
    }

    Py_INCREF(state->type_NetworkInformation);

    state->type_NetworkItem = py::register_python_type(module.get(), type_name_NetworkItem, &type_spec_NetworkItem, bases.get());
    if (!state->type_NetworkItem)
    {
        return nullptr;
    }

    Py_INCREF(state->type_NetworkItem);

    state->type_NetworkSecuritySettings = py::register_python_type(module.get(), type_name_NetworkSecuritySettings, &type_spec_NetworkSecuritySettings, bases.get());
    if (!state->type_NetworkSecuritySettings)
    {
        return nullptr;
    }

    Py_INCREF(state->type_NetworkSecuritySettings);

    state->type_NetworkStateChangeEventDetails = py::register_python_type(module.get(), type_name_NetworkStateChangeEventDetails, &type_spec_NetworkStateChangeEventDetails, bases.get());
    if (!state->type_NetworkStateChangeEventDetails)
    {
        return nullptr;
    }

    Py_INCREF(state->type_NetworkStateChangeEventDetails);

    state->type_NetworkUsage = py::register_python_type(module.get(), type_name_NetworkUsage, &type_spec_NetworkUsage, bases.get());
    if (!state->type_NetworkUsage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_NetworkUsage);

    state->type_ProviderNetworkUsage = py::register_python_type(module.get(), type_name_ProviderNetworkUsage, &type_spec_ProviderNetworkUsage, bases.get());
    if (!state->type_ProviderNetworkUsage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ProviderNetworkUsage);

    state->type_ProxyConfiguration = py::register_python_type(module.get(), type_name_ProxyConfiguration, &type_spec_ProxyConfiguration, bases.get());
    if (!state->type_ProxyConfiguration)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ProxyConfiguration);

    state->type_RoutePolicy = py::register_python_type(module.get(), type_name_RoutePolicy, &type_spec_RoutePolicy, bases.get());
    if (!state->type_RoutePolicy)
    {
        return nullptr;
    }

    Py_INCREF(state->type_RoutePolicy);

    state->type_WlanConnectionProfileDetails = py::register_python_type(module.get(), type_name_WlanConnectionProfileDetails, &type_spec_WlanConnectionProfileDetails, bases.get());
    if (!state->type_WlanConnectionProfileDetails)
    {
        return nullptr;
    }

    Py_INCREF(state->type_WlanConnectionProfileDetails);

    state->type_WwanConnectionProfileDetails = py::register_python_type(module.get(), type_name_WwanConnectionProfileDetails, &type_spec_WwanConnectionProfileDetails, bases.get());
    if (!state->type_WwanConnectionProfileDetails)
    {
        return nullptr;
    }

    Py_INCREF(state->type_WwanConnectionProfileDetails);

    state->type_NetworkUsageStates = py::register_python_type(module.get(), type_name_NetworkUsageStates, &type_spec_NetworkUsageStates, bases.get());
    if (!state->type_NetworkUsageStates)
    {
        return nullptr;
    }

    Py_INCREF(state->type_NetworkUsageStates);


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Networking::Connectivity::CellularApnAuthenticationType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CellularApnAuthenticationType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::CellularApnAuthenticationType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Connectivity::ConnectionProfileDeleteStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ConnectionProfileDeleteStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::ConnectionProfileDeleteStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Connectivity::DataUsageGranularity>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DataUsageGranularity;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::DataUsageGranularity is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Connectivity::DomainAuthenticationKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DomainAuthenticationKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::DomainAuthenticationKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Connectivity::DomainConnectivityLevel>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DomainConnectivityLevel;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::DomainConnectivityLevel is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Connectivity::NetworkAuthenticationType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkAuthenticationType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::NetworkAuthenticationType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Connectivity::NetworkConnectivityLevel>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkConnectivityLevel;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::NetworkConnectivityLevel is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Connectivity::NetworkCostType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkCostType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::NetworkCostType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Connectivity::NetworkEncryptionType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkEncryptionType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::NetworkEncryptionType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Connectivity::NetworkTypes>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkTypes;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::NetworkTypes is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Connectivity::RoamingStates>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RoamingStates;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::RoamingStates is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Connectivity::TriStates>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TriStates;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::TriStates is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Connectivity::WwanDataClass>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WwanDataClass;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::WwanDataClass is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Connectivity::WwanNetworkIPKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WwanNetworkIPKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::WwanNetworkIPKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::Connectivity::WwanNetworkRegistrationState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WwanNetworkRegistrationState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::WwanNetworkRegistrationState is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::AttributedNetworkUsage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AttributedNetworkUsage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::AttributedNetworkUsage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::CellularApnContext>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CellularApnContext;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::CellularApnContext is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectionCost>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ConnectionCost;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::ConnectionCost is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectionProfile>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ConnectionProfile;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::ConnectionProfile is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectionProfileFilter>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ConnectionProfileFilter;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::ConnectionProfileFilter is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectionSession>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ConnectionSession;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::ConnectionSession is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectivityInterval>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ConnectivityInterval;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::ConnectivityInterval is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectivityManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ConnectivityManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::ConnectivityManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::DataPlanStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DataPlanStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::DataPlanStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::DataPlanUsage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DataPlanUsage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::DataPlanUsage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::DataUsage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DataUsage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::DataUsage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::IPInformation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IPInformation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::IPInformation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::LanIdentifier>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LanIdentifier;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::LanIdentifier is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::LanIdentifierData>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LanIdentifierData;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::LanIdentifierData is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkAdapter>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkAdapter;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::NetworkAdapter is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkInformation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkInformation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::NetworkInformation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkItem>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkItem;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::NetworkItem is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkSecuritySettings>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkSecuritySettings;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::NetworkSecuritySettings is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkStateChangeEventDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkStateChangeEventDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::NetworkStateChangeEventDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkUsage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkUsage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::NetworkUsage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ProviderNetworkUsage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProviderNetworkUsage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::ProviderNetworkUsage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ProxyConfiguration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProxyConfiguration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::ProxyConfiguration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::RoutePolicy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RoutePolicy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::RoutePolicy is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::WlanConnectionProfileDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WlanConnectionProfileDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::WlanConnectionProfileDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::WwanConnectionProfileDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WwanConnectionProfileDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::WwanConnectionProfileDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkUsageStates>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::Connectivity;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::Connectivity");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkUsageStates;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::Connectivity::NetworkUsageStates is not registered");
        return nullptr;
    }

    return python_type;
}
