# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _darkprop
else:
    import _darkprop

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _darkprop.delete_SwigPyIterator

    def value(self) -> "PyObject *":
        return _darkprop.SwigPyIterator_value(self)

    def incr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _darkprop.SwigPyIterator_incr(self, n)

    def decr(self, n: "size_t"=1) -> "swig::SwigPyIterator *":
        return _darkprop.SwigPyIterator_decr(self, n)

    def distance(self, x: "SwigPyIterator") -> "ptrdiff_t":
        return _darkprop.SwigPyIterator_distance(self, x)

    def equal(self, x: "SwigPyIterator") -> "bool":
        return _darkprop.SwigPyIterator_equal(self, x)

    def copy(self) -> "swig::SwigPyIterator *":
        return _darkprop.SwigPyIterator_copy(self)

    def next(self) -> "PyObject *":
        return _darkprop.SwigPyIterator_next(self)

    def __next__(self) -> "PyObject *":
        return _darkprop.SwigPyIterator___next__(self)

    def previous(self) -> "PyObject *":
        return _darkprop.SwigPyIterator_previous(self)

    def advance(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _darkprop.SwigPyIterator_advance(self, n)

    def __eq__(self, x: "SwigPyIterator") -> "bool":
        return _darkprop.SwigPyIterator___eq__(self, x)

    def __ne__(self, x: "SwigPyIterator") -> "bool":
        return _darkprop.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _darkprop.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator &":
        return _darkprop.SwigPyIterator___isub__(self, n)

    def __add__(self, n: "ptrdiff_t") -> "swig::SwigPyIterator *":
        return _darkprop.SwigPyIterator___add__(self, n)

    def __sub__(self, *args) -> "ptrdiff_t":
        return _darkprop.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _darkprop:
_darkprop.SwigPyIterator_swigregister(SwigPyIterator)

class Target(object):
    r"""Target nuclues or electron."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_darkprop.Target_name_get, _darkprop.Target_name_set, doc=r""" name string""")
    Z = property(_darkprop.Target_Z_get, _darkprop.Target_Z_set, doc=r""" charge number""")
    A = property(_darkprop.Target_A_get, _darkprop.Target_A_set, doc=r""" mass number""")
    m = property(_darkprop.Target_m_get, _darkprop.Target_m_set, doc=r""" mass""")
    __swig_destroy__ = _darkprop.delete_Target

    def __init__(self, *args):
        _darkprop.Target_swiginit(self, _darkprop.new_Target(*args))

# Register Target in _darkprop:
_darkprop.Target_swigregister(Target)
cvar = _darkprop.cvar
GeV = cvar.GeV
eV = cvar.eV
keV = cvar.keV
MeV = cvar.MeV
TeV = cvar.TeV
PeV = cvar.PeV
fm = cvar.fm
mm = cvar.mm
cm = cvar.cm
m = cvar.m
km = cvar.km
pc = cvar.pc
kpc = cvar.kpc
Mpc = cvar.Mpc
barn = cvar.barn
pb = cvar.pb
sec = cvar.sec
minute = cvar.minute
hour = cvar.hour
day = cvar.day
year = cvar.year
kg = cvar.kg
gram = cvar.gram
g_cm3 = cvar.g_cm3
N = cvar.N
J = cvar.J
F = cvar.F
A = cvar.A
C = cvar.C
mp = cvar.mp
mn = cvar.mn
me = cvar.me
mu = cvar.mu
rEarth = cvar.rEarth
v0 = cvar.v0
vesc = cvar.vesc
vearth = cvar.vearth

class RandomNumber(object):
    r"""Random number generator."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, seed: "int"=1):
        _darkprop.RandomNumber_swiginit(self, _darkprop.new_RandomNumber(seed))

    def uniform_phi(self) -> "double":
        r"""Sample uniform distribution on (0, pi)."""
        return _darkprop.RandomNumber_uniform_phi(self)

    def uniform_costheta(self) -> "double":
        r"""Sample uniform distribution on (-1, 1)."""
        return _darkprop.RandomNumber_uniform_costheta(self)

    def uniform_xi(self) -> "double":
        r"""Sample uniform distribution on (0, 1)."""
        return _darkprop.RandomNumber_uniform_xi(self)

    def uniform_ab(self, a: "double", b: "double") -> "double":
        r"""Sample uniform distribution on (a, b)."""
        return _darkprop.RandomNumber_uniform_ab(self, a, b)
    __swig_destroy__ = _darkprop.delete_RandomNumber

# Register RandomNumber in _darkprop:
_darkprop.RandomNumber_swigregister(RandomNumber)

class Event(object):
    r"""Store particle information for dump."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    t = property(_darkprop.Event_t_get, _darkprop.Event_t_set)
    T = property(_darkprop.Event_T_get, _darkprop.Event_T_set, doc=r"""> time""")
    r = property(_darkprop.Event_r_get, _darkprop.Event_r_set, doc=r"""> kinetic energy""")
    p3 = property(_darkprop.Event_p3_get, _darkprop.Event_p3_set, doc=r"""> position""")
    __swig_destroy__ = _darkprop.delete_Event

    def __init__(self, *args):
        _darkprop.Event_swiginit(self, _darkprop.new_Event(*args))

# Register Event in _darkprop:
_darkprop.Event_swigregister(Event)

class VectorEvent(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _darkprop.VectorEvent_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _darkprop.VectorEvent___nonzero__(self)

    def __bool__(self) -> "bool":
        return _darkprop.VectorEvent___bool__(self)

    def __len__(self) -> "std::vector< darkprop::Event< Eigen::Vector3d,double > >::size_type":
        return _darkprop.VectorEvent___len__(self)

    def __getslice__(self, i: "std::vector< darkprop::Event< Eigen::Vector3d,double > >::difference_type", j: "std::vector< darkprop::Event< Eigen::Vector3d,double > >::difference_type") -> "std::vector< darkprop::Event< Vector3,double >,std::allocator< darkprop::Event< Vector3,double > > > *":
        return _darkprop.VectorEvent___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _darkprop.VectorEvent___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< darkprop::Event< Eigen::Vector3d,double > >::difference_type", j: "std::vector< darkprop::Event< Eigen::Vector3d,double > >::difference_type") -> "void":
        return _darkprop.VectorEvent___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _darkprop.VectorEvent___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< darkprop::Event< Eigen::Vector3d,double > >::value_type const &":
        return _darkprop.VectorEvent___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _darkprop.VectorEvent___setitem__(self, *args)

    def pop(self) -> "std::vector< darkprop::Event< Eigen::Vector3d,double > >::value_type":
        return _darkprop.VectorEvent_pop(self)

    def append(self, x: "Event") -> "void":
        return _darkprop.VectorEvent_append(self, x)

    def empty(self) -> "bool":
        return _darkprop.VectorEvent_empty(self)

    def size(self) -> "std::vector< darkprop::Event< Eigen::Vector3d,double > >::size_type":
        return _darkprop.VectorEvent_size(self)

    def swap(self, v: "VectorEvent") -> "void":
        return _darkprop.VectorEvent_swap(self, v)

    def begin(self) -> "std::vector< darkprop::Event< Eigen::Vector3d,double > >::iterator":
        return _darkprop.VectorEvent_begin(self)

    def end(self) -> "std::vector< darkprop::Event< Eigen::Vector3d,double > >::iterator":
        return _darkprop.VectorEvent_end(self)

    def rbegin(self) -> "std::vector< darkprop::Event< Eigen::Vector3d,double > >::reverse_iterator":
        return _darkprop.VectorEvent_rbegin(self)

    def rend(self) -> "std::vector< darkprop::Event< Eigen::Vector3d,double > >::reverse_iterator":
        return _darkprop.VectorEvent_rend(self)

    def clear(self) -> "void":
        return _darkprop.VectorEvent_clear(self)

    def get_allocator(self) -> "std::vector< darkprop::Event< Eigen::Vector3d,double > >::allocator_type":
        return _darkprop.VectorEvent_get_allocator(self)

    def pop_back(self) -> "void":
        return _darkprop.VectorEvent_pop_back(self)

    def erase(self, *args) -> "std::vector< darkprop::Event< Eigen::Vector3d,double > >::iterator":
        return _darkprop.VectorEvent_erase(self, *args)

    def __init__(self, *args):
        _darkprop.VectorEvent_swiginit(self, _darkprop.new_VectorEvent(*args))

    def push_back(self, x: "Event") -> "void":
        return _darkprop.VectorEvent_push_back(self, x)

    def front(self) -> "std::vector< darkprop::Event< Eigen::Vector3d,double > >::value_type const &":
        return _darkprop.VectorEvent_front(self)

    def back(self) -> "std::vector< darkprop::Event< Eigen::Vector3d,double > >::value_type const &":
        return _darkprop.VectorEvent_back(self)

    def assign(self, n: "std::vector< darkprop::Event< Eigen::Vector3d,double > >::size_type", x: "Event") -> "void":
        return _darkprop.VectorEvent_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _darkprop.VectorEvent_resize(self, *args)

    def insert(self, *args) -> "void":
        return _darkprop.VectorEvent_insert(self, *args)

    def reserve(self, n: "std::vector< darkprop::Event< Eigen::Vector3d,double > >::size_type") -> "void":
        return _darkprop.VectorEvent_reserve(self, n)

    def capacity(self) -> "std::vector< darkprop::Event< Eigen::Vector3d,double > >::size_type":
        return _darkprop.VectorEvent_capacity(self)
    __swig_destroy__ = _darkprop.delete_VectorEvent

# Register VectorEvent in _darkprop:
_darkprop.VectorEvent_swigregister(VectorEvent)

class VectorTarget(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self) -> "swig::SwigPyIterator *":
        return _darkprop.VectorTarget_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self) -> "bool":
        return _darkprop.VectorTarget___nonzero__(self)

    def __bool__(self) -> "bool":
        return _darkprop.VectorTarget___bool__(self)

    def __len__(self) -> "std::vector< darkprop::Target >::size_type":
        return _darkprop.VectorTarget___len__(self)

    def __getslice__(self, i: "std::vector< darkprop::Target >::difference_type", j: "std::vector< darkprop::Target >::difference_type") -> "std::vector< darkprop::Target,std::allocator< darkprop::Target > > *":
        return _darkprop.VectorTarget___getslice__(self, i, j)

    def __setslice__(self, *args) -> "void":
        return _darkprop.VectorTarget___setslice__(self, *args)

    def __delslice__(self, i: "std::vector< darkprop::Target >::difference_type", j: "std::vector< darkprop::Target >::difference_type") -> "void":
        return _darkprop.VectorTarget___delslice__(self, i, j)

    def __delitem__(self, *args) -> "void":
        return _darkprop.VectorTarget___delitem__(self, *args)

    def __getitem__(self, *args) -> "std::vector< darkprop::Target >::value_type const &":
        return _darkprop.VectorTarget___getitem__(self, *args)

    def __setitem__(self, *args) -> "void":
        return _darkprop.VectorTarget___setitem__(self, *args)

    def pop(self) -> "std::vector< darkprop::Target >::value_type":
        return _darkprop.VectorTarget_pop(self)

    def append(self, x: "Target") -> "void":
        return _darkprop.VectorTarget_append(self, x)

    def empty(self) -> "bool":
        return _darkprop.VectorTarget_empty(self)

    def size(self) -> "std::vector< darkprop::Target >::size_type":
        return _darkprop.VectorTarget_size(self)

    def swap(self, v: "VectorTarget") -> "void":
        return _darkprop.VectorTarget_swap(self, v)

    def begin(self) -> "std::vector< darkprop::Target >::iterator":
        return _darkprop.VectorTarget_begin(self)

    def end(self) -> "std::vector< darkprop::Target >::iterator":
        return _darkprop.VectorTarget_end(self)

    def rbegin(self) -> "std::vector< darkprop::Target >::reverse_iterator":
        return _darkprop.VectorTarget_rbegin(self)

    def rend(self) -> "std::vector< darkprop::Target >::reverse_iterator":
        return _darkprop.VectorTarget_rend(self)

    def clear(self) -> "void":
        return _darkprop.VectorTarget_clear(self)

    def get_allocator(self) -> "std::vector< darkprop::Target >::allocator_type":
        return _darkprop.VectorTarget_get_allocator(self)

    def pop_back(self) -> "void":
        return _darkprop.VectorTarget_pop_back(self)

    def erase(self, *args) -> "std::vector< darkprop::Target >::iterator":
        return _darkprop.VectorTarget_erase(self, *args)

    def __init__(self, *args):
        _darkprop.VectorTarget_swiginit(self, _darkprop.new_VectorTarget(*args))

    def push_back(self, x: "Target") -> "void":
        return _darkprop.VectorTarget_push_back(self, x)

    def front(self) -> "std::vector< darkprop::Target >::value_type const &":
        return _darkprop.VectorTarget_front(self)

    def back(self) -> "std::vector< darkprop::Target >::value_type const &":
        return _darkprop.VectorTarget_back(self)

    def assign(self, n: "std::vector< darkprop::Target >::size_type", x: "Target") -> "void":
        return _darkprop.VectorTarget_assign(self, n, x)

    def resize(self, *args) -> "void":
        return _darkprop.VectorTarget_resize(self, *args)

    def insert(self, *args) -> "void":
        return _darkprop.VectorTarget_insert(self, *args)

    def reserve(self, n: "std::vector< darkprop::Target >::size_type") -> "void":
        return _darkprop.VectorTarget_reserve(self, n)

    def capacity(self) -> "std::vector< darkprop::Target >::size_type":
        return _darkprop.VectorTarget_capacity(self)
    __swig_destroy__ = _darkprop.delete_VectorTarget

# Register VectorTarget in _darkprop:
_darkprop.VectorTarget_swigregister(VectorTarget)

class Particle(object):
    r"""Base abstract Particle class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    m = property(_darkprop.Particle_m_get, _darkprop.Particle_m_set, doc=r""" mass""")
    sigma0 = property(_darkprop.Particle_sigma0_get, _darkprop.Particle_sigma0_set, doc=r""" cross section""")
    t = property(_darkprop.Particle_t_get, _darkprop.Particle_t_set, doc=r""" time""")
    T = property(_darkprop.Particle_T_get, _darkprop.Particle_T_set, doc=r""" kinetic energy""")
    r = property(_darkprop.Particle_r_get, _darkprop.Particle_r_set, doc=r""" position""")
    v = property(_darkprop.Particle_v_get, _darkprop.Particle_v_set, doc=r""" velocity""")
    p3 = property(_darkprop.Particle_p3_get, _darkprop.Particle_p3_set, doc=r""" 3 momentum""")
    ep = property(_darkprop.Particle_ep_get, _darkprop.Particle_ep_set, doc=r""" velocity (momentum) direction""")
    er = property(_darkprop.Particle_er_get, _darkprop.Particle_er_set, doc=r""" position direction""")
    in_earth = property(_darkprop.Particle_in_earth_get, _darkprop.Particle_in_earth_set, doc=r""" switch indicating whether to continue the simulation""")
    __swig_destroy__ = _darkprop.delete_Particle

    def pFromT(self) -> "double":
        return _darkprop.Particle_pFromT(self)

    def TFromP3(self) -> "double":
        return _darkprop.Particle_TFromP3(self)

    def updateEr(self) -> "void":
        return _darkprop.Particle_updateEr(self)

    def updateEp(self) -> "void":
        return _darkprop.Particle_updateEp(self)

    def updateVwithP3T(self) -> "void":
        return _darkprop.Particle_updateVwithP3T(self)

    def updateP3TwithV(self) -> "void":
        return _darkprop.Particle_updateP3TwithV(self)

    def setR(self, t_r: "Eigen::Vector3d") -> "void":
        return _darkprop.Particle_setR(self, t_r)

    def setP(self, t_p: "Eigen::Vector3d") -> "void":
        return _darkprop.Particle_setP(self, t_p)

    def setV(self, t_v: "Eigen::Vector3d") -> "void":
        return _darkprop.Particle_setV(self, t_v)

    def totalCrossSection(self, t: "Target") -> "double":
        r"""
        Total cross section scattering with Target ``t``.
        Use current ``this-``>T as initial kinetic energy.
        """
        return _darkprop.Particle_totalCrossSection(self, t)

    def scatteringSampleTr(self, t: "Target", rn: "RandomNumber") -> "double":
        r"""Sample recoil kinetic energy of the target particle in laboratory frame."""
        return _darkprop.Particle_scatteringSampleTr(self, t, rn)

    def scatteringCosTheta(self, t: "Target", Tr: "double") -> "double":
        r"""Return cosine of scattering angle of DM particle in laboratory frame."""
        return _darkprop.Particle_scatteringCosTheta(self, t, Tr)

    def toEvent(self, kmsec: "bool"=True) -> "darkprop::Event< Eigen::Vector3d,double >":
        r"""
        Generate a Event from the current state.
        :type kmsec: boolean, optional
        :param kmsec: if true the quantities ``t`` and ``r`` will be in unit of
            second and kilomiter respecively, otherwise remain natural unit with
            GeV = 1. Default ``true``.
        """
        return _darkprop.Particle_toEvent(self, kmsec)

# Register Particle in _darkprop:
_darkprop.Particle_swigregister(Particle)

class Earth(object):
    r"""Base abstract Earth class."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    targets = property(_darkprop.Earth_targets_get, _darkprop.Earth_targets_set)
    __swig_destroy__ = _darkprop.delete_Earth

    def setCache(self, arg2: "Particle") -> "void":
        return _darkprop.Earth_setCache(self, arg2)

    def getTargets(self) -> "std::vector< darkprop::Target,std::allocator< darkprop::Target > > const &":
        return _darkprop.Earth_getTargets(self)

    def propagate(self, particle: "Particle", rn: "RandomNumber") -> "void":
        r"""
        Propagate a particle.
        Sample a free path and propagate the particle and determine whether
        the particle in Earth or not.
        Set ``particle.in_earth`` to false if the simulation should stop.
        """
        return _darkprop.Earth_propagate(self, particle, rn)

    def sampleTarget(self, particle: "Particle", rn: "RandomNumber") -> "darkprop::Target":
        r"""Sample a target before scattering."""
        return _darkprop.Earth_sampleTarget(self, particle, rn)

# Register Earth in _darkprop:
_darkprop.Earth_swigregister(Earth)


def scatter(p: "Particle", earth: "Earth", rn: "RandomNumber") -> "bool":
    r"""
    Basic interface for Particle scattering in the Earth.

    Update ``T``, ``p3``, ``v``, ``ep`` of the ``particle`` after a scattering.
    Use ``Earth.sampleTarget``, ``Particle.scatteringSampleTr`` and
    ``Particle.scatteringCosTheta``.
    """
    return _darkprop.scatter(p, earth, rn)

def propagate(p: "Particle", earth: "Earth", rn: "RandomNumber") -> "bool":
    r"""
    Basic interface for Particle propagating the in Earth.

    Simply wrap Earth.propagate.
    """
    return _darkprop.propagate(p, earth, rn)
class SIDM(Particle):
    r"""Spin independent elastic scattering DM model with constant cross section."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _darkprop.SIDM_swiginit(self, _darkprop.new_SIDM(*args))
    __swig_destroy__ = _darkprop.delete_SIDM

    def sigmaEff(self, t: "Target") -> "double":
        return _darkprop.SIDM_sigmaEff(self, t)

    def maximumRecoilT(self, target: "Target") -> "double":
        return _darkprop.SIDM_maximumRecoilT(self, target)

    def differentialCrossSection(self, Tr: "double", t: "Target") -> "double":
        return _darkprop.SIDM_differentialCrossSection(self, Tr, t)

    def totalCrossSection(self, t: "Target") -> "double":
        return _darkprop.SIDM_totalCrossSection(self, t)

    def scatteringSampleTr(self, t: "Target", rn: "RandomNumber") -> "double":
        return _darkprop.SIDM_scatteringSampleTr(self, t, rn)

    def scatteringCosTheta(self, t: "Target", Tr: "double") -> "double":
        return _darkprop.SIDM_scatteringCosTheta(self, t, Tr)

# Register SIDM in _darkprop:
_darkprop.SIDM_swigregister(SIDM)

class SIHelmDM(SIDM):
    r"""Spin independent elastic scattering DM model with Helm form factor."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _darkprop.SIHelmDM_swiginit(self, _darkprop.new_SIHelmDM(*args))
    __swig_destroy__ = _darkprop.delete_SIHelmDM

    def differentialCrossSection(self, Tr: "double", t: "Target") -> "double":
        return _darkprop.SIHelmDM_differentialCrossSection(self, Tr, t)

    @staticmethod
    def integrand(q2: "double", t_A: "void *") -> "double":
        return _darkprop.SIHelmDM_integrand(q2, t_A)

    def init_integral_of_ff2(self, Trmin: "double", Trmax: "double", t: "Target", n: "std::size_t") -> "void":
        return _darkprop.SIHelmDM_init_integral_of_ff2(self, Trmin, Trmax, t, n)

    def initCrossSectionCDF(self, Trmin: "double", Trmax: "double", t: "Target", n: "std::size_t") -> "void":
        return _darkprop.SIHelmDM_initCrossSectionCDF(self, Trmin, Trmax, t, n)

    def ff2Integral(self, q2: "double", t: "Target") -> "double":
        return _darkprop.SIHelmDM_ff2Integral(self, q2, t)

    def inverseCDF(self, xi: "double", t: "Target") -> "double":
        return _darkprop.SIHelmDM_inverseCDF(self, xi, t)

    def scatteringSampleTr(self, t: "Target", rn: "RandomNumber") -> "double":
        return _darkprop.SIHelmDM_scatteringSampleTr(self, t, rn)

    def totalCrossSection(self, t: "Target") -> "double":
        return _darkprop.SIHelmDM_totalCrossSection(self, t)

# Register SIHelmDM in _darkprop:
_darkprop.SIHelmDM_swigregister(SIHelmDM)

def SIHelmDM_integrand(q2: "double", t_A: "void *") -> "double":
    return _darkprop.SIHelmDM_integrand(q2, t_A)

class HomoEarth(Earth):
    r"""A homogeneous Earth model composed of 8 components."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    rfinal = property(_darkprop.HomoEarth_rfinal_get, _darkprop.HomoEarth_rfinal_set)
    use_cache = property(_darkprop.HomoEarth_use_cache_get, _darkprop.HomoEarth_use_cache_set)
    cached_lambda = property(_darkprop.HomoEarth_cached_lambda_get, _darkprop.HomoEarth_cached_lambda_set)

    def calcLambda(self, *args) -> "double":
        return _darkprop.HomoEarth_calcLambda(self, *args)

    def __init__(self, *args, **kwargs):
        _darkprop.HomoEarth_swiginit(self, _darkprop.new_HomoEarth(*args, **kwargs))
    __swig_destroy__ = _darkprop.delete_HomoEarth

    def getTargets(self) -> "std::vector< darkprop::Target,std::allocator< darkprop::Target > > const &":
        return _darkprop.HomoEarth_getTargets(self)

    def setCache(self, p: "Particle") -> "void":
        return _darkprop.HomoEarth_setCache(self, p)

    def propagate(self, particle: "Particle", rn: "RandomNumber") -> "void":
        return _darkprop.HomoEarth_propagate(self, particle, rn)

    def sampleTarget(self, particle: "Particle", rn: "RandomNumber") -> "darkprop::Target":
        return _darkprop.HomoEarth_sampleTarget(self, particle, rn)

# Register HomoEarth in _darkprop:
_darkprop.HomoEarth_swigregister(HomoEarth)
HomoEarth.density = _darkprop.cvar.HomoEarth_density
HomoEarth.radius2 = _darkprop.cvar.HomoEarth_radius2

class HomoElectronEarth(Earth):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args, **kwargs):
        _darkprop.HomoElectronEarth_swiginit(self, _darkprop.new_HomoElectronEarth(*args, **kwargs))
    __swig_destroy__ = _darkprop.delete_HomoElectronEarth

    def setRFinal(self, t_rfinal: "double") -> "void":
        return _darkprop.HomoElectronEarth_setRFinal(self, t_rfinal)

    def getTargets(self) -> "std::vector< darkprop::Target,std::allocator< darkprop::Target > > const &":
        return _darkprop.HomoElectronEarth_getTargets(self)

    def calcLambda(self, p: "Particle") -> "double":
        return _darkprop.HomoElectronEarth_calcLambda(self, p)

    def setCache(self, p: "Particle") -> "void":
        return _darkprop.HomoElectronEarth_setCache(self, p)

    def propagate(self, p: "Particle", rn: "RandomNumber") -> "void":
        return _darkprop.HomoElectronEarth_propagate(self, p, rn)

    def sampleTarget(self, particle: "Particle", rn: "RandomNumber") -> "darkprop::Target":
        return _darkprop.HomoElectronEarth_sampleTarget(self, particle, rn)

# Register HomoElectronEarth in _darkprop:
_darkprop.HomoElectronEarth_swigregister(HomoElectronEarth)

class PREMEarth(Earth):
    r"""Preliminary reference Earth model (PREM)."""

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cross_section_energy_dependent = property(_darkprop.PREMEarth_cross_section_energy_dependent_get, _darkprop.PREMEarth_cross_section_energy_dependent_set)
    rfinal = property(_darkprop.PREMEarth_rfinal_get, _darkprop.PREMEarth_rfinal_set)
    accuracy = property(_darkprop.PREMEarth_accuracy_get, _darkprop.PREMEarth_accuracy_set)
    maxit = property(_darkprop.PREMEarth_maxit_get, _darkprop.PREMEarth_maxit_set)

    def __init__(self, *args, **kwargs):
        _darkprop.PREMEarth_swiginit(self, _darkprop.new_PREMEarth(*args, **kwargs))
    __swig_destroy__ = _darkprop.delete_PREMEarth

    def getLayer(self, r: "double") -> "int":
        return _darkprop.PREMEarth_getLayer(self, r)

    def getLayerRadius(self, layer: "int") -> "double":
        return _darkprop.PREMEarth_getLayerRadius(self, layer)

    def setPREM(self, p: "Particle") -> "void":
        return _darkprop.PREMEarth_setPREM(self, p)

    def setCache(self, p: "Particle") -> "void":
        return _darkprop.PREMEarth_setCache(self, p)

    def getTargets(self) -> "std::vector< darkprop::Target,std::allocator< darkprop::Target > > const &":
        return _darkprop.PREMEarth_getTargets(self)

    def propagate(self, particle: "Particle", rn: "RandomNumber") -> "void":
        return _darkprop.PREMEarth_propagate(self, particle, rn)

    def sampleTarget(self, particle: "Particle", rn: "RandomNumber") -> "darkprop::Target":
        return _darkprop.PREMEarth_sampleTarget(self, particle, rn)

    def toNextBoundary(self, r0: "Eigen::Vector3d const &", ep: "Eigen::Vector3d const &", on_bound: "int &", in_layer: "int &") -> "double":
        return _darkprop.PREMEarth_toNextBoundary(self, r0, ep, on_bound, in_layer)

    def densityIntegral(self, r0: "double", cosa: "double", L: "double", layer: "std::size_t") -> "double":
        return _darkprop.PREMEarth_densityIntegral(self, r0, cosa, L, layer)

    def density(self, r: "double", layer: "int") -> "double":
        return _darkprop.PREMEarth_density(self, r, layer)

# Register PREMEarth in _darkprop:
_darkprop.PREMEarth_swigregister(PREMEarth)


def simulate_track(p: "Particle", earth: "Earth", Tcut: "double", rn: "RandomNumber") -> "std::vector< darkprop::Event< Eigen::Vector3d,double >,std::allocator< darkprop::Event< Vector3,double > > >":
    r"""Run a simulation and return the complete trajectory."""
    return _darkprop.simulate_track(p, earth, Tcut, rn)

def simulate_cross_sphere(p: "Particle", earth: "Earth", Tcut: "double", r0: "Eigen::Vector3d const &", R: "double", rn: "RandomNumber") -> "Eigen::Vector3d const &":
    r"""Run a simulation and collect events that cross a sphere."""
    return _darkprop.simulate_cross_sphere(p, earth, Tcut, r0, R, rn)

def simulate_cross_depth(p: "Particle", earth: "Earth", Tcut: "double", depth: "std::vector< double,std::allocator< double > >", rn: "RandomNumber") -> "std::vector< std::vector< darkprop::Event< Eigen::Vector3d,double >,std::allocator< darkprop::Event< Eigen::Vector3d,double > > >,std::allocator< std::vector< darkprop::Event< Vector3,double >,std::allocator< darkprop::Event< Vector3,double > > > > >":
    r"""Run a simulation and collect crossing events on several depths."""
    return _darkprop.simulate_cross_depth(p, earth, Tcut, depth, rn)

def norm_maxwell(*args, **kwargs) -> "double":
    r"""The normalization of Maxwell velocity distribution (vesc = +inf)."""
    return _darkprop.norm_maxwell(*args, **kwargs)

def norm_esc(*args, **kwargs) -> "double":
    r"""
    The normalization of halo DM velocity distribution with a finite escape
    velocity.
    """
    return _darkprop.norm_esc(*args, **kwargs)

def fv_halo_1d(*args, **kwargs) -> "double":
    r"""Halo DM 1D speed distribution."""
    return _darkprop.fv_halo_1d(*args, **kwargs)

def sample_halo_speed(*args, **kwargs) -> "double":
    r"""
    Sample 1D halo speed from the isotropic SHM.

    :type vesc: float, optional
    :param vesc: escape speed  upper bound  lower bound  random number gen
    :type v0: float, optional
    :param v0: most probable speed
    """
    return _darkprop.sample_halo_speed(*args, **kwargs)

def random_isotropic_vector(rn: "RandomNumber", len: "double"=1) -> "Eigen::Vector3d":
    r"""Sample a random vector isotropicly with length ``len`` (default 1)."""
    return _darkprop.random_isotropic_vector(rn, len)

def sample_halo_velocity_earth_frame(*args, **kwargs) -> "Eigen::Vector3d":
    r"""
    Sample 3D halo velocity in the Earth frame from the SHM.

    The sampling range can be set to (``vmin``, ``vmax)``. If ``vmax`` <= 0, it
    will be set to ``v_earth.norm()`` + ``vesc``.

    :type vesc: float, optional
    :param vesc: halo escape speed  speed upper bound  speed lower bound  random number generator  earth velocity
    :type v0: float, optional
    :param v0: halo most probable speed
    """
    return _darkprop.sample_halo_velocity_earth_frame(*args, **kwargs)

def random_incident_position(*args, **kwargs) -> "Eigen::Vector3d const &":
    r"""Sample an incident position according to the given direction."""
    return _darkprop.random_incident_position(*args, **kwargs)

def init_halo(*args, **kwargs) -> "Eigen::Vector3d const &":
    r"""
    Set halo DM random initial condition.

    ``vmin`` and ``vmax`` are in the Earth frame.

    :type v0: float, optional
    :param v0: halo most probable speed  halo escape velocity  speed upper bound  initail disk distance  random number generator  velocity of the Earth  speed lower bound  initial time
    """
    return _darkprop.init_halo(*args, **kwargs)

def init_Tbl(*args, **kwargs) -> "void":
    r"""
    Set initial condition of a particle with energy T and direction in galactic
    coordinate (b, l).
    """
    return _darkprop.init_Tbl(*args, **kwargs)

def init_Tbl_vertical(*args, **kwargs) -> "void":
    return _darkprop.init_Tbl_vertical(*args, **kwargs)

def init_T_isotropic(*args, **kwargs) -> "void":
    r"""Set initial condition of a particle isotropically with energy T."""
    return _darkprop.init_T_isotropic(*args, **kwargs)

def inject(*args, **kwargs) -> "void":
    r"""Place the particle on the the Earth's surface."""
    return _darkprop.inject(*args, **kwargs)


