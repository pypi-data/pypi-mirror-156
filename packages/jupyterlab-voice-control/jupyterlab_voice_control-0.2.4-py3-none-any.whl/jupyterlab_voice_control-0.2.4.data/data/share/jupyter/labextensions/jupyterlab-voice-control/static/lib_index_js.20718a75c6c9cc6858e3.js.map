{"version":3,"file":"lib_index_js.20718a75c6c9cc6858e3.js","mappings":";;;;;;;;;;;;;;;;;;AAAqD;AAC9C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+DAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;;;;;ACnH+B;AAC+B;AACF;AACe;AACpE,0CAA0C,6DAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAmB,CAAC,2DAAS,IAAI,qBAAqB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0DAAsB;AACxC,kBAAkB,2DAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gDAAmB,CAAC,4DAAS,IAAI;AACrD;AACA;AACA;AACA,mBAAmB;AACnB,gBAAgB,gDAAmB,eAAe,+BAA+B;AACjF,qDAAqD,gDAAmB,CAAC,2DAAQ,IAAI,8EAA8E,MAAM,gDAAmB;AAC5L,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;;;;ACpC+C;AACJ;AACa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qDAAM;AACvC;AACA;AACA,YAAY,sEAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sEAAgB;AACpC;AACA;AACA,oBAAoB,sEAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,6DAAQ,0BAA0B,6DAAQ;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,UAAU,IAAI,gBAAgB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AChPoD;AACG;AACO;AACvD,mCAAmC,8DAAO;AACjD;AACA,YAAY,mEAAU;AACtB,CAAC;AACM,oCAAoC,8DAAO;AAClD;AACA,YAAY,uEAAa;AACzB,CAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACV2C;AACW;AACJ;AACmB;AACP;AACG;AACnB;AACyB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iEAAe;AAC9B,eAAe,yEAAgB,EAAE,6DAAU,EAAE,gEAAW;AACxD;AACA;AACA,mCAAmC,mEAAc;AACjD;AACA,+BAA+B,wDAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,oCAAoC,+DAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,0BAA0B,2EAA2B;AACrD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,6BAA6B,mDAAQ;AACrC,SAAS;AACT;AACA;AACA,6BAA6B,mDAAQ;AACrC,SAAS;AACT;AACA;AACA,6BAA6B,qDAAU;AACvC,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,6BAA6B,qDAAU;AACvC,SAAS;AACT;AACA;AACA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;;ACxHtB,iEAAe,giBAAgiB;;;;;;;;;;;;;;ACA/iB,iEAAe,uWAAuW","sources":["webpack://jupyterlab-voice-control/./lib/commands.js","webpack://jupyterlab-voice-control/./lib/components/status.js","webpack://jupyterlab-voice-control/./lib/controller.js","webpack://jupyterlab-voice-control/./lib/icons.js","webpack://jupyterlab-voice-control/./lib/index.js","webpack://jupyterlab-voice-control/./style/icons/microphone-off.svg","webpack://jupyterlab-voice-control/./style/icons/microphone.svg"],"sourcesContent":["import { NotebookPanel } from '@jupyterlab/notebook';\nexport function moveCursor(options) {\n    const focused = document.activeElement;\n    if (!focused) {\n        return 'Cannot move cursor: no element is focused';\n    }\n    if (typeof focused.value !== 'undefined') {\n        const input = focused;\n        if (options.to === 'start') {\n            input.setSelectionRange(0, 0);\n            input.focus();\n        }\n        if (options.to === 'end') {\n            const end = input.value.length;\n            input.setSelectionRange(end, end);\n            input.focus();\n        }\n    }\n}\nfunction getEditor(widget) {\n    if (widget instanceof NotebookPanel) {\n        const activeCell = widget.content.activeCell;\n        if (activeCell) {\n            return activeCell.editor;\n        }\n    }\n    else if (typeof widget.content.editor !== 'undefined') {\n        return widget.content.editor;\n    }\n    else if (typeof widget.editor !== 'undefined') {\n        return widget.editor;\n    }\n    return null;\n}\nexport function typeText(options, currentWidget) {\n    if (typeof options.text === 'undefined') {\n        return 'No text provided';\n    }\n    // Try to use Editor interface if current widget has it (and the editor has focus)\n    const editor = getEditor(currentWidget);\n    if (editor && editor.hasFocus) {\n        const cursor = editor.getCursorPosition();\n        const offset = editor.getOffsetAt(cursor);\n        editor.model.value.insert(offset, options.text);\n        const updatedPosition = editor.getPositionAt(offset + options.text.length);\n        if (updatedPosition) {\n            editor.setCursorPosition(updatedPosition);\n        }\n        return;\n    }\n    const focused = document.activeElement;\n    if (!focused) {\n        return 'Cannot type: no element is focused';\n    }\n    if (typeof focused.value !== 'undefined') {\n        focused.value += options.text;\n    }\n    else {\n        for (const key of options.text) {\n            console.log(key.charCodeAt(0), key);\n            focused.dispatchEvent(new KeyboardEvent('keydown', {\n                key: key,\n                keyCode: key.charCodeAt(0),\n                code: key,\n                shiftKey: false,\n                ctrlKey: false,\n                metaKey: false,\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                which: key.charCodeAt(0)\n            }));\n        }\n    }\n}\nexport function deleteText(options, currentWidget) {\n    if (typeof options.what === 'undefined') {\n        return 'No \"what\" argument provided';\n    }\n    // Try to use Editor interface if current widget has it (and the editor has focus)\n    const editor = getEditor(currentWidget);\n    if (editor && editor.hasFocus) {\n        const cursor = editor.getCursorPosition();\n        const offset = editor.getOffsetAt(cursor);\n        const valueUpToCursor = editor.model.value.text.substring(0, offset);\n        const lastSpace = valueUpToCursor.lastIndexOf(' ');\n        editor.model.value.remove(lastSpace, offset);\n        const updatedPosition = editor.getPositionAt(lastSpace);\n        if (updatedPosition) {\n            editor.setCursorPosition(updatedPosition);\n        }\n        return;\n    }\n    const focused = document.activeElement;\n    if (!focused) {\n        return 'Cannot delete: no element is focused';\n    }\n    if (typeof focused.value !== 'undefined') {\n        const value = focused.value;\n        const lastSpace = value.lastIndexOf(' ');\n        focused.value = value.substring(0, lastSpace);\n    }\n}\nexport function scrollBy(options) {\n    const focused = document.activeElement;\n    if (!focused) {\n        return 'Cannot scroll: no element is focused';\n    }\n    if (options.behavior == null) {\n        options.behavior = 'smooth';\n    }\n    focused.scrollBy({\n        top: ((options.topPercent || 0) / 100) * window.innerHeight,\n        left: ((options.leftPercent || 0) / 100) * window.innerWidth,\n        behavior: options.behavior\n    });\n}\n","import * as React from 'react';\nimport { ReactWidget, UseSignal } from '@jupyterlab/apputils';\nimport { GroupItem, TextItem } from '@jupyterlab/statusbar';\nimport { recognitionEnabledIcon, recognitionDisabledIcon } from '../icons';\nexport class VoiceControlStatusIndicator extends ReactWidget {\n    constructor(signal, trans, controller) {\n        super();\n        this.signal = signal;\n        this.trans = trans;\n        this.controller = controller;\n    }\n    render() {\n        return (React.createElement(UseSignal, { signal: this.signal }, (sender, status) => {\n            if (!status) {\n                status = {\n                    enabled: false\n                };\n            }\n            const icon = status.enabled\n                ? recognitionEnabledIcon\n                : recognitionDisabledIcon;\n            const confidence = status.lastConfidence\n                ? Math.round(status.lastConfidence * 100)\n                : '?';\n            const text = status.executed ? this.trans.__('Executed %1 based on %2 (%3%)', status.executed.label, status.lastResult, confidence) : this.trans.__('Recognised %1 (%2%) but don\\'t understand.', status.lastResult, confidence);\n            const shortText = status.executed ? this.trans.__('ðŸ™‚ executed', status.lastResult) : this.trans.__('ðŸ¤” %1 (%2%)', status.lastResult, confidence);\n            const controller = this.controller;\n            return (React.createElement(GroupItem, { spacing: 0, title: text, onClick: () => {\n                    controller.isEnabled\n                        ? controller.disable()\n                        : controller.enable();\n                } },\n                React.createElement(icon.react, { top: '2px', kind: 'statusBar' }),\n                status.error || status.lastResult ? (React.createElement(TextItem, { className: 'status-message', source: status.error ? status.error : shortText })) : (React.createElement(\"div\", null))));\n        }));\n    }\n}\n","import { distance } from 'fastest-levenshtein';\nimport { Signal } from '@lumino/signaling';\nimport { showErrorMessage } from '@jupyterlab/apputils';\nfunction normalise(text) {\n    return text.toLowerCase().trim();\n}\nconst ordinals = {\n    first: 1,\n    second: 2,\n    third: 3,\n    fourth: 4,\n    fifth: 5\n};\nexport class VoiceController {\n    constructor(commandRegistry, trans, palette) {\n        this.commandRegistry = commandRegistry;\n        this.trans = trans;\n        this.speak = false;\n        this.commands = [];\n        this.suggestionThreshold = 0.5;\n        this.counter = 0;\n        this._currentSuggestions = [];\n        this.statusChanged = new Signal(this);\n        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n        if (!SpeechRecognition) {\n            showErrorMessage(trans.__('Speech recognition not supported'), trans.__('Your browser does not support speech recognition.'));\n            throw Error('Not supported');\n        }\n        this.recognition = new SpeechRecognition();\n        this.recognition.continuous = true;\n        this.recognition.interimResults = false;\n        this.recognition.maxAlternatives = 1;\n        this.confidenceThreshold = 0;\n        this._status = {\n            enabled: false\n        };\n        this.jupyterCommands = new Map();\n        this.recognition.onresult = this.handleSpeechResult.bind(this);\n        this.recognition.onspeechend = event => {\n            console.log('speech end');\n            this.disable();\n        };\n        this.recognition.onerror = event => {\n            const title = this.trans.__('Speech recognition not available');\n            switch (event.error) {\n                case 'audio-capture':\n                    showErrorMessage(title, this.trans.__('Microphone not detected'));\n                    break;\n                case 'not-allowed':\n                    showErrorMessage(title, this.trans.__('Access to microphone was denied or blocked'));\n                    break;\n                case 'no-speech':\n                    this._status.error = this.trans.__('No speech was detected');\n                    break;\n            }\n        };\n        commandRegistry.commandChanged.connect(() => {\n            this.updateGrammar();\n        });\n        this.updateGrammar();\n    }\n    matchPhrase(phrase) {\n        // First try to match against our voice commands which get a higher priority\n        for (const command of this.commands) {\n            const match = phrase.match(new RegExp(command.phrase, 'i'));\n            if (match != null) {\n                if (!this.commandRegistry.hasCommand(command.command)) {\n                    return {\n                        message: this.trans.__('Matched \"%1\" phrase but command \"%2\" is not in the registry', command.phrase, command.command)\n                    };\n                }\n                const args = Object.assign({}, command.arguments);\n                if (match.groups) {\n                    Object.assign(args, match.groups);\n                }\n                return {\n                    match: {\n                        id: command.command,\n                        label: command.phrase,\n                        arguments: args\n                    }\n                };\n            }\n        }\n        // If it did not succeed, match against all JupyterLab commands\n        const command = this.jupyterCommands.get(phrase);\n        if (command) {\n            return { match: {\n                    id: command.id,\n                    label: command.label,\n                    arguments: {}\n                } };\n        }\n        else {\n            let best = Infinity;\n            let bestCandidates = [];\n            for (const [candidateLabel, command] of this.jupyterCommands.entries()) {\n                const matchScore = Math.min(distance(candidateLabel, phrase), distance(normalise(command.caption), phrase));\n                if (matchScore < best) {\n                    best = matchScore;\n                    bestCandidates = [command];\n                }\n                else if (matchScore === best) {\n                    bestCandidates.push(command);\n                }\n            }\n            if (bestCandidates.length !== 0 &&\n                best / phrase.length <= this.suggestionThreshold) {\n                const suggestionText = this.trans.__('Did you mean %1?', bestCandidates.length === 1\n                    ? bestCandidates[0].label\n                    : bestCandidates\n                        .map((candidate, index) => `${index + 1}) ${candidate.label}`)\n                        .join(' or '));\n                const suggestions = bestCandidates.map(candidate => {\n                    return {\n                        command: {\n                            id: candidate.id,\n                            label: candidate.label,\n                        },\n                        score: best\n                    };\n                });\n                return {\n                    message: suggestionText,\n                    suggestions: suggestions\n                };\n            }\n        }\n        return {};\n    }\n    communicate(message) {\n        this._status.error = message;\n        if (this.speak) {\n            speechSynthesis.speak(new SpeechSynthesisUtterance(message));\n        }\n    }\n    handleSpeechResult(event) {\n        const result = event.results[this.counter][0];\n        const speech = normalise(result.transcript);\n        this._status.lastResult = speech;\n        this._status.lastConfidence = result.confidence;\n        this.counter += 1;\n        if (result.confidence < this.confidenceThreshold) {\n            this.communicate(this.trans.__('Too low confidence. Speak up?'));\n            this.statusChanged.emit(this._status);\n            console.log('Discarding the result due to too low confidence');\n            return;\n        }\n        this._status.error = undefined;\n        this._status.executed = undefined;\n        const matchResult = this.matchPhrase(speech);\n        if (matchResult.match) {\n            this.execute(matchResult.match);\n        }\n        if (matchResult.message) {\n            this.communicate(matchResult.message);\n        }\n        this._currentSuggestions = matchResult.suggestions || [];\n        this.statusChanged.emit(this._status);\n    }\n    execute(command) {\n        this._status.executed = command;\n        this.commandRegistry.execute(command.id, command.arguments);\n    }\n    acceptSuggestion(options) {\n        const option = options.option != null ? ordinals[options.option] - 1 : 0;\n        if (typeof option !== 'undefined') {\n            if (this._currentSuggestions.length > option) {\n                this.execute(this._currentSuggestions[option].command);\n                this._currentSuggestions = [];\n            }\n            else {\n                this.communicate(this.trans.__('Suggestion %1 not available.', option + 1));\n            }\n        }\n        else {\n            console.warn('Could not resolve option to accept suggestion', options);\n        }\n    }\n    set language(value) {\n        this.recognition.lang = value;\n    }\n    updateGrammar() {\n        this.jupyterCommands.clear();\n        this.commandRegistry\n            .listCommands()\n            .filter(commandID => {\n            try {\n                return this.commandRegistry.isVisible(commandID);\n            }\n            catch (e) {\n                // some commands require arguments to `isVisible` thus\n                // we cannot know if they should be included or not,\n                // but since users can specify custom trigger phrases\n                // with appropriate arguments in settings, we do not\n                // want to exclude those commands.\n                return true;\n            }\n        })\n            .map(commandID => {\n            try {\n                const label = this.commandRegistry.label(commandID);\n                const caption = this.commandRegistry.caption(commandID);\n                if (label) {\n                    this.jupyterCommands.set(normalise(label), {\n                        id: commandID,\n                        caption: caption,\n                        label: label\n                    });\n                }\n                return label;\n            }\n            catch (e) {\n                return null;\n            }\n        })\n            .filter(commandID => !!commandID);\n    }\n    get isEnabled() {\n        return this._status.enabled;\n    }\n    configure(settings) {\n        // TODO\n        this.language = 'en-US';\n        this.speak = settings.composite.speak;\n        this.confidenceThreshold = settings.composite.confidenceThreshold;\n        this.suggestionThreshold = settings.composite.suggestionThreshold;\n        this.commands = settings.composite.commands;\n    }\n    enable() {\n        this._status.enabled = true;\n        this.recognition.start();\n        this.counter = 0;\n        this.statusChanged.emit(this._status);\n    }\n    disable() {\n        this._status.enabled = false;\n        this.recognition.stop();\n        this.statusChanged.emit(this._status);\n    }\n}\n","import { LabIcon } from '@jupyterlab/ui-components';\nimport microphone from '../style/icons/microphone.svg';\nimport microphoneOff from '../style/icons/microphone-off.svg';\nexport const recognitionEnabledIcon = new LabIcon({\n    name: 'voice:enabled',\n    svgstr: microphone\n});\nexport const recognitionDisabledIcon = new LabIcon({\n    name: 'voice:disabled',\n    svgstr: microphoneOff\n});\n","import { JSONExt } from '@lumino/coreutils';\nimport { ICommandPalette } from '@jupyterlab/apputils';\nimport { IStatusBar } from '@jupyterlab/statusbar';\nimport { ITranslator, nullTranslator } from '@jupyterlab/translation';\nimport { ISettingRegistry } from '@jupyterlab/settingregistry';\nimport { VoiceControlStatusIndicator } from './components/status';\nimport { VoiceController } from './controller';\nimport { scrollBy, typeText, moveCursor, deleteText } from './commands';\nconst PLUGIN_ID = 'jupyterlab-voice-control:plugin';\n/**\n * Initialization data for the jupyterlab-voice-control extension.\n */\nconst plugin = {\n    id: PLUGIN_ID,\n    autoStart: true,\n    requires: [ICommandPalette],\n    optional: [ISettingRegistry, IStatusBar, ITranslator],\n    activate: (app, palette, settingRegistry, statusBar, translator) => {\n        console.log('JupyterLab extension jupyterlab-voice-control is activated!');\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab-voice-control');\n        const controller = new VoiceController(app.commands, trans, palette);\n        let canonical;\n        let configuredVoiceCommands = [];\n        /**\n         * Populate the plugin's schema defaults.\n         */\n        const populate = (schema) => {\n            const commandsSchema = schema.properties.commands;\n            const defaultCommands = commandsSchema.default.map(voiceCommand => voiceCommand.command);\n            const availableCommands = new Set(app.commands.listCommands());\n            const userCommands = configuredVoiceCommands.filter(x => !defaultCommands.includes(x));\n            const commandsUnion = new Set([\n                ...availableCommands,\n                ...userCommands,\n                ...defaultCommands\n            ]);\n            console.log(userCommands);\n            const unavailableUserCommands = userCommands.filter(x => !availableCommands.has(x));\n            if (unavailableUserCommands.length) {\n                console.warn('User commands', unavailableUserCommands, 'provided for custom voice commands are not available in this installation of JupyterLab');\n            }\n            const unavailableDefaultCommands = defaultCommands.filter(x => !availableCommands.has(x));\n            if (unavailableDefaultCommands.length) {\n                console.warn('Default commands', unavailableDefaultCommands, 'are not available in this installation of JupyterLab');\n            }\n            commandsSchema.items.properties.command.enum = [...commandsUnion];\n        };\n        if (settingRegistry) {\n            settingRegistry\n                .load(plugin.id)\n                .then(settings => {\n                configuredVoiceCommands = settings.composite.commands.map(voiceCommand => voiceCommand.command);\n                settings.changed.connect(controller.configure.bind(controller));\n                controller.configure(settings);\n            })\n                .catch(reason => {\n                console.error('Failed to load settings for jupyterlab-voice-control.', reason);\n            });\n            settingRegistry.transform(plugin.id, {\n                fetch: plugin => {\n                    // Only override the canonical schema the first time.\n                    if (!canonical) {\n                        canonical = JSONExt.deepCopy(plugin.schema);\n                        populate(canonical);\n                    }\n                    return {\n                        data: plugin.data,\n                        id: plugin.id,\n                        raw: plugin.raw,\n                        schema: canonical,\n                        version: plugin.version\n                    };\n                }\n            });\n        }\n        if (statusBar) {\n            statusBar.registerStatusItem(PLUGIN_ID, {\n                item: new VoiceControlStatusIndicator(controller.statusChanged, trans, controller),\n                rank: 900\n            });\n        }\n        app.commands.addCommand('vc:start-listening', {\n            label: trans.__('Enable voice control'),\n            execute: () => controller.enable(),\n            isVisible: () => !controller.isEnabled\n        });\n        app.commands.addCommand('vc:stop-listening', {\n            label: trans.__('Enable voice control'),\n            execute: () => controller.enable(),\n            isVisible: () => !controller.isEnabled\n        });\n        app.commands.addCommand('vc:scroll-by', {\n            label: trans.__('Scroll Focused Element By'),\n            execute: args => scrollBy(args)\n        });\n        app.commands.addCommand('vc:type-text', {\n            label: trans.__('Type Text Into Focused Element'),\n            execute: args => typeText(args, app.shell.currentWidget)\n        });\n        app.commands.addCommand('vc:delete-text', {\n            label: trans.__('Delete Text From Focused Element'),\n            execute: args => deleteText(args, app.shell.currentWidget)\n        });\n        app.commands.addCommand('vc:accept-suggestion', {\n            label: trans.__('Accept Voice Control Suggestion'),\n            execute: args => controller.acceptSuggestion(args)\n        });\n        app.commands.addCommand('vc:open-notebook', {\n            label: trans.__('Open Notebook By Name'),\n            execute: args => app.commands.execute('filebrowser:open-path', {\n                path: args.path + '.ipynb'\n            })\n        });\n        app.commands.addCommand('vc:move-cursor', {\n            label: trans.__('Move Cursor In Editor'),\n            execute: args => moveCursor(args)\n        });\n    }\n};\nexport default plugin;\n","export default \"<svg width=\\\"16\\\" viewBox=\\\"0 0 24 24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n  <g class=\\\"jp-icon3 jp-icon-selectable\\\" fill=\\\"#4F4F4F\\\">\\n    <path d=\\\"M19,11C19,12.19 18.66,13.3 18.1,14.28L16.87,13.05C17.14,12.43 17.3,11.74 17.3,11H19M15,11.16L9,5.18V5A3,3 0 0,1 12,2A3,3 0 0,1 15,5V11L15,11.16M4.27,3L21,19.73L19.73,21L15.54,16.81C14.77,17.27 13.91,17.58 13,17.72V21H11V17.72C7.72,17.23 5,14.41 5,11H6.7C6.7,14 9.24,16.1 12,16.1C12.81,16.1 13.6,15.91 14.31,15.58L12.65,13.92L12,14A3,3 0 0,1 9,11V10.28L3,4.27L4.27,3Z\\\" />\\n  </g>\\n</svg>\";","export default \"<svg width=\\\"16\\\" viewBox=\\\"0 0 24 24\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n  <g class=\\\"jp-icon3 jp-icon-selectable\\\" fill=\\\"#4F4F4F\\\">\\n    <path d=\\\"M12,2A3,3 0 0,1 15,5V11A3,3 0 0,1 12,14A3,3 0 0,1 9,11V5A3,3 0 0,1 12,2M19,11C19,14.53 16.39,17.44 13,17.93V21H11V17.93C7.61,17.44 5,14.53 5,11H7A5,5 0 0,0 12,16A5,5 0 0,0 17,11H19Z\\\" />\\n  </g>\\n</svg>\";"],"names":[],"sourceRoot":""}