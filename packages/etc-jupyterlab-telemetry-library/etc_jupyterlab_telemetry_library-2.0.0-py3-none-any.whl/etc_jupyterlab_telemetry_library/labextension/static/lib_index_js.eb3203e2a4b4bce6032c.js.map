{"version":3,"file":"lib_index_js.eb3203e2a4b4bce6032c.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAuD;AACZ;AAC3C;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,iBAAiB;AACvF;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA,qBAAqB,iCAAiC;AACtD;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,uBAAuB;AACzC,kCAAkC,qDAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAoD;AAChF;AACA;AACA,iCAAiC,0BAA0B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,uBAAuB;AACzC,iCAAiC,qDAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kFAAgC;AACpD;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,uBAAuB;AACzC,qCAAqC,qDAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uCAAuC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,uBAAuB;AACzC,sCAAsC,qDAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,uBAAuB;AACzC,mCAAmC,qDAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA,mEAAmE,iCAAiC;AACpG;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,uBAAuB;AACzC,8BAA8B,qDAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA,2BAA2B,gDAAgD;AAC3E;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,uBAAuB;AACzC,gCAAgC,qDAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA,2BAA2B,gDAAgD;AAC3E;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,uBAAuB;AACzC,gCAAgC,qDAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,QAAQ,mEAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC5W+C;AACS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kDAAkD;AACzD;AACA,qBAAqB,+EAA6B;AAClD,uBAAuB,8DAAW;AAClC;AACA;AACA;AACA,yBAAyB,8EAA4B;AACrD;AACA;AACA,kBAAkB,+EAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gFAA8B;AAChD;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AClCwD;AACd;AACsF;AAC+C;AACxI;AACvC;AACO,kDAAkD,oDAAK;AAC9D;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA,aAAa,eAAe;AAC5B,mDAAmD,qCAAqC;AACxF;AACA;AACO;AACP,kBAAkB,uBAAuB;AACzC,qCAAqC,sDAAiB;AACtD;AACA;AACA,SAAS;AACT,qCAAqC,sDAAiB;AACtD;AACA;AACA,SAAS;AACT,sCAAsC,uDAAkB;AACxD;AACA;AACA,SAAS;AACT,kCAAkC,mDAAc;AAChD;AACA;AACA,SAAS;AACT,uCAAuC,wDAAmB;AAC1D;AACA;AACA,SAAS;AACT,yCAAyC,0DAAqB;AAC9D;AACA;AACA,SAAS;AACT,gCAAgC,iDAAY;AAC5C;AACA;AACA,SAAS;AACT,mCAAmC,oDAAe;AAClD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAgB;AAC/B,eAAe,0IAAmC;AAClD;AACA,8BAA8B,oDAAU;AACxC,uBAAuB,UAAU,IAAI,QAAQ;AAC7C,6BAA6B,oDAAU;AACvC,8FAA8F,gBAAgB;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,8BAA8B;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,eAAe;AAClF,+FAA+F,eAAe;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,iEAAe,MAAM,EAAC","sources":["webpack://@educational-technology-collective/etc_jupyterlab_telemetry_library/./lib/events.js","webpack://@educational-technology-collective/etc_jupyterlab_telemetry_library/./lib/handler.js","webpack://@educational-technology-collective/etc_jupyterlab_telemetry_library/./lib/index.js"],"sourcesContent":["import { NotebookActions } from \"@jupyterlab/notebook\";\nimport { Signal } from '@lumino/signaling';\n// export class NotebookCloseEvent {\n//     private _notebookClosed: Signal<NotebookCloseEvent, any> = new Signal(this);\n//     // private _notebookPanel: NotebookPanel;\n//     // private _notebook: Notebook;\n//     constructor({ notebookPanel, config }: INotebookEventOptions) {\n//         // this._notebookPanel = notebookPanel;\n//         // this._notebook = notebookPanel.content;\n//         if (config['mentoracademy.org/schemas/events/1.0.0/NotebookCloseEvent']['enable']) {\n//             (async () => {\n//                 try {\n//                     await notebookPanel.revealed;\n//                     console.log(notebookPanel.id);\n//                     let node = document.querySelector(`[data-id=\"${notebookPanel.id}\"] .lm-TabBar-tabCloseIcon`);\n//                     node?.addEventListener('click', () => {\n//                         console.log(notebookPanel.content.widgets);\n//                     })\n//                 }\n//                 catch (e) {\n//                     console.error(e);\n//                 }\n//             })();\n//         }\n//     }\n//     onDisposed() {\n//         Signal.disconnectAll(this);\n//     }\n//     // private onNotebookDisposed(): void {\n//     //     console.log('private onNotebookDisposed(): void {');\n//     //     let cells = this._notebook.widgets.map((cell: Cell<ICellModel>, index: number) =>\n//     //         ({ id: cell.model.id, index: index })\n//     //     );\n//     //     this._notebookClosed.emit({\n//     //         event_name: \"close_notebook\",\n//     //         cells: cells,\n//     //         notebookPanel: this._notebookPanel\n//     //     });\n//     // }\n//     get notebookClosed(): ISignal<NotebookCloseEvent, any> {\n//         return this._notebookClosed\n//     }\n// }\nexport class NotebookSaveEvent {\n    constructor({ notebookPanel, config }) {\n        this._notebookSaved = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        notebookPanel.disposed.connect(this.onDisposed, this);\n        if (config.notebook_save_event) {\n            (async () => {\n                try {\n                    await notebookPanel.revealed;\n                    notebookPanel.context.saveState.connect(this.onSaveState, this);\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            })();\n        }\n    }\n    onDisposed() {\n        Signal.disconnectAll(this);\n    }\n    onSaveState(context, saveState) {\n        let cell;\n        let cells;\n        let index;\n        if (saveState.match(\"completed\")) {\n            cells = [];\n            for (index = 0; index < this._notebookPanel.content.widgets.length; index++) {\n                cell = this._notebookPanel.content.widgets[index];\n                if (this._notebookPanel.content.isSelectedOrActive(cell)) {\n                    cells.push({ id: cell.model.id, index });\n                }\n            }\n            this._notebookSaved.emit({\n                event_name: \"save_notebook\",\n                cells: cells,\n                notebookPanel: this._notebookPanel\n            });\n        }\n    }\n    get notebookSaved() {\n        return this._notebookSaved;\n    }\n}\nexport class CellExecutionEvent {\n    constructor({ notebookPanel, config }) {\n        this._cellExecuted = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        this._notebook = notebookPanel.content;\n        notebookPanel.disposed.connect(this.onDisposed, this);\n        if (config.notebook_cell_execution_event) {\n            (async () => {\n                try {\n                    await notebookPanel.revealed;\n                    NotebookActions.executed.connect(this.onExecuted, this);\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            })();\n        }\n    }\n    onDisposed() {\n        Signal.disconnectAll(this);\n    }\n    onExecuted(_, args) {\n        if (args.notebook.model === this._notebook.model) {\n            let cells = [\n                {\n                    id: args.cell.model.id,\n                    index: this._notebook.widgets.findIndex((value) => value == args.cell)\n                }\n            ];\n            this._cellExecuted.emit({\n                event_name: \"cell_executed\",\n                cells: cells,\n                notebookPanel: this._notebookPanel\n            });\n        }\n    }\n    get cellExecuted() {\n        return this._cellExecuted;\n    }\n}\nexport class NotebookScrollEvent {\n    constructor({ notebookPanel, config }) {\n        this._notebookScrolled = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        this._notebook = notebookPanel.content;\n        this._timeout = 0;\n        this.onScrolled = this.onScrolled.bind(this);\n        notebookPanel.disposed.connect(this.onDisposed, this);\n        if (config.notebook_scroll_event) {\n            (async () => {\n                try {\n                    await notebookPanel.revealed;\n                    notebookPanel.content.node.addEventListener(\"scroll\", this.onScrolled, false);\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            })();\n        }\n    }\n    onDisposed() {\n        Signal.disconnectAll(this);\n    }\n    onScrolled(e) {\n        e.stopPropagation();\n        clearTimeout(this._timeout);\n        this._timeout = setTimeout(() => {\n            let cells = [];\n            let cell;\n            let index;\n            let id;\n            for (index = 0; index < this._notebook.widgets.length; index++) {\n                cell = this._notebook.widgets[index];\n                let cellTop = cell.node.offsetTop;\n                let cellBottom = cell.node.offsetTop + cell.node.offsetHeight;\n                let viewTop = this._notebook.node.scrollTop;\n                let viewBottom = this._notebook.node.scrollTop + this._notebook.node.clientHeight;\n                if (cellTop > viewBottom || cellBottom < viewTop) {\n                    continue;\n                }\n                id = cell.model.id;\n                cells.push({ id, index });\n            }\n            this._notebookScrolled.emit({\n                event_name: \"scroll\",\n                cells: cells,\n                notebookPanel: this._notebookPanel\n            });\n        }, 1000);\n    }\n    get notebookScrolled() {\n        return this._notebookScrolled;\n    }\n}\nexport class ActiveCellChangeEvent {\n    constructor({ notebookPanel, config }) {\n        this._activeCellChanged = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        this._notebook = notebookPanel.content;\n        notebookPanel.disposed.connect(this.onDisposed, this);\n        if (config.notebook_active_cell_change_event) {\n            (async () => {\n                try {\n                    await notebookPanel.revealed;\n                    notebookPanel.content.activeCellChanged.connect(this.onActiveCellChanged, this);\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            })();\n        }\n    }\n    onDisposed() {\n        Signal.disconnectAll(this);\n    }\n    onActiveCellChanged(send, args) {\n        let cells = [\n            {\n                id: args.model.id,\n                index: this._notebook.widgets.findIndex((value) => value == args)\n            }\n        ];\n        this._activeCellChanged.emit({\n            event_name: \"active_cell_changed\",\n            cells: cells,\n            notebookPanel: this._notebookPanel\n        });\n    }\n    get activeCellChanged() {\n        return this._activeCellChanged;\n    }\n}\nexport class NotebookOpenEvent {\n    constructor({ notebookPanel, config }) {\n        this._notebookOpened = new Signal(this);\n        this._once = false;\n        this._notebookPanel = notebookPanel;\n        this._notebook = notebookPanel.content;\n        notebookPanel.disposed.connect(this.onDisposed, this);\n        if (config.notebook_open_event) {\n            if (!this._once) {\n                (async () => {\n                    try {\n                        await notebookPanel.revealed;\n                        this.onNotebookOpened();\n                    }\n                    catch (e) {\n                        console.error(e);\n                    }\n                })();\n            }\n        }\n    }\n    onDisposed() {\n        Signal.disconnectAll(this);\n    }\n    onNotebookOpened() {\n        let cells = this._notebook.widgets.map((cell, index) => ({ id: cell.model.id, index: index }));\n        this._notebookOpened.emit({\n            event_name: \"open_notebook\",\n            cells: cells,\n            notebookPanel: this._notebookPanel\n        });\n        this._once = true;\n    }\n    get notebookOpened() {\n        return this._notebookOpened;\n    }\n}\nexport class CellAddEvent {\n    constructor({ notebookPanel, config }) {\n        this._cellAdded = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        notebookPanel.disposed.connect(this.onDisposed, this);\n        if (config.notebook_cell_add_event) {\n            (async () => {\n                var _a;\n                try {\n                    await notebookPanel.revealed;\n                    (_a = notebookPanel.content.model) === null || _a === void 0 ? void 0 : _a.cells.changed.connect(this.onCellsChanged, this);\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            })();\n        }\n    }\n    onDisposed() {\n        Signal.disconnectAll(this);\n    }\n    onCellsChanged(sender, args) {\n        if (args.type == \"add\") {\n            let cells = [{ id: args.newValues[0].id, index: args.newIndex }];\n            this._cellAdded.emit({\n                event_name: \"add_cell\",\n                cells: cells,\n                notebookPanel: this._notebookPanel\n            });\n        }\n    }\n    get cellAdded() {\n        return this._cellAdded;\n    }\n}\nexport class CellRemoveEvent {\n    constructor({ notebookPanel, config }) {\n        this._cellRemoved = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        notebookPanel.disposed.connect(this.onDisposed, this);\n        if (config.notebook_cell_remove_event) {\n            (async () => {\n                var _a;\n                try {\n                    await notebookPanel.revealed;\n                    (_a = notebookPanel.content.model) === null || _a === void 0 ? void 0 : _a.cells.changed.connect(this.onCellsChanged, this);\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            })();\n        }\n    }\n    onDisposed() {\n        Signal.disconnectAll(this);\n    }\n    onCellsChanged(sender, args) {\n        if (args.type == \"remove\") {\n            let cells = [{ id: args.oldValues[0].id, index: args.oldIndex }];\n            this._cellRemoved.emit({\n                event_name: \"remove_cell\",\n                cells: cells,\n                notebookPanel: this._notebookPanel\n            });\n        }\n    }\n    get cellRemoved() {\n        return this._cellRemoved;\n    }\n}\nexport class CellErrorEvent {\n    constructor({ notebookPanel, config }) {\n        this._cellErrored = new Signal(this);\n        this._notebookPanel = notebookPanel;\n        notebookPanel.disposed.connect(this.onDisposed, this);\n        if (config.notebook_cell_error_event) {\n            (async () => {\n                try {\n                    await notebookPanel.revealed;\n                    notebookPanel.sessionContext.iopubMessage.connect(this.onCellErrored, this);\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            })();\n        }\n    }\n    onDisposed() {\n        Signal.disconnectAll(this);\n    }\n    onCellErrored(_, args) {\n        var _a;\n        if (args.header.msg_type == \"error\") {\n            let cells = [\n                {\n                    id: (_a = this._notebookPanel.content.activeCell) === null || _a === void 0 ? void 0 : _a.model.id,\n                    index: this._notebookPanel.content.activeCellIndex\n                }\n            ];\n            this._cellErrored.emit({\n                event_name: \"cell_errored\",\n                cells: cells,\n                notebookPanel: this._notebookPanel\n            });\n        }\n    }\n    get cellErrored() {\n        return this._cellErrored;\n    }\n}\n","import { URLExt } from '@jupyterlab/coreutils';\nimport { ServerConnection } from '@jupyterlab/services';\n/**\n * Call the API extension\n *\n * @param endPoint API REST end point for the extension\n * @param init Initial values for the request\n * @returns The response body interpreted as JSON\n */\nexport async function requestAPI(endPoint = '', init = {}) {\n    // Make request to Jupyter API\n    const settings = ServerConnection.makeSettings();\n    const requestUrl = URLExt.join(settings.baseUrl, 'etc-jupyterlab-telemetry-library', // API Namespace\n    endPoint);\n    let response;\n    try {\n        response = await ServerConnection.makeRequest(requestUrl, init, settings);\n    }\n    catch (error) {\n        throw new ServerConnection.NetworkError(error);\n    }\n    let data = await response.text();\n    if (data.length > 0) {\n        try {\n            data = JSON.parse(data);\n        }\n        catch (error) {\n            console.log('Not a JSON response body.', response);\n        }\n    }\n    if (!response.ok) {\n        throw new ServerConnection.ResponseError(response, data.message || data);\n    }\n    return data;\n}\n","import { INotebookTracker } from '@jupyterlab/notebook';\nimport { Token } from '@lumino/coreutils';\nimport { IETCJupyterLabNotebookStateProvider } from \"@educational-technology-collective/etc_jupyterlab_notebook_state_provider\";\nimport { NotebookOpenEvent, NotebookSaveEvent, CellExecutionEvent, NotebookScrollEvent, ActiveCellChangeEvent, CellAddEvent, CellRemoveEvent, CellErrorEvent } from \"./events\";\nimport { requestAPI } from \"./handler\";\nconst PLUGIN_ID = '@educational-technology-collective/etc_jupyterlab_telemetry_library:plugin';\nexport const IETCJupyterLabTelemetryLibraryFactory = new Token(PLUGIN_ID);\nclass ETCJupyterLabTelemetryLibraryFactory {\n    constructor({ config }) {\n        this._config = config;\n    }\n    create({ notebookPanel }) {\n        return new ETCJupyterLabTelemetryLibrary({ notebookPanel, config: this._config });\n    }\n}\nexport class ETCJupyterLabTelemetryLibrary {\n    constructor({ notebookPanel, config }) {\n        this.notebookOpenEvent = new NotebookOpenEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.notebookSaveEvent = new NotebookSaveEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.cellExecutionEvent = new CellExecutionEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.cellErrorEvent = new CellErrorEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.notebookScrollEvent = new NotebookScrollEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.activeCellChangeEvent = new ActiveCellChangeEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.cellAddEvent = new CellAddEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n        this.cellRemoveEvent = new CellRemoveEvent({\n            notebookPanel: notebookPanel,\n            config: config\n        });\n    }\n}\n/**\n * Initialization data for the @educational-technology-collective/etc_jupyterlab_telemetry_extension extension.\n */\nconst plugin = {\n    id: PLUGIN_ID,\n    autoStart: true,\n    provides: IETCJupyterLabTelemetryLibraryFactory,\n    requires: [INotebookTracker],\n    optional: [IETCJupyterLabNotebookStateProvider],\n    activate: async (app, notebookTracker, etcJupyterLabNotebookStateProvider) => {\n        const VERSION = await requestAPI(\"version\");\n        console.log(`${PLUGIN_ID}, ${VERSION}`);\n        const CONFIG = await requestAPI(\"config\");\n        let etcJupyterLabTelemetryLibraryFactory = new ETCJupyterLabTelemetryLibraryFactory({ config: CONFIG });\n        // // TEST\n        // class MessageAdapter {\n        //   constructor() { }\n        //   log(sender: any, args: any) {\n        //     let notebookPanel = args.notebookPanel;\n        //     delete args.notebookPanel;\n        //     let notebookState = etcJupyterLabNotebookStateProvider.getNotebookState({ notebookPanel: notebookPanel })\n        //     let data = {\n        //       ...args, ...notebookState\n        //     }\n        //     console.log(\"etc_jupyterlab_telemetry_extension\", data);\n        //   }\n        // }\n        // let messageAdapter = new MessageAdapter();\n        // notebookTracker.widgetAdded.connect(async (sender: INotebookTracker, notebookPanel: NotebookPanel) => {\n        //   etcJupyterLabNotebookStateProvider.addNotebookPanel({ notebookPanel });\n        //   let etcJupyterLabTelemetryLibrary = etcJupyterLabTelemetryLibraryFactory.create({ notebookPanel });\n        //   etcJupyterLabTelemetryLibrary.notebookOpenEvent.notebookOpened.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.notebookSaveEvent.notebookSaved.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.activeCellChangeEvent.activeCellChanged.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.cellAddEvent.cellAdded.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.cellRemoveEvent.cellRemoved.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.notebookScrollEvent.notebookScrolled.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.cellExecutionEvent.cellExecuted.connect(messageAdapter.log);\n        //   etcJupyterLabTelemetryLibrary.cellErrorEvent.cellErrored.connect(messageAdapter.log);\n        // });\n        // // TEST\n        return etcJupyterLabTelemetryLibraryFactory;\n    }\n};\nexport default plugin;\n"],"names":[],"sourceRoot":""}